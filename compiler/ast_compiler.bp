use "/stdlib/memory.bp";
use "./utils.bp";
use "./wasm_output.bp";
use "./ast_compiler_base.bp";
use "./ast_parser.bp";
use "./ast_semantics.bp";

fn compile_impl(
    input_ptr: i32,
    input_len: i32,
    out_ptr: i32,
    current_module_index: i32,
) -> i32 {
    initialize_layout(out_ptr);
    record_type_metadata_debug(out_ptr, 0, 0, 0);
    store_i32(scratch_module_base_ptr(out_ptr), input_ptr);
    store_i32(scratch_module_len_ptr(out_ptr), input_len);
    store_i32(scratch_module_index_ptr(out_ptr), current_module_index);
    let ast_base: i32 = ast_program_base(out_ptr, input_len);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(
        input_ptr,
        input_len,
        ast_base,
        0,
        current_module_index,
    );
    if func_count <= 0 {
        if ast_constants_count(ast_base) > 0 {
            record_type_metadata_debug(out_ptr, 99, 0, 0);
            record_type_metadata_failure(out_ptr);
        } else if out_ptr > 0 {
            if load_u8(out_ptr) == 0 {
                write_failure_detail_with_location(
                    out_ptr,
                    current_module_index,
                    input_ptr,
                    input_len,
                    0,
                    21,
                    "parsing source failed",
                );
            }
        }
        return -1;
    }
    if interpret_program_constants(out_ptr, ast_base, func_count) < 0 {
        record_type_metadata_debug(out_ptr, 100, 0, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if validate_program(out_ptr, ast_base, func_count) < 0 {
        record_type_metadata_debug(out_ptr, 101, 0, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let final_func_count: i32 = ast_functions_count(ast_base);
    if final_func_count < 0 {
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if write_type_metadata(out_ptr, ast_base) < 0 {
        record_type_metadata_debug(out_ptr, 102, 0, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }

    let produced_len: i32 = emit_program(out_ptr, ast_base, final_func_count);
    if produced_len <= 0 {
        record_type_metadata_debug(out_ptr, 103, 0, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    produced_len
}

fn report_missing_module_path(detail_out_ptr: i32) {
    if detail_out_ptr > 0 {
        clear_failure_location(detail_out_ptr);
        write_failure_detail(detail_out_ptr, 19, "module path missing");
    }
}

fn write_module_failure_with_location(
    detail_out_ptr: i32,
    path_ptr: i32,
    path_len: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) {
    if detail_out_ptr > 0 {
        store_failure_detail_location(detail_out_ptr, path_ptr, path_len, 1, 1);
        write_failure_detail(detail_out_ptr, MESSAGE_LEN, message);
    }
}

fn prepare_module_storage_allocation_failure(
    detail_out_ptr: i32,
    path_ptr: i32,
    path_len: i32,
) -> i32 {
    let resolved_ptr: i32 = resolve_module_failure_detail_ptr(detail_out_ptr);
    if resolved_ptr > 0 {
        store_failure_detail_location(resolved_ptr, path_ptr, path_len, 1, 1);
        if load_u8(resolved_ptr) == 0 {
            let message: [u8; 32] = "module storage allocation failed";
            write_module_failure_with_location(
                resolved_ptr,
                path_ptr,
                path_len,
                32,
                message,
            );
        }
    }
    resolved_ptr
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    compile_impl(input_ptr, input_len, out_ptr, -1)
}

// Allows the host environment to feed source code for a module into the module
// cache.  The storage is owned by the compiler runtime so subsequent imports can
// reuse the content without copying from the host again.
fn loadModuleFromSource(path_ptr: i32, content_ptr: i32) -> i32 {
    module_ensure_state_initialized();
    let mut detail_out_ptr: i32 = module_storage_top();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        report_missing_module_path(detail_out_ptr);
        return -1;
    }
    if path_len > MODULE_PATH_MAX_LENGTH {
        if detail_out_ptr > 0 {
            clear_failure_location(detail_out_ptr);
            write_failure_detail(
                detail_out_ptr,
                34,
                "module path exceeds maximum length",
            );
        }
        return -1;
    }
    let content_len: i32 = string_length(content_ptr);
    if content_len < 0 {
        write_module_failure_with_location(
            detail_out_ptr,
            path_ptr,
            path_len,
            22,
            "module content missing",
        );
        return -1;
    }
    let existing_index: i32 = module_find_index(path_ptr, path_len);
    let stored_path_ptr: i32 = if existing_index >= 0 {
        module_entry_path(existing_index)
    } else {
        if module_count() >= MODULE_MAX_COUNT {
            write_module_failure_with_location(
                detail_out_ptr,
                path_ptr,
                path_len,
                29,
                "module table capacity reached",
            );
            return -1;
        }
        let allocated_path_ptr: i32 = module_allocate_bytes(path_len + 1);
        if allocated_path_ptr <= 0 {
            detail_out_ptr = prepare_module_storage_allocation_failure(
                module_storage_top(),
                path_ptr,
                path_len,
            );
            return -1;
        }
        copy_bytes(allocated_path_ptr, path_ptr, path_len);
        store_u8(allocated_path_ptr + path_len, 0);
        allocated_path_ptr
    };
    let allocated_content_ptr: i32 = module_allocate_bytes(content_len + 1);
    if allocated_content_ptr <= 0 {
        let stored_path_len: i32 = if existing_index >= 0 {
            module_entry_path_len(existing_index)
        } else {
            path_len
        };
        detail_out_ptr = prepare_module_storage_allocation_failure(
            module_storage_top(),
            stored_path_ptr,
            stored_path_len,
        );
        return -1;
    }
    copy_bytes(allocated_content_ptr, content_ptr, content_len);
    store_u8(allocated_content_ptr + content_len, 0);
    let store_index: i32 = if existing_index >= 0 {
        existing_index
    } else {
        let index: i32 = module_count();
        module_set_count(index + 1);
        index
    };
    module_write_entry(store_index, stored_path_ptr, path_len, allocated_content_ptr, content_len);
    0
}

// Compiles a module that has previously been registered with
// `loadModuleFromSource`.  The implementation ensures the module graph is loaded
// only once and resolves imports transitively before running the main pipeline.
fn compileFromPath(path_ptr: i32) -> i32 {
    module_ensure_state_initialized();
    let detail_out_ptr: i32 = module_storage_top();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        report_missing_module_path(detail_out_ptr);
        return -1;
    }
    let index: i32 = module_find_index(path_ptr, path_len);
    if index < 0 {
        write_module_failure_with_location(
            detail_out_ptr,
            path_ptr,
            path_len,
            26,
            "module has not been loaded",
        );
        return -1;
    }
    module_clear_flags();
    module_entry_set_flags(index, MODULE_FLAG_IMPORTING);
    let module_path_ptr: i32 = module_entry_path(index);
    let module_path_len: i32 = module_entry_path_len(index);
    let input_ptr: i32 = module_entry_content(index);
    let input_len: i32 = module_entry_content_len(index);
    if input_ptr <= 0 || input_len <= 0 {
        write_module_failure_with_location(
            detail_out_ptr,
            module_path_ptr,
            module_path_len,
            35,
            "cached module entry missing content",
        );
        return -1;
    }
    let initial_top: i32 = module_storage_top();
    let out_ptr: i32 = align_to(initial_top, WORD_SIZE);
    module_set_storage_top(out_ptr);
    let required: i32 = out_ptr + ast_output_reserve(input_len);
    if ensure_memory_capacity(required) < 0 {
        write_module_failure_with_location(
            out_ptr,
            module_path_ptr,
            module_path_len,
            54,
            "failed to reserve linear memory for module compilation",
        );
        return -1;
    }
    let status: i32 = compile_impl(input_ptr, input_len, out_ptr, index);
    if status <= 0 {
        if out_ptr > 0 {
            if load_u8(out_ptr) == 0 {
                let module_index: i32 = index;
                let message: [u8; 25] = "module compilation failed";
                write_failure_detail_with_location(
                    out_ptr,
                    module_index,
                    input_ptr,
                    input_len,
                    0,
                    25,
                    message,
                );
            }
        }
    }
    status
}

fn main() -> i32 {
    0
}
