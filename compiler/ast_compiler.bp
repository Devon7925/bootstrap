fn write_byte(base: i32, offset: i32, value: i32) -> i32 {
    store_u8(base + offset, value & 255);
    offset + 1
}

fn write_u32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let mut byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        if remaining != 0 {
            byte = byte | 128;
        };
        out = write_byte(base, out, byte);
        if remaining == 0 {
            break;
        };
    };
    out
}

fn write_i32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        let mut out_byte: i32 = byte;
        if !done {
            out_byte = out_byte | 128;
        };
        out = write_byte(base, out, out_byte);
        if done {
            break;
        };
    };
    out
}

fn leb_u32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        count = count + 1;
        remaining = remaining >> 7;
        if remaining == 0 {
            break;
        };
    };
    count
}

fn leb_i32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        count = count + 1;
        if done {
            break;
        };
    };
    count
}

fn write_magic(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 97);
    out = write_byte(base, out, 115);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out
}

fn is_whitespace(byte: i32) -> bool {
    byte == 32 || byte == 9 || byte == 10 || byte == 13
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if byte == 47 {
            if idx + 1 < len {
                let next: i32 = load_u8(base + idx + 1);
                if next == 47 {
                    idx = idx + 2;
                    loop {
                        if idx >= len {
                            break;
                        };
                        let comment_byte: i32 = load_u8(base + idx);
                        if comment_byte == 10 {
                            idx = idx + 1;
                            break;
                        };
                        idx = idx + 1;
                    };
                    continue;
                };
            };
        };
        if !is_whitespace(byte) {
            break;
        };
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    };
    offset + 1
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122) || byte == 95
}

fn is_digit(byte: i32) -> bool {
    byte >= 48 && byte <= 57
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || is_digit(byte)
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    if offset + 1 >= len {
        return -1;
    };
    let first: i32 = load_u8(base + offset);
    let second: i32 = load_u8(base + offset + 1);
    if first != 102 || second != 110 {
        return -1;
    };
    let next: i32 = offset + 2;
    if next < len {
        let after: i32 = load_u8(base + next);
        if is_identifier_continue(after) {
            return -1;
        };
    };
    next
}

fn parse_identifier(base: i32, len: i32, offset: i32, out_start_ptr: i32, out_len_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let first: i32 = load_u8(base + offset);
    if !is_identifier_start(first) {
        return -1;
    };
    let mut idx: i32 = offset + 1;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_identifier_continue(byte) {
            break;
        };
        idx = idx + 1;
    };
    store_i32(out_start_ptr, offset);
    store_i32(out_len_ptr, idx - offset);
    idx
}

fn max_params() -> i32 {
    16
}

fn identifiers_match_source(
    base: i32,
    start_a: i32,
    len_a: i32,
    start_b: i32,
    len_b: i32,
) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(base + start_a + idx);
        let b_byte: i32 = load_u8(base + start_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn find_parameter_index(
    base: i32,
    params_table_ptr: i32,
    params_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let mut idx: i32 = 0;
    loop {
        if idx >= params_count {
            break;
        };
        let entry_ptr: i32 = params_table_ptr + idx * 8;
        let param_start: i32 = load_i32(entry_ptr);
        let param_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, param_start, param_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn parse_i32_type(base: i32, len: i32, offset: i32) -> i32 {
    if offset + 3 > len {
        return -1;
    };
    let byte0: i32 = load_u8(base + offset);
    let byte1: i32 = load_u8(base + offset + 1);
    let byte2: i32 = load_u8(base + offset + 2);
    if byte0 != 105 || byte1 != 51 || byte2 != 50 {
        return -1;
    };
    let next: i32 = offset + 3;
    if next < len {
        let after: i32 = load_u8(base + next);
        if is_identifier_continue(after) {
            return -1;
        };
    };
    next
}

fn parse_i32_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let mut idx: i32 = offset;
    let mut sign: i32 = 1;
    let first: i32 = load_u8(base + idx);
    if first == 45 {
        sign = -1;
        idx = idx + 1;
        if idx >= len {
            return -1;
        };
    };
    let mut digits: i32 = 0;
    let mut value: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_digit(byte) {
            break;
        };
        value = value * 10 + (byte - 48);
        idx = idx + 1;
        digits = digits + 1;
    };
    if digits == 0 {
        return -1;
    };
    store_i32(out_value_ptr, value * sign);
    idx
}

fn word_size() -> i32 {
    4
}

fn scratch_instr_offset() -> i32 {
    4096
}

fn scratch_expr_type_offset() -> i32 {
    4092
}

fn scratch_instr_base_offset() -> i32 {
    8192
}

fn scratch_instr_capacity() -> i32 {
    65536
}

fn scratch_functions_count_offset() -> i32 {
    851960
}

fn scratch_functions_base_offset() -> i32 {
    851968
}

fn type_entry_size() -> i32 {
    16
}

fn scratch_types_capacity() -> i32 {
    2048
}

fn scratch_types_base_offset() -> i32 {
    scratch_functions_base_offset() - scratch_types_capacity() * type_entry_size()
}

fn scratch_types_count_offset() -> i32 {
    scratch_types_base_offset() - word_size()
}

fn scratch_instr_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_instr_offset()
}

fn scratch_expr_type_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_expr_type_offset()
}

fn scratch_instr_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_instr_base_offset()
}

fn scratch_functions_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_functions_count_offset()
}

fn scratch_functions_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_functions_base_offset()
}

fn scratch_types_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_count_offset()
}

fn scratch_types_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_base_offset()
}

fn ast_max_functions() -> i32 {
    16
}

fn ast_function_entry_size() -> i32 {
    24
}

fn ast_names_capacity() -> i32 {
    512
}

fn ast_call_data_capacity() -> i32 {
    512
}

fn ast_program_base(out_ptr: i32) -> i32 {
    scratch_instr_base(out_ptr)
}

fn ast_functions_count_ptr(ast_base: i32) -> i32 {
    ast_base
}

fn ast_function_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_base + word_size() + index * ast_function_entry_size()
}

fn ast_names_len_ptr(ast_base: i32) -> i32 {
    ast_base + word_size() + ast_max_functions() * ast_function_entry_size()
}

fn ast_names_base(ast_base: i32) -> i32 {
    ast_names_len_ptr(ast_base) + word_size()
}

fn ast_call_data_len_ptr(ast_base: i32) -> i32 {
    ast_names_base(ast_base) + ast_names_capacity()
}

fn ast_call_data_base(ast_base: i32) -> i32 {
    ast_call_data_len_ptr(ast_base) + word_size()
}

fn ast_reset(ast_base: i32) {
    store_i32(ast_functions_count_ptr(ast_base), 0);
    store_i32(ast_names_len_ptr(ast_base), 0);
    store_i32(ast_call_data_len_ptr(ast_base), 0);
    ast_expr_reset(ast_base);
}

fn ast_store_name(ast_base: i32, source_base: i32, start: i32, len: i32) -> i32 {
    let name_len_ptr: i32 = ast_names_len_ptr(ast_base);
    let mut used: i32 = load_i32(name_len_ptr);
    if used + len > ast_names_capacity() {
        return -1;
    };
    let name_ptr: i32 = ast_names_base(ast_base) + used;
    let mut idx: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(source_base + start + idx);
        store_u8(name_ptr + idx, byte);
        idx = idx + 1;
    };
    used = used + len;
    store_i32(name_len_ptr, used);
    name_ptr
}

fn ast_call_data_alloc(ast_base: i32, word_count: i32) -> i32 {
    if word_count <= 0 {
        return -1;
    };
    let used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let used: i32 = load_i32(used_ptr);
    if used + word_count > ast_call_data_capacity() {
        return -1;
    };
    let entry_ptr: i32 = ast_call_data_base(ast_base) + used * word_size();
    store_i32(used_ptr, used + word_count);
    entry_ptr
}

fn call_metadata_name_ptr(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr)
}

fn call_metadata_name_len(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 4)
}

fn call_metadata_arg_count(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 8)
}

fn call_metadata_callee_index_ptr(metadata_ptr: i32) -> i32 {
    metadata_ptr + 12
}

fn call_metadata_args_base(metadata_ptr: i32) -> i32 {
    metadata_ptr + 16
}

fn ast_write_function_entry(
    ast_base: i32,
    index: i32,
    name_ptr: i32,
    name_len: i32,
    param_count: i32,
    body_kind: i32,
    body_data0: i32,
    body_data1: i32,
) {
    let entry_ptr: i32 = ast_function_entry_ptr(ast_base, index);
    store_i32(entry_ptr, name_ptr);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, param_count);
    store_i32(entry_ptr + 12, body_kind);
    store_i32(entry_ptr + 16, body_data0);
    store_i32(entry_ptr + 20, body_data1);
}

fn ast_extra_base(ast_base: i32) -> i32 {
    ast_call_data_base(ast_base) + ast_call_data_capacity() * word_size()
}

fn ast_expr_entry_size() -> i32 {
    16
}

fn ast_expr_capacity() -> i32 {
    256
}

fn ast_expr_count_ptr(ast_base: i32) -> i32 {
    ast_extra_base(ast_base)
}

fn ast_expr_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_extra_base(ast_base) + word_size() + index * ast_expr_entry_size()
}

fn ast_temp_base(ast_base: i32) -> i32 {
    ast_extra_base(ast_base) + word_size() + ast_expr_capacity() * ast_expr_entry_size()
}

fn ast_expr_reset(ast_base: i32) {
    store_i32(ast_expr_count_ptr(ast_base), 0);
}

fn ast_expr_count(ast_base: i32) -> i32 {
    load_i32(ast_expr_count_ptr(ast_base))
}

fn ast_expr_alloc(ast_base: i32, kind: i32, data0: i32, data1: i32, data2: i32) -> i32 {
    let count_ptr: i32 = ast_expr_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= ast_expr_capacity() {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, count);
    store_i32(entry_ptr, kind);
    store_i32(entry_ptr + 4, data0);
    store_i32(entry_ptr + 8, data1);
    store_i32(entry_ptr + 12, data2);
    store_i32(count_ptr, count + 1);
    count
}

fn ast_expr_alloc_literal(ast_base: i32, value: i32) -> i32 {
    ast_expr_alloc(ast_base, 0, value, 0, 0)
}

fn ast_expr_alloc_call(ast_base: i32, metadata_ptr: i32) -> i32 {
    ast_expr_alloc(ast_base, 1, metadata_ptr, 0, 0)
}

fn ast_expr_alloc_add(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    ast_expr_alloc(ast_base, 2, left_index, right_index, 0)
}

fn ast_expr_alloc_sub(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    ast_expr_alloc(ast_base, 3, left_index, right_index, 0)
}

fn ast_expr_alloc_mul(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    ast_expr_alloc(ast_base, 4, left_index, right_index, 0)
}

fn ast_expr_alloc_div(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    ast_expr_alloc(ast_base, 5, left_index, right_index, 0)
}

fn ast_expr_alloc_param(ast_base: i32, param_index: i32) -> i32 {
    ast_expr_alloc(ast_base, 6, param_index, 0, 0)
}

fn expression_node_from_parts(ast_base: i32, kind: i32, data0: i32, data1: i32) -> i32 {
    if kind == 0 {
        return ast_expr_alloc_literal(ast_base, data0);
    };
    if kind == 1 {
        return ast_expr_alloc_call(ast_base, data0);
    };
    if kind == 6 {
        return ast_expr_alloc_param(ast_base, data0);
    };
    data0
}

fn parse_basic_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    literal_ptr: i32,
    ident_start_ptr: i32,
    ident_len_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    nested_temp_base: i32,
) -> i32 {
    if cursor >= len {
        return -1;
    };
    let first_byte: i32 = load_u8(base + cursor);
    if first_byte == 40 {
        let mut next_cursor: i32 = cursor + 1;
        next_cursor = skip_whitespace(base, len, next_cursor);
        next_cursor = parse_expression(
            base,
            len,
            next_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            nested_temp_base,
            out_kind_ptr,
            out_data0_ptr,
            out_data1_ptr,
        );
        if next_cursor < 0 {
            return -1;
        };
        next_cursor = skip_whitespace(base, len, next_cursor);
        next_cursor = expect_char(base, len, next_cursor, 41);
        if next_cursor < 0 {
            return -1;
        };
        return skip_whitespace(base, len, next_cursor);
    };
    if first_byte == 45 || is_digit(first_byte) {
        let next_cursor: i32 = parse_i32_literal(base, len, cursor, literal_ptr);
        if next_cursor < 0 {
            return -1;
        };
        let value: i32 = load_i32(literal_ptr);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, value);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, next_cursor);
    };
    if !is_identifier_start(first_byte) {
        return -1;
    };
    let mut next_cursor: i32 = parse_identifier(base, len, cursor, ident_start_ptr, ident_len_ptr);
    if next_cursor < 0 {
        return -1;
    };
    let ident_start: i32 = load_i32(ident_start_ptr);
    let ident_len: i32 = load_i32(ident_len_ptr);
    next_cursor = skip_whitespace(base, len, next_cursor);
    if next_cursor < len {
        let next_byte: i32 = load_u8(base + next_cursor);
        if next_byte == 40 {
            let mut call_cursor: i32 = next_cursor + 1;
            call_cursor = skip_whitespace(base, len, call_cursor);
            let args_limit: i32 = max_params();
            let arg_kind_ptr: i32 = nested_temp_base;
            let arg_data0_ptr: i32 = nested_temp_base + 4;
            let arg_data1_ptr: i32 = nested_temp_base + 8;
            let args_list_ptr: i32 = nested_temp_base + 16;
            let arg_nested_base: i32 = nested_temp_base + 160;
            let mut arg_count: i32 = 0;
            if call_cursor < len {
                let maybe_close: i32 = load_u8(base + call_cursor);
                if maybe_close == 41 {
                    call_cursor = call_cursor + 1;
                } else {
                    loop {
                        if arg_count >= args_limit {
                            return -1;
                        };
                        call_cursor = parse_expression(
                            base,
                            len,
                            call_cursor,
                            ast_base,
                            params_table_ptr,
                            params_count,
                            arg_nested_base,
                            arg_kind_ptr,
                            arg_data0_ptr,
                            arg_data1_ptr,
                        );
                        if call_cursor < 0 {
                            return -1;
                        };
                        let arg_kind: i32 = load_i32(arg_kind_ptr);
                        let arg_data0: i32 = load_i32(arg_data0_ptr);
                        let arg_data1: i32 = load_i32(arg_data1_ptr);
                        let arg_index: i32 =
                            expression_node_from_parts(ast_base, arg_kind, arg_data0, arg_data1);
                        if arg_index < 0 {
                            return -1;
                        };
                        store_i32(args_list_ptr + arg_count * 4, arg_index);
                        arg_count = arg_count + 1;
                        call_cursor = skip_whitespace(base, len, call_cursor);
                        if call_cursor >= len {
                            return -1;
                        };
                        let delimiter: i32 = load_u8(base + call_cursor);
                        if delimiter == 44 {
                            call_cursor = skip_whitespace(base, len, call_cursor + 1);
                            if call_cursor >= len {
                                return -1;
                            };
                            let after_comma: i32 = load_u8(base + call_cursor);
                            if after_comma == 41 {
                                call_cursor = call_cursor + 1;
                                break;
                            };
                            continue;
                        };
                        if delimiter == 41 {
                            call_cursor = call_cursor + 1;
                            break;
                        };
                        return -1;
                    };
                };
            } else {
                return -1;
            };
            let name_ptr: i32 = ast_store_name(ast_base, base, ident_start, ident_len);
            if name_ptr < 0 {
                return -1;
            };
            let metadata_words: i32 = 4 + arg_count;
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, metadata_words);
            if metadata_ptr < 0 {
                return -1;
            };
            store_i32(metadata_ptr, name_ptr);
            store_i32(metadata_ptr + 4, ident_len);
            store_i32(metadata_ptr + 8, arg_count);
            store_i32(metadata_ptr + 12, -1);
            let mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= arg_count {
                    break;
                };
                let arg_value: i32 = load_i32(args_list_ptr + arg_idx * 4);
                store_i32(metadata_ptr + 16 + arg_idx * 4, arg_value);
                arg_idx = arg_idx + 1;
            };
            store_i32(out_kind_ptr, 1);
            store_i32(out_data0_ptr, metadata_ptr);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, call_cursor);
        };
    };
    let param_index: i32 =
        find_parameter_index(base, params_table_ptr, params_count, ident_start, ident_len);
    if param_index < 0 {
        return -1;
    };
    store_i32(out_kind_ptr, 6);
    store_i32(out_data0_ptr, param_index);
    store_i32(out_data1_ptr, 0);
    skip_whitespace(base, len, next_cursor)
}

fn parse_multiplicative_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    temp_base: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let literal_ptr: i32 = temp_base;
    let ident_start_ptr: i32 = temp_base + 4;
    let ident_len_ptr: i32 = temp_base + 8;
    let next_kind_ptr: i32 = temp_base + 12;
    let next_data0_ptr: i32 = temp_base + 16;
    let next_data1_ptr: i32 = temp_base + 20;
    let nested_temp_base: i32 = temp_base + 32;

    let mut current_cursor: i32 = parse_basic_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        literal_ptr,
        ident_start_ptr,
        ident_len_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
        nested_temp_base,
    );
    if current_cursor < 0 {
        return -1;
    };

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != 42 && next_byte != 47 {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_basic_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            literal_ptr,
            ident_start_ptr,
            ident_len_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
            nested_temp_base,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 = expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 = expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == 42 {
            ast_expr_alloc_mul(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_div(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    temp_base: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let mult_temp_base: i32 = temp_base;
    let next_kind_ptr: i32 = temp_base + 96;
    let next_data0_ptr: i32 = temp_base + 100;
    let next_data1_ptr: i32 = temp_base + 104;

    let mut current_cursor: i32 = parse_multiplicative_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        mult_temp_base,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != 43 && next_byte != 45 {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_multiplicative_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            mult_temp_base,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == 43 {
            ast_expr_alloc_add(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_sub(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_function(base: i32, len: i32, offset: i32, ast_base: i32, func_index: i32) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, offset);
    cursor = expect_keyword_fn(base, len, cursor);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let name_start_ptr: i32 = temp_base;
    let name_len_ptr: i32 = temp_base + 4;
    let params_count_ptr: i32 = temp_base + 8;
    let params_table_ptr: i32 = temp_base + 12;
    let params_table_end: i32 = params_table_ptr + max_params() * 8;
    let param_name_start_ptr: i32 = params_table_end;
    let param_name_len_ptr: i32 = param_name_start_ptr + 4;
    let expr_kind_ptr: i32 = param_name_len_ptr + 4;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_kind_ptr + 8;
    let expr_temp_base: i32 = expr_kind_ptr + 32;
    cursor = parse_identifier(base, len, cursor, name_start_ptr, name_len_ptr);
    if cursor < 0 {
        return -1;
    };
    let name_start: i32 = load_i32(name_start_ptr);
    let name_len: i32 = load_i32(name_len_ptr);

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, 40);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);
    store_i32(params_count_ptr, 0);
    let mut param_count: i32 = 0;
    loop {
        if cursor >= len {
            return -1;
        };
        let next_byte: i32 = load_u8(base + cursor);
        if next_byte == 41 {
            cursor = cursor + 1;
            break;
        };
        if param_count >= max_params() {
            return -1;
        };
        cursor = parse_identifier(base, len, cursor, param_name_start_ptr, param_name_len_ptr);
        if cursor < 0 {
            return -1;
        };
        let param_start: i32 = load_i32(param_name_start_ptr);
        let param_len: i32 = load_i32(param_name_len_ptr);
        let mut existing_idx: i32 = 0;
        loop {
            if existing_idx >= param_count {
                break;
            };
            let existing_ptr: i32 = params_table_ptr + existing_idx * 8;
            let existing_start: i32 = load_i32(existing_ptr);
            let existing_len: i32 = load_i32(existing_ptr + 4);
            if identifiers_match_source(base, existing_start, existing_len, param_start, param_len) {
                return -1;
            };
            existing_idx = existing_idx + 1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, 58);
        if cursor < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_i32_type(base, len, cursor);
        if cursor < 0 {
            return -1;
        };
        store_i32(params_table_ptr + param_count * 8, param_start);
        store_i32(params_table_ptr + param_count * 8 + 4, param_len);
        param_count = param_count + 1;
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            return -1;
        };
        let delimiter: i32 = load_u8(base + cursor);
        if delimiter == 44 {
            cursor = skip_whitespace(base, len, cursor + 1);
            if cursor >= len {
                return -1;
            };
            let maybe_close: i32 = load_u8(base + cursor);
            if maybe_close == 41 {
                cursor = cursor + 1;
                break;
            };
            continue;
        };
        if delimiter == 41 {
            cursor = cursor + 1;
            break;
        };
        return -1;
    };
    store_i32(params_count_ptr, param_count);
    cursor = skip_whitespace(base, len, cursor);

    cursor = expect_char(base, len, cursor, 45);
    if cursor < 0 {
        return -1;
    };
    cursor = expect_char(base, len, cursor, 62);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);
    cursor = parse_i32_type(base, len, cursor);
    if cursor < 0 {
        return -1;
    };

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, 123);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);

    cursor = parse_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        param_count,
        expr_temp_base,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
    );
    if cursor < 0 {
        return -1;
    };

    if cursor < len {
        let next: i32 = load_u8(base + cursor);
        if next == 59 {
            cursor = cursor + 1;
            cursor = skip_whitespace(base, len, cursor);
        };
    };
    cursor = expect_char(base, len, cursor, 125);
    if cursor < 0 {
        return -1;
    };

    let name_ptr: i32 = ast_store_name(ast_base, base, name_start, name_len);
    if name_ptr < 0 {
        return -1;
    };
    let body_kind: i32 = load_i32(expr_kind_ptr);
    let body_data0: i32 = load_i32(expr_data0_ptr);
    let body_data1: i32 = load_i32(expr_data1_ptr);
    if body_kind < 0 {
        return -1;
    };
    ast_write_function_entry(
        ast_base,
        func_index,
        name_ptr,
        name_len,
        param_count,
        body_kind,
        body_data0,
        body_data1,
    );
    cursor
}

fn parse_program(base: i32, len: i32, ast_base: i32) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, 0);
    let mut count: i32 = 0;
    loop {
        if cursor >= len {
            break;
        };
        if count >= ast_max_functions() {
            return -1;
        };
        cursor = parse_function(base, len, cursor, ast_base, count);
        if cursor < 0 {
            return -1;
        };
        count = count + 1;
        cursor = skip_whitespace(base, len, cursor);
    };
    store_i32(ast_functions_count_ptr(ast_base), count);
    count
}

fn identifiers_match(ptr_a: i32, len_a: i32, ptr_b: i32, len_b: i32) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(ptr_a + idx);
        let b_byte: i32 = load_u8(ptr_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn resolve_call_metadata(ast_base: i32, metadata_ptr: i32, func_count: i32) -> i32 {
    if metadata_ptr < 0 {
        return -1;
    };
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        };
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
        if resolve_expression(ast_base, arg_expr_index, func_count) < 0 {
            return -1;
        };
        arg_idx = arg_idx + 1;
    };

    let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
    let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
    let mut target_idx: i32 = 0;
    let mut found_idx: i32 = -1;
    loop {
        if target_idx >= func_count {
            break;
        };
        let target_entry_ptr: i32 = ast_function_entry_ptr(ast_base, target_idx);
        let target_name_ptr: i32 = load_i32(target_entry_ptr);
        let target_name_len: i32 = load_i32(target_entry_ptr + 4);
        if call_name_len == target_name_len {
            if identifiers_match(call_name_ptr, call_name_len, target_name_ptr, target_name_len) {
                let expected_params: i32 = load_i32(target_entry_ptr + 8);
                if expected_params != arg_count {
                    return -1;
                };
                found_idx = target_idx;
                break;
            };
        };
        target_idx = target_idx + 1;
    };
    if found_idx < 0 {
        return -1;
    };
    store_i32(call_metadata_callee_index_ptr(metadata_ptr), found_idx);
    0
}

fn validate_program(ast_base: i32, func_count: i32) -> i32 {
    if func_count <= 0 {
        return -1;
    };
    let mut main_count: i32 = 0;
    let main_name_ptr: i32 = ast_temp_base(ast_base);
    store_u8(main_name_ptr + 0, 109);
    store_u8(main_name_ptr + 1, 97);
    store_u8(main_name_ptr + 2, 105);
    store_u8(main_name_ptr + 3, 110);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        if name_len == 4 {
            if identifiers_match(name_ptr, name_len, main_name_ptr, 4) {
                main_count = main_count + 1;
                if param_count != 0 {
                    return -1;
                };
            };
        };
        let mut other_idx: i32 = idx + 1;
        loop {
            if other_idx >= func_count {
                break;
            };
            let other_entry_ptr: i32 = ast_function_entry_ptr(ast_base, other_idx);
            let other_name_ptr: i32 = load_i32(other_entry_ptr);
            let other_name_len: i32 = load_i32(other_entry_ptr + 4);
            if name_len == other_name_len {
                if identifiers_match(name_ptr, name_len, other_name_ptr, other_name_len) {
                    return -1;
                };
            };
            other_idx = other_idx + 1;
        };

        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if resolve_call_metadata(ast_base, metadata_ptr, func_count) < 0 {
                return -1;
            };
            store_i32(entry_ptr + 20, 0);
        } else {
            if body_kind == 2 {
                let expr_index: i32 = load_i32(entry_ptr + 16);
                if resolve_expression(ast_base, expr_index, func_count) < 0 {
                    return -1;
                };
                store_i32(entry_ptr + 20, 0);
            };
        };
        idx = idx + 1;
    };
    if main_count != 1 {
        return -1;
    };
    0
}

fn resolve_expression(ast_base: i32, expr_index: i32, func_count: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if resolve_call_metadata(ast_base, metadata_ptr, func_count) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 6 {
        return 0;
    };
    if kind == 2 || kind == 3 || kind == 4 || kind == 5 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression(ast_base, left_index, func_count) < 0 {
            return -1;
        };
        if resolve_expression(ast_base, right_index, func_count) < 0 {
            return -1;
        };
        return 0;
    };
    -1
}

fn expression_code_size(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        return 1 + leb_i32_len(value);
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut arg_idx: i32 = 0;
        loop {
            if arg_idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
            if arg_size < 0 {
                return -1;
            };
            total = total + arg_size;
            arg_idx = arg_idx + 1;
        };
        return total + 1 + leb_u32_len(callee_index);
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        return 1 + leb_u32_len(param_index);
    };
    if kind == 2 || kind == 3 || kind == 4 || kind == 5 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_size: i32 = expression_code_size(ast_base, left_index);
        if left_size < 0 {
            return -1;
        };
        let right_size: i32 = expression_code_size(ast_base, right_index);
        if right_size < 0 {
            return -1;
        };
        return left_size + right_size + 1;
    };
    -1
}

fn emit_expression(base: i32, offset: i32, ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = offset;
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, value);
        return out;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut out: i32 = offset;
        let mut arg_idx: i32 = 0;
        loop {
            if arg_idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            out = emit_expression(base, out, ast_base, arg_expr_index);
            if out < 0 {
                return -1;
            };
            arg_idx = arg_idx + 1;
        };
        out = write_byte(base, out, 16);
        out = write_u32_leb(base, out, callee_index);
        return out;
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 32);
        out = write_u32_leb(base, out, param_index);
        return out;
    };
    if kind == 2 || kind == 3 || kind == 4 || kind == 5 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, right_index);
        if out < 0 {
            return -1;
        };
        let opcode: i32 = if kind == 2 {
            106
        } else {
            if kind == 3 {
                107
            } else {
                if kind == 4 {
                    108
                } else {
                    109
                }
            }
        };
        out = write_byte(base, out, opcode);
        return out;
    };
    -1
}

fn emit_type_section(base: i32, offset: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        payload_size = payload_size + 1;
        payload_size = payload_size + leb_u32_len(param_count);
        payload_size = payload_size + param_count;
        payload_size = payload_size + leb_u32_len(1);
        payload_size = payload_size + 1;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        out = write_byte(base, out, 96);
        out = write_u32_leb(base, out, param_count);
        let mut param_idx: i32 = 0;
        loop {
            if param_idx >= param_count {
                break;
            };
            out = write_byte(base, out, 127);
            param_idx = param_idx + 1;
        };
        out = write_u32_leb(base, out, 1);
        out = write_byte(base, out, 127);
        idx = idx + 1;
    };
    out
}

fn emit_function_section(base: i32, offset: i32, func_count: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 3);
    let payload_size: i32 = leb_u32_len(func_count) + func_count;
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        out = write_u32_leb(base, out, idx);
        idx = idx + 1;
    };
    out
}

fn emit_memory_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 5);
    let payload_size: i32 = leb_u32_len(1) + 1 + leb_u32_len(16) + leb_u32_len(16);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, 1);
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, 16);
    out = write_u32_leb(base, out, 16);
    out
}

fn emit_export_section(base: i32, offset: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count + 1);
    payload_size = payload_size + leb_u32_len(6) + 6 + 1 + leb_u32_len(0);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_len: i32 = load_i32(entry_ptr + 4);
        payload_size = payload_size + leb_u32_len(name_len) + name_len + 1 + leb_u32_len(idx);
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 7);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count + 1);

    out = write_u32_leb(base, out, 6);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 101);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 111);
    out = write_byte(base, out, 114);
    out = write_byte(base, out, 121);
    out = write_byte(base, out, 2);
    out = write_u32_leb(base, out, 0);

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        out = write_u32_leb(base, out, name_len);
        let mut byte_idx: i32 = 0;
        loop {
            if byte_idx >= name_len {
                break;
            };
            let byte: i32 = load_u8(name_ptr + byte_idx);
            out = write_byte(base, out, byte);
            byte_idx = byte_idx + 1;
        };
        out = write_byte(base, out, 0);
        out = write_u32_leb(base, out, idx);
        idx = idx + 1;
    };
    out
}

fn emit_code_section(base: i32, offset: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = 1 + 1 + leb_i32_len(literal_value) + 1;
        } else {
            if body_kind == 1 {
                let metadata_ptr: i32 = load_i32(entry_ptr + 16);
                if metadata_ptr < 0 {
                    return -1;
                };
                let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
                if callee_index < 0 {
                    return -1;
                };
                let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
                let args_base: i32 = call_metadata_args_base(metadata_ptr);
                let mut args_size: i32 = 0;
                let mut arg_idx: i32 = 0;
                loop {
                    if arg_idx >= arg_count {
                        break;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                    let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                    if arg_size < 0 {
                        return -1;
                    };
                    args_size = args_size + arg_size;
                    arg_idx = arg_idx + 1;
                };
                body_size = 1 + args_size + 1 + leb_u32_len(callee_index) + 1;
            } else {
                let expr_index: i32 = load_i32(entry_ptr + 16);
                let expr_size: i32 = expression_code_size(ast_base, expr_index);
                if expr_size < 0 {
                    return -1;
                };
                body_size = 1 + expr_size + 1;
            };
        };
        payload_size = payload_size + leb_u32_len(body_size) + body_size;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 10);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = 1 + 1 + leb_i32_len(literal_value) + 1;
            out = write_u32_leb(base, out, body_size);
            out = write_u32_leb(base, out, 0);
            out = write_byte(base, out, 65);
            out = write_i32_leb(base, out, literal_value);
            out = write_byte(base, out, 11);
        } else {
            if body_kind == 1 {
                let metadata_ptr: i32 = load_i32(entry_ptr + 16);
                if metadata_ptr < 0 {
                    return -1;
                };
                let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
                if callee_index < 0 {
                    return -1;
                };
                let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
                let args_base: i32 = call_metadata_args_base(metadata_ptr);
                let mut args_size: i32 = 0;
                let mut arg_idx: i32 = 0;
                loop {
                    if arg_idx >= arg_count {
                        break;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                    let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                    if arg_size < 0 {
                        return -1;
                    };
                    args_size = args_size + arg_size;
                    arg_idx = arg_idx + 1;
                };
                body_size = 1 + args_size + 1 + leb_u32_len(callee_index) + 1;
                out = write_u32_leb(base, out, body_size);
                out = write_u32_leb(base, out, 0);
                let mut emit_idx: i32 = 0;
                loop {
                    if emit_idx >= arg_count {
                        break;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + emit_idx * 4);
                    out = emit_expression(base, out, ast_base, arg_expr_index);
                    if out < 0 {
                        return -1;
                    };
                    emit_idx = emit_idx + 1;
                };
                out = write_byte(base, out, 16);
                out = write_u32_leb(base, out, callee_index);
                out = write_byte(base, out, 11);
            } else {
                let expr_index: i32 = load_i32(entry_ptr + 16);
                let expr_size: i32 = expression_code_size(ast_base, expr_index);
                if expr_size < 0 {
                    return -1;
                };
                body_size = 1 + expr_size + 1;
                out = write_u32_leb(base, out, body_size);
                out = write_u32_leb(base, out, 0);
                out = emit_expression(base, out, ast_base, expr_index);
                if out < 0 {
                    return -1;
                };
                out = write_byte(base, out, 11);
            };
        };
        idx = idx + 1;
    };
    out
}

fn emit_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut offset: i32 = 0;
    offset = write_magic(out_ptr, offset);
    offset = emit_type_section(out_ptr, offset, ast_base, func_count);
    offset = emit_function_section(out_ptr, offset, func_count);
    offset = emit_memory_section(out_ptr, offset);
    offset = emit_export_section(out_ptr, offset, ast_base, func_count);
    offset = emit_code_section(out_ptr, offset, ast_base, func_count);
    offset
}

fn initialize_layout(out_ptr: i32) {
    store_i32(scratch_instr_offset_ptr(out_ptr), 0);
    store_i32(scratch_expr_type_ptr(out_ptr), -1);
    store_i32(scratch_functions_count_ptr(out_ptr), 0);
    store_i32(scratch_types_count_ptr(out_ptr), 0);
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    if input_len <= 0 {
        return -1;
    };

    initialize_layout(out_ptr);

    let ast_base: i32 = ast_program_base(out_ptr);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(input_ptr, input_len, ast_base);
    if func_count <= 0 {
        return -1;
    };

    if validate_program(ast_base, func_count) < 0 {
        return -1;
    };

    store_i32(scratch_functions_count_ptr(out_ptr), func_count);

    let produced_len: i32 = emit_program(out_ptr, ast_base, func_count);
    if produced_len <= 0 {
        return -1;
    };
    produced_len
}

fn main() -> i32 {
    0
}
