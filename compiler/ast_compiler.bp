use "/stdlib/memory.bp";
use "./utils.bp";
use "./wasm_output.bp";
use "./ast_compiler_base.bp";
use "./ast_parser.bp";
use "./ast_semantics.bp";

fn compile_impl(
    input_ptr: i32,
    input_len: i32,
    out_ptr: i32,
    current_module_index: i32,
) -> i32 {
    if input_len <= 0 {
        return -1;
    };

    initialize_layout(out_ptr);
    let ast_base: i32 = ast_program_base(out_ptr, input_len);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(
        input_ptr,
        input_len,
        ast_base,
        0,
        current_module_index,
    );
    if func_count <= 0 {
        return -1;
    };
    if interpret_program_constants(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };
    if validate_program(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };
    let final_func_count: i32 = ast_functions_count(ast_base);
    if final_func_count < 0 {
        return -1;
    };
    if write_type_metadata(out_ptr, ast_base) < 0 {
        return -1;
    };

    let produced_len: i32 = emit_program(out_ptr, ast_base, final_func_count);
    if produced_len <= 0 {
        return -1;
    };
    produced_len
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    compile_impl(input_ptr, input_len, out_ptr, -1)
}

// Allows the host environment to feed source code for a module into the module
// cache.  The storage is owned by the compiler runtime so subsequent imports can
// reuse the content without copying from the host again.
fn loadModuleFromSource(path_ptr: i32, content_ptr: i32) -> i32 {
    if path_ptr <= 0 || content_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        return -1;
    };
    let content_len: i32 = string_length(content_ptr);
    if content_len < 0 {
        return -1;
    };
    let existing_index: i32 = module_find_index(path_ptr, path_len);
    let mut stored_path_ptr: i32 = 0;
    if existing_index >= 0 {
        stored_path_ptr = module_entry_path(existing_index);
    } else {
        if module_count() >= MODULE_MAX_COUNT {
            return -1;
        };
        let allocated_path_ptr: i32 = module_allocate_bytes(path_len + 1);
        if allocated_path_ptr <= 0 {
            return -1;
        };
        copy_bytes(allocated_path_ptr, path_ptr, path_len);
        store_u8(allocated_path_ptr + path_len, 0);
        stored_path_ptr = allocated_path_ptr;
    };
    let allocated_content_ptr: i32 = module_allocate_bytes(content_len + 1);
    if allocated_content_ptr <= 0 {
        return -1;
    };
    copy_bytes(allocated_content_ptr, content_ptr, content_len);
    store_u8(allocated_content_ptr + content_len, 0);
    let mut store_index: i32 = existing_index;
    if store_index < 0 {
        store_index = module_count();
        module_set_count(store_index + 1);
    };
    module_write_entry(store_index, stored_path_ptr, path_len, allocated_content_ptr, content_len);
    0
}

// Compiles a module that has previously been registered with
// `loadModuleFromSource`.  The implementation ensures the module graph is loaded
// only once and resolves imports transitively before running the main pipeline.
fn compileFromPath(path_ptr: i32) -> i32 {
    if path_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let detail_out_ptr: i32 = module_storage_top();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        return -1;
    };
    let index: i32 = module_find_index(path_ptr, path_len);
    if index < 0 {
        if detail_out_ptr > 0 {
            write_failure_detail(detail_out_ptr, 26, "module has not been loaded");
        };
        return -1;
    };
    module_clear_flags();
    module_entry_set_flags(index, MODULE_FLAG_IMPORTING);
    let input_ptr: i32 = module_entry_content(index);
    let input_len: i32 = module_entry_content_len(index);
    if input_ptr <= 0 || input_len <= 0 {
        return -1;
    };
    let mut out_ptr: i32 = module_storage_top();
    if out_ptr <= 0 {
        module_ensure_state_initialized();
        out_ptr = module_storage_top();
    };
    out_ptr = align_to(out_ptr, WORD_SIZE);
    module_set_storage_top(out_ptr);
    let required: i32 = out_ptr + ast_output_reserve(input_len);
    if ensure_memory_capacity(required) < 0 {
        return -1;
    };
    let status: i32 = compile_impl(input_ptr, input_len, out_ptr, index);
    if status > 0 {
        module_entry_set_flags(index, MODULE_FLAG_IMPORTED);
    } else {
        module_entry_set_flags(index, 0);
    };
    status
}

fn main() -> i32 {
    0
}
