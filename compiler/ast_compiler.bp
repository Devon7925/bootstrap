use "/stdlib/memory.bp";
use "./utils.bp";
use "./wasm_output.bp";
use "./ast_compiler_base.bp";
use "./ast_parser.bp";
use "./ast_semantics.bp";

fn compile_impl(
    input_ptr: i32,
    input_len: i32,
    out_ptr: i32,
    current_module_index: i32,
) -> i32 {
    initialize_layout(out_ptr);
    store_i32(scratch_module_base_ptr(out_ptr), input_ptr);
    store_i32(scratch_module_len_ptr(out_ptr), input_len);
    store_i32(scratch_module_index_ptr(out_ptr), current_module_index);
    let ast_base: i32 = ast_program_base(out_ptr, input_len);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(
        input_ptr,
        input_len,
        ast_base,
        0,
        current_module_index,
    );
    if func_count <= 0 {
        return -1;
    };
    if interpret_program_constants(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };
    if validate_program(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };
    let final_func_count: i32 = ast_functions_count(ast_base);
    if final_func_count < 0 {
        return -1;
    };
    if write_type_metadata(out_ptr, ast_base) < 0 {
        return -1;
    };

    let produced_len: i32 = emit_program(out_ptr, ast_base, final_func_count);
    if produced_len <= 0 {
        return -1;
    };
    produced_len
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    compile_impl(input_ptr, input_len, out_ptr, -1)
}

// Allows the host environment to feed source code for a module into the module
// cache.  The storage is owned by the compiler runtime so subsequent imports can
// reuse the content without copying from the host again.
fn loadModuleFromSource(path_ptr: i32, content_ptr: i32) -> i32 {
    if path_ptr <= 0 || content_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        let detail_out_ptr: i32 = module_storage_top();
        if detail_out_ptr > 0 {
            write_failure_detail(detail_out_ptr, 10, "empty path");
        };
        return -1;
    };
    let content_len: i32 = string_length(content_ptr);
    if content_len < 0 {
        return -1;
    };
    let existing_index: i32 = module_find_index(path_ptr, path_len);
    let stored_path_ptr: i32 = if existing_index >= 0 {
        module_entry_path(existing_index)
    } else {
        if module_count() >= MODULE_MAX_COUNT {
            return -1;
        };
        let allocated_path_ptr: i32 = module_allocate_bytes(path_len + 1);
        if allocated_path_ptr <= 0 {
            return -1;
        };
        copy_bytes(allocated_path_ptr, path_ptr, path_len);
        store_u8(allocated_path_ptr + path_len, 0);
        allocated_path_ptr
    };
    let allocated_content_ptr: i32 = module_allocate_bytes(content_len + 1);
    if allocated_content_ptr <= 0 {
        return -1;
    };
    copy_bytes(allocated_content_ptr, content_ptr, content_len);
    store_u8(allocated_content_ptr + content_len, 0);
    let store_index: i32 = if existing_index >= 0 {
        existing_index
    } else {
        let index: i32 = module_count();
        module_set_count(index + 1);
        index
    };
    module_write_entry(store_index, stored_path_ptr, path_len, allocated_content_ptr, content_len);
    0
}

// Compiles a module that has previously been registered with
// `loadModuleFromSource`.  The implementation ensures the module graph is loaded
// only once and resolves imports transitively before running the main pipeline.
fn compileFromPath(path_ptr: i32) -> i32 {
    if path_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let detail_out_ptr: i32 = module_storage_top();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        return -1;
    };
    let index: i32 = module_find_index(path_ptr, path_len);
    if index < 0 {
        if detail_out_ptr > 0 {
            write_failure_detail(detail_out_ptr, 26, "module has not been loaded");
        };
        return -1;
    };
    module_clear_flags();
    module_entry_set_flags(index, MODULE_FLAG_IMPORTING);
    let input_ptr: i32 = module_entry_content(index);
    let input_len: i32 = module_entry_content_len(index);
    if input_ptr <= 0 || input_len <= 0 {
        return -1;
    };
    let initial_top: i32 = module_storage_top();
    let out_ptr: i32 = align_to(
        if initial_top > 0 {
            initial_top
        } else {
            module_ensure_state_initialized();
            module_storage_top()
        },
        WORD_SIZE,
    );
    module_set_storage_top(out_ptr);
    let required: i32 = out_ptr + ast_output_reserve(input_len);
    if ensure_memory_capacity(required) < 0 {
        if out_ptr > 0 {
            write_failure_detail(out_ptr, 54, "failed to reserve linear memory for module compilation");
        };
        return -1;
    };
    let status: i32 = compile_impl(input_ptr, input_len, out_ptr, index);
    module_entry_set_flags(index, if status > 0 { MODULE_FLAG_IMPORTED } else { 0 });
    status
}

fn main() -> i32 {
    0
}
