use "/stdlib/memory.bp";
use "./utils.bp";
use "./wasm_output.bp";
use "./constant_interpreter.bp";

fn memory_size_pages() -> i32 {
    inline_wasm([0x3f, 0x00])
}

fn memory_grow_pages(pages: i32) -> i32 {
    inline_wasm([0x20, 0x00, 0x40, 0x00])
}

fn ensure_memory_capacity(required: i32) -> i32 {
    if required <= 0 {
        return 0;
    };
    let mut current_pages: i32 = memory_size_pages();
    if current_pages < 0 {
        return -1;
    };
    let mut current_bytes: i32 = current_pages << 16;
    if current_bytes >= required {
        return 0;
    };
    loop {
        let additional_bytes: i32 = required - current_bytes;
        if additional_bytes <= 0 {
            break;
        };
        let mut additional_pages: i32 = additional_bytes >> 16;
        if (additional_bytes & 65535) != 0 {
            additional_pages = additional_pages + 1;
        };
        if additional_pages <= 0 {
            additional_pages = 1;
        };
        let previous_pages: i32 = memory_grow_pages(additional_pages);
        if previous_pages < 0 {
            return -1;
        };
        current_pages = previous_pages + additional_pages;
        current_bytes = current_pages << 16;
        if current_bytes >= required {
            break;
        };
    };
    0
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if byte == '/' {
            if idx + 1 < len {
                let next: i32 = load_u8(base + idx + 1);
                if next == '/' {
                    idx = idx + 2;
                    loop {
                        if idx >= len {
                            break;
                        };
                        let comment_byte: i32 = load_u8(base + idx);
                        if comment_byte == '\n' {
                            idx = idx + 1;
                            break;
                        };
                        idx = idx + 1;
                    };
                    continue;
                };
            };
        };
        if !is_whitespace(byte) {
            break;
        };
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    };
    offset + 1
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 'A' && byte <= 'Z') || (byte >= 'a' && byte <= 'z') || byte == '_'
}

fn is_digit(byte: i32) -> bool {
    byte >= '0' && byte <= '9'
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || is_digit(byte)
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "fn\0\0\0\0\0\0\0\0\0\0")
}

fn expect_keyword_use(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "use\0\0\0\0\0\0\0\0\0")
}

fn expect_keyword_type(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "type\0\0\0\0\0\0\0\0")
}

fn expect_keyword_if(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "if\0\0\0\0\0\0\0\0\0\0")
}

fn expect_keyword_as(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "as\0\0\0\0\0\0\0\0\0\0")
}

fn expect_keyword_true(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "true\0\0\0\0\0\0\0\0")
}

fn expect_keyword_false(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "false\0\0\0\0\0\0\0")
}

fn expect_keyword_else(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "else\0\0\0\0\0\0\0\0")
}

fn expect_keyword_loop(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "loop\0\0\0\0\0\0\0\0")
}

fn expect_keyword_break(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "break\0\0\0\0\0\0\0")
}

fn expect_keyword_continue(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "continue\0\0\0\0")
}

fn expect_keyword_return(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "return\0\0\0\0\0\0")
}

fn parse_identifier(base: i32, len: i32, offset: i32) -> (i32, i32, i32) {
    if offset >= len {
        return (-1, 0, 0);
    };
    let first: i32 = load_u8(base + offset);
    if !is_identifier_start(first) {
        return (-1, 0, 0);
    };
    let mut idx: i32 = offset + 1;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_identifier_continue(byte) {
            break;
        };
        idx = idx + 1;
    };
    (idx, offset, idx - offset)
}

const MAX_PARAMS: i32 = 64;

const MAX_ARRAY_LITERAL_ELEMENTS: i32 = 256;

const MAX_TUPLE_ELEMENTS: i32 = 32;

const INTRINSIC_KIND_NONE: i32 = -1;

const INTRINSIC_KIND_LEN: i32 = 0;

const INTRINSIC_KIND_INLINE_WASM: i32 = 1;

fn padded_string_len(keyword: [u8; 12]) -> i32 {
    let capacity: i32 = len(keyword);
    let mut length: i32 = 0;
    loop {
        if length >= capacity {
            break;
        };
        let value: i32 = keyword[length] as i32;
        if value == 0 {
            break;
        };
        length = length + 1;
    };
    length
}

fn identifier_matches_keyword(
    base: i32,
    source_len: i32,
    start: i32,
    ident_len: i32,
    keyword: [u8; 12],
) -> bool {
    if start < 0 || start + ident_len > source_len {
        return false;
    };
    let keyword_len: i32 = padded_string_len(keyword);
    if keyword_len <= 0 {
        return false;
    };
    if ident_len != keyword_len {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= keyword_len {
            break;
        };
        if load_u8(base + start + idx) != keyword[idx] as i32 {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn expect_keyword_literal(base: i32, len: i32, offset: i32, keyword: [u8; 12]) -> i32 {
    let keyword_len: i32 = padded_string_len(keyword);
    if keyword_len <= 0 {
        return -1;
    };
    if offset < 0 || offset + keyword_len > len {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= keyword_len {
            break;
        };
        if load_u8(base + offset + idx) != keyword[idx] as i32 {
            return -1;
        };
        idx = idx + 1;
    };
    let next: i32 = offset + keyword_len;
    if next < len {
        let after: i32 = load_u8(base + next);
        if is_identifier_continue(after) {
            return -1;
        };
    };
    next
}

fn identify_intrinsic(base: i32, len: i32, start: i32, ident_len: i32) -> i32 {
    let names: [[u8; 12]; 2] = [
        "len\0\0\0\0\0\0\0\0\0",
        "inline_wasm\0",
    ];
    let kinds: [i32; 2] = [INTRINSIC_KIND_LEN, INTRINSIC_KIND_INLINE_WASM];
    let mut idx: i32 = 0;
    let count: i32 = len(kinds);
    loop {
        if idx >= count {
            break;
        };
        if identifier_matches_keyword(base, len, start, ident_len, names[idx]) {
            return kinds[idx];
        };
        idx = idx + 1;
    };
    INTRINSIC_KIND_NONE
}

fn identifiers_match_source(
    base: i32,
    start_a: i32,
    len_a: i32,
    start_b: i32,
    len_b: i32,
) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(base + start_a + idx);
        let b_byte: i32 = load_u8(base + start_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn find_parameter_index(
    base: i32,
    params_table_ptr: i32,
    params_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let mut idx: i32 = 0;
    loop {
        if idx >= params_count {
            break;
        };
        let entry_ptr: i32 = params_table_ptr + idx * 8;
        let param_start: i32 = load_i32(entry_ptr);
        let param_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, param_start, param_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn expect_keyword_const(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "const\0\0\0\0\0\0\0")
}

fn expect_keyword_let(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "let\0\0\0\0\0\0\0\0\0")
}

const MAX_LOCALS: i32 = 512;

const LOCALS_ENTRY_SIZE: i32 = 20;

fn locals_entry_ptr(locals_table_ptr: i32, index: i32) -> i32 {
    locals_table_ptr + index * LOCALS_ENTRY_SIZE
}

fn find_local_entry_index(
    base: i32,
    locals_table_ptr: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= 0 {
        return -1;
    };
    let mut idx: i32 = locals_stack_count - 1;
    loop {
        if idx < 0 {
            break;
        };
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx - 1;
    };
    -1
}

fn find_local_entry_index_in_scope(
    base: i32,
    locals_table_ptr: i32,
    scope_start: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= scope_start {
        return -1;
    };
    let mut idx: i32 = locals_stack_count - 1;
    loop {
        if idx < scope_start {
            break;
        };
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx - 1;
    };
    -1
}

fn locals_entry_local_index(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 8)
}

fn locals_entry_type_id(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 12)
}

fn locals_entry_is_mut(entry_ptr: i32) -> bool {
    load_i32(entry_ptr + 16) != 0
}

fn find_constant_entry_index(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let count: i32 = ast_constants_count(ast_base);
    if count <= 0 {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, idx);
        let const_start: i32 = load_i32(entry_ptr);
        let const_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, const_start, const_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn expression_guaranteed_diverges(ast_base: i32, expr_index: i32) -> bool {
    if expr_index < 0 {
        return false;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return false;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 13 {
        return true;
    };
    if kind == 24 {
        return true;
    };
    if kind == 23 {
        return true;
    };
    if kind == 11 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        return expression_guaranteed_diverges(ast_base, then_index);
    };
    if kind == 9 {
        let body_index: i32 = load_i32(entry_ptr + 12);
        return expression_guaranteed_diverges(ast_base, body_index);
    };
    if kind == 7 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if !expression_guaranteed_diverges(ast_base, then_index) {
            return false;
        };
        if !expression_guaranteed_diverges(ast_base, else_index) {
            return false;
        };
        return true;
    };
    false
}

const BLOCK_STATEMENT_ENTRY_SIZE: i32 = 12;

const BLOCK_STATEMENTS_CAPACITY: i32 = 512;

fn parse_block_expression_body(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    temp_base: i32,
    allow_empty_final_expr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    out_value_status_ptr: i32,
) -> i32 {
    let saved_stack_count: i32 = load_i32(locals_stack_count_ptr);
    let saved_next_index: i32 = load_i32(locals_next_index_ptr);
    let mut idx: i32 = skip_whitespace(base, len, cursor);

    let statement_count_ptr: i32 = temp_base;
    store_i32(statement_count_ptr, 0);
    let statements_base: i32 = statement_count_ptr + 4;
    let statements_capacity: i32 = BLOCK_STATEMENTS_CAPACITY;
    let statement_entry_size: i32 = BLOCK_STATEMENT_ENTRY_SIZE;
    let statements_end: i32 = statements_base + statements_capacity * statement_entry_size;
    let stmt_expr_kind_ptr: i32 = statements_end;
    let stmt_expr_data0_ptr: i32 = stmt_expr_kind_ptr + 4;
    let stmt_expr_data1_ptr: i32 = stmt_expr_kind_ptr + 8;
    let stmt_expr_value_status_ptr: i32 = stmt_expr_kind_ptr + 12;
    let stmt_local_type_ptr: i32 = stmt_expr_value_status_ptr + 4;
    let stmt_nested_temp_base: i32 = stmt_expr_kind_ptr + 64;

    let allow_empty_value: bool = allow_empty_final_expr != 0;
    let mut have_value_expr: bool = false;
    let mut final_kind: i32 = -1;
    let mut final_data0: i32 = 0;
    let mut final_data1: i32 = 0;
    store_i32(out_value_status_ptr, 0);

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };
        let next_byte: i32 = load_u8(base + idx);
        if next_byte == '}' {
            if !have_value_expr {
                if allow_empty_value {
                    have_value_expr = true;
                    final_kind = 0;
                    final_data0 = 0;
                    final_data1 = 0;
                } else {
                    let stmt_count: i32 = load_i32(statement_count_ptr);
                    let mut diverges: bool = false;
                    if stmt_count > 0 {
                        let last_ptr: i32 =
                            statements_base + (stmt_count - 1) * statement_entry_size;
                        let last_kind: i32 = load_i32(last_ptr);
                        if last_kind == 1 {
                            let last_expr_index: i32 = load_i32(last_ptr + 4);
                            if expression_guaranteed_diverges(ast_base, last_expr_index) {
                                diverges = true;
                            };
                        };
                    };
                    if diverges {
                        have_value_expr = true;
                        final_kind = 0;
                        final_data0 = 0;
                        final_data1 = 0;
                    } else {
                        store_i32(locals_stack_count_ptr, saved_stack_count);
                        store_i32(locals_next_index_ptr, saved_next_index);
                        return -1;
                    };
                };
            };
            idx = idx + 1;
            idx = skip_whitespace(base, len, idx);
            break;
        };
        if have_value_expr {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };

        let mut handled_statement: bool = false;
        let mut let_cursor: i32 = expect_keyword_let(base, len, idx);
        if let_cursor >= 0 {
            if let_cursor >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let after_keyword: i32 = load_u8(base + let_cursor);
            if !is_whitespace(after_keyword) {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, let_cursor);
            let mut is_mut: bool = false;
            if idx + 3 <= len {
                let m: i32 = load_u8(base + idx);
                if m == 'm' {
                    let u: i32 = load_u8(base + idx + 1);
                    let t: i32 = load_u8(base + idx + 2);
                    if u == 'u' && t == 't' {
                        let after_mut: i32 = idx + 3;
                        if after_mut >= len {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let after_mut_byte: i32 = load_u8(base + after_mut);
                        if is_whitespace(after_mut_byte) {
                            is_mut = true;
                            idx = skip_whitespace(base, len, after_mut);
                        };
                    };
                };
            };

            let ident: (i32, i32, i32) = parse_identifier(base, len, idx);
            let next_idx: i32 = ident.0;
            if next_idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let name_start: i32 = ident.1;
            let name_len: i32 = ident.2;
            idx = next_idx;

            let current_stack: i32 = load_i32(locals_stack_count_ptr);
            let existing: i32 = find_local_entry_index_in_scope(
                base,
                locals_table_ptr,
                saved_stack_count,
                current_stack,
                name_start,
                name_len,
            );
            if existing >= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };

            idx = skip_whitespace(base, len, idx);
            let mut has_type_annotation: bool = false;
            if idx < len {
                let next_char: i32 = load_u8(base + idx);
                if next_char == ':' {
                    has_type_annotation = true;
                    idx = skip_whitespace(base, len, idx + 1);
                    idx = parse_type(base, len, idx, ast_base, stmt_local_type_ptr);
                    if idx < 0 {
                        store_i32(locals_stack_count_ptr, saved_stack_count);
                        store_i32(locals_next_index_ptr, saved_next_index);
                        return -1;
                    };
                };
            };
            if !has_type_annotation {
                store_i32(stmt_local_type_ptr, -1);
            };
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, '=');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, idx);
            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let init_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let init_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let init_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let init_index: i32 =
                expression_node_from_parts(ast_base, init_kind, init_data0, init_data1);
            if init_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            if load_i32(stmt_local_type_ptr) < 0 {
                let inferred_type: i32 = ast_expr_type(ast_base, init_index);
                if inferred_type < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                store_i32(stmt_local_type_ptr, inferred_type);
            };
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, ';');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };

            let stack_count: i32 = load_i32(locals_stack_count_ptr);
            if stack_count >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let next_local_offset: i32 = load_i32(locals_next_index_ptr);
            if next_local_offset >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let local_index: i32 = params_count + next_local_offset;
            let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, stack_count);
            store_i32(entry_ptr, name_start);
            store_i32(entry_ptr + 4, name_len);
            store_i32(entry_ptr + 8, local_index);
            let local_type_id: i32 = load_i32(stmt_local_type_ptr);
            store_i32(entry_ptr + 12, local_type_id);
            store_i32(entry_ptr + 16, if is_mut { 1 } else { 0 });
            store_i32(locals_stack_count_ptr, stack_count + 1);
            store_i32(locals_next_index_ptr, next_local_offset + 1);

            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 0);
            store_i32(stmt_ptr + 4, local_index);
            store_i32(stmt_ptr + 8, init_index);
            store_i32(statement_count_ptr, stmt_count + 1);
            handled_statement = true;
        };

        if handled_statement {
            continue;
        };

        let mut expression_parsed: bool = false;

        let mut break_cursor: i32 = expect_keyword_break(base, len, idx);
        if break_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let mut after_break: i32 = skip_whitespace(base, len, break_cursor);
            if after_break >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let mut value_index: i32 = -1;
            let after_byte: i32 = load_u8(base + after_break);
            if after_byte != ';' {
                after_break = parse_expression(
                    base,
                    len,
                    after_break,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                value_index = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                after_break = skip_whitespace(base, len, after_break);
                after_break = expect_char(base, len, after_break, ';');
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
            } else {
                after_break = skip_whitespace(base, len, after_break + 1);
            };
            let break_expr_index: i32 = ast_expr_alloc_break(ast_base, value_index);
            if break_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, break_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = after_break;
            continue;
        };

        let mut continue_cursor: i32 = expect_keyword_continue(base, len, idx);
        if continue_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            if continue_cursor < len {
                let after_byte: i32 = load_u8(base + continue_cursor);
                if after_byte != ';' && !is_whitespace(after_byte) {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
            };
            let mut after_continue: i32 = skip_whitespace(base, len, continue_cursor);
            after_continue = expect_char(base, len, after_continue, ';');
            if after_continue < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let continue_expr_index: i32 = ast_expr_alloc_continue(ast_base);
            if continue_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, continue_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = skip_whitespace(base, len, after_continue);
            continue;
        };

        let mut return_cursor: i32 = expect_keyword_return(base, len, idx);
        if return_cursor >= 0 {
            let mut after_return: i32 = skip_whitespace(base, len, return_cursor);
            after_return = parse_expression(
                base,
                len,
                after_return,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if after_return < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let value_index: i32 = expression_node_from_parts(
                ast_base,
                value_kind,
                value_data0,
                value_data1,
            );
            if value_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            after_return = skip_whitespace(base, len, after_return);
            after_return = expect_char(base, len, after_return, ';');
            if after_return < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let return_expr_index: i32 = ast_expr_alloc_return(ast_base, value_index);
            if return_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            have_value_expr = true;
            final_kind = 23;
            final_data0 = return_expr_index;
            final_data1 = 0;
            store_i32(out_value_status_ptr, 1);
            idx = skip_whitespace(base, len, after_return);
            continue;
        };

        let mut loop_cursor: i32 = expect_keyword_loop(base, len, idx);
        if loop_cursor >= 0 {
            let mut after_loop: i32 = skip_whitespace(base, len, loop_cursor);
            after_loop = expect_char(base, len, after_loop, '{');
            if after_loop < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let saved_loop_depth: i32 = load_i32(loop_depth_ptr);
            store_i32(loop_depth_ptr, saved_loop_depth + 1);
            after_loop = parse_block_expression_body(
                base,
                len,
                after_loop,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                stmt_nested_temp_base,
                1,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
                stmt_expr_value_status_ptr,
            );
            if after_loop < 0 {
                store_i32(loop_depth_ptr, saved_loop_depth);
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            store_i32(loop_depth_ptr, saved_loop_depth);
            let body_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let body_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let body_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let body_index: i32 = expression_node_from_parts(
                ast_base,
                body_kind,
                body_data0,
                body_data1,
            );
            if body_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let loop_expr_index: i32 = ast_expr_alloc_loop(ast_base, body_index);
            if loop_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            store_i32(stmt_expr_kind_ptr, 12);
            store_i32(stmt_expr_data0_ptr, loop_expr_index);
            store_i32(stmt_expr_data1_ptr, 0);
            idx = after_loop;
            expression_parsed = true;
        };

        let statement_start: i32 = idx;
        let mut assignment_identified: bool = false;
        let mut assignment_local_index: i32 = -1;
        let mut assignment_cursor: i32 = idx;
        if !expression_parsed {
            if is_identifier_start(next_byte) {
                let assignment_ident: (i32, i32, i32) = parse_identifier(base, len, idx);
                assignment_cursor = assignment_ident.0;
                if assignment_cursor >= 0 {
                    let name_start: i32 = assignment_ident.1;
                    let name_len: i32 = assignment_ident.2;
                    let mut after_ident: i32 = skip_whitespace(base, len, assignment_cursor);
                    if after_ident < len {
                        let assign_byte: i32 = load_u8(base + after_ident);
                        if assign_byte == '=' {
                            let mut after_equal: i32 = after_ident + 1;
                            if after_equal >= len {
                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                store_i32(locals_next_index_ptr, saved_next_index);
                                return -1;
                            };
                            let maybe_second_equal: i32 = load_u8(base + after_equal);
                            if maybe_second_equal != '=' {
                                let current_stack: i32 = load_i32(locals_stack_count_ptr);
                                let entry_index: i32 = find_local_entry_index(
                                    base,
                                    locals_table_ptr,
                                    current_stack,
                                    name_start,
                                    name_len,
                                );
                                if entry_index < 0 {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                };
                                let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, entry_index);
                                if !locals_entry_is_mut(entry_ptr) {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                };
                                assignment_local_index = locals_entry_local_index(entry_ptr);
                                assignment_identified = true;
                                assignment_cursor = skip_whitespace(base, len, after_equal);
                            };
                        };
                    };
                };
            };
        };

        if !expression_parsed {
            idx = statement_start;
            if assignment_identified {
                idx = parse_expression(
                    base,
                    len,
                    assignment_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                let value_index: i32 = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                idx = skip_whitespace(base, len, idx);
                idx = expect_char(base, len, idx, ';');
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let assign_expr_index: i32 =
                    ast_expr_alloc_set_local(ast_base, assignment_local_index, value_index);
                if assign_expr_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let stmt_count: i32 = load_i32(statement_count_ptr);
                if stmt_count >= statements_capacity {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                store_i32(stmt_ptr, 1);
                store_i32(stmt_ptr + 4, assign_expr_index);
                store_i32(stmt_ptr + 8, 0);
                store_i32(statement_count_ptr, stmt_count + 1);
                continue;
            };

            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
        };
        let expr_kind: i32 = load_i32(stmt_expr_kind_ptr);
        let expr_data0: i32 = load_i32(stmt_expr_data0_ptr);
        let expr_data1: i32 = load_i32(stmt_expr_data1_ptr);
        let mut next_cursor: i32 = skip_whitespace(base, len, idx);
        let mut treat_as_statement: bool = false;
        if next_cursor < len {
            let delimiter: i32 = load_u8(base + next_cursor);
            if delimiter == ';' {
                let after_semicolon: i32 = skip_whitespace(base, len, next_cursor + 1);
                if after_semicolon < len {
                    let after_byte: i32 = load_u8(base + after_semicolon);
                    if after_byte == '}' && !have_value_expr {
                        next_cursor = after_semicolon;
                    } else {
                        treat_as_statement = true;
                        next_cursor = after_semicolon;
                    };
                } else {
                    treat_as_statement = true;
                    next_cursor = after_semicolon;
                };
            };
        };
        if !treat_as_statement {
            if expr_kind == 12 {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte != '}' {
                        treat_as_statement = true;
                    };
                };
            };
        };
        if treat_as_statement {
            let expr_index: i32 = expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
            if expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = next_cursor;
            continue;
        };

        let expr_metadata: i32 = load_i32(stmt_expr_data1_ptr);
        if expr_metadata < 0 {
            if allow_empty_value {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte == '}' {
                        let expr_index: i32 =
                            expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
                        if expr_index < 0 {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let stmt_count: i32 = load_i32(statement_count_ptr);
                        if stmt_count >= statements_capacity {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                        store_i32(stmt_ptr, 1);
                        store_i32(stmt_ptr + 4, expr_index);
                        store_i32(stmt_ptr + 8, 0);
                        store_i32(statement_count_ptr, stmt_count + 1);
                        idx = next_cursor;
                        continue;
                    };
                };
            };
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };
        have_value_expr = true;
        final_kind = expr_kind;
        final_data0 = expr_data0;
        final_data1 = expr_data1;
        store_i32(out_value_status_ptr, 1);
        idx = next_cursor;
    };

    store_i32(locals_stack_count_ptr, saved_stack_count);

    let mut final_index: i32 =
        expression_node_from_parts(ast_base, final_kind, final_data0, final_data1);
    if final_index < 0 {
        store_i32(locals_next_index_ptr, saved_next_index);
        return -1;
    };
    let stmt_count: i32 = load_i32(statement_count_ptr);
    if stmt_count > 0 {
        let mut stmt_idx: i32 = stmt_count - 1;
        loop {
            if stmt_idx < 0 {
                break;
            };
            let stmt_ptr: i32 = statements_base + stmt_idx * statement_entry_size;
            let stmt_kind: i32 = load_i32(stmt_ptr);
            if stmt_kind == 0 {
                let local_index: i32 = load_i32(stmt_ptr + 4);
                let init_index: i32 = load_i32(stmt_ptr + 8);
                final_index = ast_expr_alloc_let(ast_base, local_index, init_index, final_index);
            } else {
                let first_index: i32 = load_i32(stmt_ptr + 4);
                final_index = ast_expr_alloc_sequence(ast_base, first_index, final_index);
            };
            if final_index < 0 {
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            stmt_idx = stmt_idx - 1;
        };
    };

    store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, final_index, 0));
    idx
}

const BUILTIN_TYPE_ID_I32: i32 = 0;

const BUILTIN_TYPE_ID_BOOL: i32 = 1;

const BUILTIN_TYPE_ID_I8: i32 = 2;

const BUILTIN_TYPE_ID_I16: i32 = 3;

const BUILTIN_TYPE_ID_I64: i32 = 4;

const BUILTIN_TYPE_ID_U8: i32 = 5;

const BUILTIN_TYPE_ID_U16: i32 = 6;

const BUILTIN_TYPE_ID_U32: i32 = 7;

const BUILTIN_TYPE_ID_U64: i32 = 8;

const BUILTIN_INTEGER_VARIANT_COUNT: i32 = 4;

const SCRATCH_TYPES_CAPACITY: i32 = 2048;

const BUILTIN_TYPE_ID_MAX: i32 = BUILTIN_TYPE_ID_U64;

const TYPE_ALIAS_CAPACITY: i32 = 256;

const ARRAY_TYPE_CAPACITY: i32 = 256;

const TUPLE_TYPE_CAPACITY: i32 = 256;

const TYPE_ID_KIND_SHIFT: i32 = 24;

const TYPE_ID_KIND_USER_COMPOSITE: i32 = 1;

const TYPE_ID_KIND_USER_ALIAS: i32 = 2;

const fn type_id_kind_base(kind: i32) -> i32 {
    kind << TYPE_ID_KIND_SHIFT
}

const TYPE_ID_ARRAY_BASE: i32 = type_id_kind_base(TYPE_ID_KIND_USER_COMPOSITE);

const TYPE_ID_TUPLE_BASE: i32 = TYPE_ID_ARRAY_BASE + ARRAY_TYPE_CAPACITY;

const TYPE_ID_ARRAY_LIMIT: i32 = TYPE_ID_TUPLE_BASE;

const TYPE_ID_TUPLE_LIMIT: i32 = TYPE_ID_TUPLE_BASE + TUPLE_TYPE_CAPACITY;

const TYPE_ID_ALIAS_BASE: i32 = type_id_kind_base(TYPE_ID_KIND_USER_ALIAS);

const TYPE_ID_ALIAS_LIMIT: i32 = TYPE_ID_ALIAS_BASE + TYPE_ALIAS_CAPACITY;

fn type_id_is_builtin(type_id: i32) -> bool {
    type_id >= 0 && type_id <= BUILTIN_TYPE_ID_MAX
}

fn type_id_is_array(type_id: i32) -> bool {
    type_id >= TYPE_ID_ARRAY_BASE && type_id < TYPE_ID_ARRAY_LIMIT
}

fn type_id_is_tuple(type_id: i32) -> bool {
    type_id >= TYPE_ID_TUPLE_BASE && type_id < TYPE_ID_TUPLE_LIMIT
}

fn type_id_is_alias(type_id: i32) -> bool {
    type_id >= TYPE_ID_ALIAS_BASE && type_id < TYPE_ID_ALIAS_LIMIT
}

fn alias_type_id(index: i32) -> i32 {
    TYPE_ID_ALIAS_BASE + index
}

fn alias_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_ALIAS_BASE
}

fn type_id_is_bool(type_id: i32) -> bool {
    type_id == BUILTIN_TYPE_ID_BOOL
}

fn integer_type_variant_index(type_id: i32) -> i32 {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == signed[idx] {
            return idx;
        };
        if type_id == unsigned[idx] {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn type_id_is_integer(type_id: i32) -> bool {
    integer_type_variant_index(type_id) >= 0
}

fn type_id_is_signed_integer(type_id: i32) -> bool {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == signed[idx] {
            return true;
        };
        idx = idx + 1;
    };
    false
}

fn type_id_is_unsigned_integer(type_id: i32) -> bool {
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    let count: i32 = len(unsigned);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == unsigned[idx] {
            return true;
        };
        idx = idx + 1;
    };
    false
}

fn type_id_is_64_bit_integer(type_id: i32) -> bool {
    let variant_index: i32 = integer_type_variant_index(type_id);
    if variant_index < 0 {
        return false;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[variant_index] == 64
}








fn builtin_integer_variant_width(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[index]
}

fn builtin_signed_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    signed[index]
}

fn builtin_unsigned_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    unsigned[index]
}

fn builtin_integer_type_keyword_to_id(base: i32, start: i32, ident_len: i32) -> i32 {
    if ident_len <= 1 {
        return -1;
    };
    let first: i32 = load_u8(base + start);
    if first != 'i' && first != 'u' {
        return -1;
    };
    let mut idx: i32 = 1;
    let mut width: i32 = 0;
    loop {
        if idx >= ident_len {
            break;
        };
        let digit: i32 = load_u8(base + start + idx);
        if !is_digit(digit) {
            return -1;
        };
        width = width * 10 + (digit - '0');
        idx = idx + 1;
    };
    let variant_count: i32 = BUILTIN_INTEGER_VARIANT_COUNT;
    let mut variant_index: i32 = 0;
    loop {
        if variant_index >= variant_count {
            break;
        };
        let expected_width: i32 = builtin_integer_variant_width(variant_index);
        if expected_width == width {
            if first == 'i' {
                return builtin_signed_integer_type_id_for_variant(variant_index);
            };
            return builtin_unsigned_integer_type_id_for_variant(variant_index);
        };
        variant_index = variant_index + 1;
    };
    -1
}

fn alias_definition_chain_is_valid(ast_base: i32, alias_index: i32) -> bool {
    if alias_index < 0 {
        return false;
    };
    let count: i32 = ast_type_definitions_count(ast_base);
    if alias_index >= count {
        return false;
    };
    let mut guard: i32 = 0;
    let mut current_index: i32 = alias_index;
    loop {
        if guard >= TYPE_ALIAS_CAPACITY {
            return false;
        };
        guard = guard + 1;
        let target_type_id: i32 = ast_type_definition_target_type(ast_base, current_index);
        if target_type_id < 0 {
            return false;
        };
        if !type_id_is_alias(target_type_id) {
            return true;
        };
        let next_index: i32 = alias_type_index(target_type_id);
        if next_index < 0 {
            return false;
        };
        if next_index >= count {
            return false;
        };
        current_index = next_index;
    };
}

fn parse_type(base: i32, len: i32, offset: i32, ast_base: i32, out_type_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let first: i32 = load_u8(base + offset);
    if first == '[' {
        if out_type_ptr < 0 {
            return -1;
        };
        let mut cursor: i32 = offset + 1;
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_type(base, len, cursor, ast_base, out_type_ptr);
        if cursor < 0 {
            return -1;
        };
        let element_type_id: i32 = load_i32(out_type_ptr);
        if element_type_id < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ';');
        if cursor < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        let literal_base: i32 = ast_temp_base(ast_base);
        let literal_ptr: i32 = literal_base;
        let literal_cursor: i32 = parse_i32_literal(base, len, cursor, literal_ptr);
        let mut length: i32 = -1;
        if literal_cursor >= 0 {
            length = load_i32(literal_ptr);
            if length < 0 {
                return -1;
            };
            cursor = literal_cursor;
        } else {
            let temp_base: i32 = literal_base;
            let params_table_ptr: i32 = temp_base;
            let expr_kind_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
            let expr_data0_ptr: i32 = expr_kind_ptr + 4;
            let expr_data1_ptr: i32 = expr_kind_ptr + 8;
            let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
            let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
            let locals_next_index_ptr: i32 =
                locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
            let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
            let expr_temp_base: i32 = loop_depth_ptr + 4;
            store_i32(locals_stack_count_ptr, 0);
            store_i32(locals_next_index_ptr, 0);
            store_i32(loop_depth_ptr, 0);
            cursor = parse_expression(
                base,
                len,
                cursor,
                ast_base,
                params_table_ptr,
                0,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                expr_temp_base,
                loop_depth_ptr,
                expr_kind_ptr,
                expr_data0_ptr,
                expr_data1_ptr,
            );
            if cursor < 0 {
                return -1;
            };
            let length_value_ptr: i32 = expr_temp_base;
            let length_type_ptr: i32 = length_value_ptr + 4;
            let length_scratch_base: i32 = length_type_ptr + 4;
            if evaluate_expression_literal(
                ast_base,
                expr_kind_ptr,
                expr_data0_ptr,
                expr_data1_ptr,
                length_scratch_base,
                length_value_ptr,
                length_type_ptr,
            ) < 0 {
                return -1;
            };
            let length_type: i32 = load_i32(length_type_ptr);
            if !constant_eval_integer_type_supported(length_type) {
                return -1;
            };
            length = normalize_integer_value(load_i32(length_value_ptr), length_type);
            if length < 0 {
                return -1;
            };
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ']');
        if cursor < 0 {
            return -1;
        };
        let type_id: i32 = ast_register_array_type(ast_base, element_type_id, length);
        if type_id < 0 {
            return -1;
        };
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return cursor;
    };
    if first == '(' {
        let mut cursor: i32 = offset + 1;
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            return -1;
        };
        let next_byte: i32 = load_u8(base + cursor);
        if next_byte == ')' {
            let type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
            if type_id < 0 {
                return -1;
            };
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, type_id);
            };
            return cursor + 1;
        };
        if out_type_ptr < 0 {
            return -1;
        };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let mut element_count: i32 = 0;
        let mut elements_ptr: i32 = -1;
        cursor = parse_type(base, len, cursor, ast_base, out_type_ptr);
        if cursor < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let first_type_id: i32 = load_i32(out_type_ptr);
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let mut delimiter: i32 = load_u8(base + cursor);
        if delimiter == ')' {
            return cursor + 1;
        };
        if delimiter != ',' {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        elements_ptr = ast_call_data_alloc(ast_base, 1);
        if elements_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        store_i32(elements_ptr, first_type_id);
        element_count = 1;
        let mut tuple_cursor: i32 = skip_whitespace(base, len, cursor + 1);
        loop {
            if tuple_cursor >= len {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let tuple_byte: i32 = load_u8(base + tuple_cursor);
            if tuple_byte == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            };
            if element_count >= MAX_TUPLE_ELEMENTS {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let element_ptr: i32 = ast_call_data_alloc(ast_base, 1);
            if element_ptr < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            tuple_cursor = parse_type(base, len, tuple_cursor, ast_base, element_ptr);
            if tuple_cursor < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            element_count = element_count + 1;
            tuple_cursor = skip_whitespace(base, len, tuple_cursor);
            if tuple_cursor >= len {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            delimiter = load_u8(base + tuple_cursor);
            if delimiter == ',' {
                tuple_cursor = skip_whitespace(base, len, tuple_cursor + 1);
                continue;
            };
            if delimiter == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            };
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let type_id: i32 = ast_register_tuple_type(ast_base, elements_ptr, element_count);
        if type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        };
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return tuple_cursor;
    };
    if !is_identifier_start(first) {
        return -1;
    };
    let mut next: i32 = offset + 1;
    loop {
        if next >= len {
            break;
        };
        let byte: i32 = load_u8(base + next);
        if !is_identifier_continue(byte) {
            break;
        };
        next = next + 1;
    };
    let ident_len: i32 = next - offset;
    if ident_len <= 0 {
        return -1;
    };
    let type_id: i32 = builtin_integer_type_keyword_to_id(base, offset, ident_len);
    if type_id >= 0 {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return next;
    };
    let bool_keyword: [u8; 12] = "bool\0\0\0\0\0\0\0\0";
    if identifier_matches_keyword(base, len, offset, ident_len, bool_keyword) {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        };
        return next;
    };
    let alias_index: i32 =
        find_type_definition_entry_index(base, ast_base, offset, ident_len);
    if alias_index >= 0 {
        if !alias_definition_chain_is_valid(ast_base, alias_index) {
            return -1;
        };
        let type_id: i32 = alias_type_id(alias_index);
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return next;
    };
    -1
}

fn parse_i32_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let mut idx: i32 = offset;
    let mut sign: i32 = 1;
    let first: i32 = load_u8(base + idx);
    if first == '-' {
        sign = -1;
        idx = idx + 1;
        if idx >= len {
            return -1;
        };
    };
    if idx + 1 < len {
        let leading: i32 = load_u8(base + idx);
        let prefix: i32 = load_u8(base + idx + 1);
        if leading == '0' && (prefix == 'x' || prefix == 'X') {
            idx = idx + 2;
            let mut digits: i32 = 0;
            let mut value: i32 = 0;
            loop {
                if idx >= len {
                    break;
                };
                let byte: i32 = load_u8(base + idx);
                let hex: i32 = if byte >= '0' && byte <= '9' {
                    byte - '0'
                } else if byte >= 'a' && byte <= 'f' {
                    byte - 'a' + 10
                } else if byte >= 'A' && byte <= 'F' {
                    byte - 'A' + 10
                } else {
                    -1
                };
                if hex < 0 {
                    break;
                };
                value = value * 16 + hex;
                idx = idx + 1;
                digits = digits + 1;
            };
            if digits == 0 {
                return -1;
            };
            store_i32(out_value_ptr, value * sign);
            return idx;
        };
    };
    let mut digits: i32 = 0;
    let mut value: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_digit(byte) {
            break;
        };
        value = value * 10 + (byte - '0');
        idx = idx + 1;
        digits = digits + 1;
    };
    if digits == 0 {
        return -1;
    };
    store_i32(out_value_ptr, value * sign);
    idx
}

fn parse_char_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let quote: i32 = load_u8(base + offset);
    if quote != '\'' {
        return -1;
    };
    let mut idx: i32 = offset + 1;
    if idx >= len {
        return -1;
    };
    let mut value: i32 = load_u8(base + idx);
    if value == '\\' {
        idx = idx + 1;
        if idx >= len {
            return -1;
        };
        let escape: i32 = load_u8(base + idx);
        value = if escape == 'n' {
            '\n'
        } else if escape == 'r' {
            '\r'
        } else if escape == 't' {
            '\t'
        } else if escape == '0' {
            '\0'
        } else if escape == '\\' {
            '\\'
        } else if escape == '\'' {
            '\''
        } else {
            return -1;
        };
    } else if value == '\n' || value == '\r' {
        return -1;
    };
    idx = idx + 1;
    if idx >= len {
        return -1;
    };
    let closing: i32 = load_u8(base + idx);
    if closing != '\'' {
        return -1;
    };
    store_i32(out_value_ptr, value);
    idx + 1
}

const WORD_SIZE: i32 = 4;

const SCRATCH_INSTR_OFFSET: i32 = 4096;

const SCRATCH_EXPR_TYPE_OFFSET: i32 = 4092;

const SCRATCH_INSTR_BASE_OFFSET: i32 = 8192;

const SCRATCH_INSTR_CAPACITY: i32 = 65536;

const SCRATCH_FN_COUNT_OFFSET: i32 = 851960;

const SCRATCH_FN_BASE_OFFSET: i32 = 851968;

const TYPE_ENTRY_SIZE: i32 = 16;

const TYPE_ENTRY_TYPE_ID_OFFSET: i32 = 0;

const TYPE_ENTRY_NAME_PTR_OFFSET: i32 = 4;

const TYPE_ENTRY_NAME_LEN_OFFSET: i32 = 8;

const TYPE_ENTRY_EXTRA_OFFSET: i32 = 12;

const SCRATCH_TYPES_BASE_OFFSET: i32 = SCRATCH_FN_BASE_OFFSET - SCRATCH_TYPES_CAPACITY * TYPE_ENTRY_SIZE;

const SCRATCH_TYPES_COUNT_OFFSET: i32 = SCRATCH_TYPES_BASE_OFFSET - WORD_SIZE;

const MODULE_STATE_BASE: i32 = 1048576;

const MODULE_COUNT_OFFSET: i32 = 0;

const MODULE_STORAGE_TOP_OFFSET: i32 = 4;

const MODULE_TABLE_OFFSET: i32 = 8;

const MODULE_MAX_COUNT: i32 = 256;

const MODULE_ENTRY_SIZE: i32 = 20;

const MODULE_PATH_PTR_OFFSET: i32 = 0;

const MODULE_PATH_LEN_OFFSET: i32 = 4;

const MODULE_CONTENT_PTR_OFFSET: i32 = 8;

const MODULE_CONTENT_LEN_OFFSET: i32 = 12;

const MODULE_FLAGS_OFFSET: i32 = 16;

const MODULE_FLAG_IMPORTED: i32 = 1;

const MODULE_FLAG_IMPORTING: i32 = 2;

const MODULE_PATH_MAX_LENGTH: i32 = 1024;

const MODULE_CONTENT_BASE_OFFSET: i32 = MODULE_TABLE_OFFSET + MODULE_MAX_COUNT * MODULE_ENTRY_SIZE;

fn module_count_ptr() -> i32 {
    MODULE_STATE_BASE + MODULE_COUNT_OFFSET
}

fn module_storage_top_ptr() -> i32 {
    MODULE_STATE_BASE + MODULE_STORAGE_TOP_OFFSET
}

fn module_table_base() -> i32 {
    MODULE_STATE_BASE + MODULE_TABLE_OFFSET
}

fn module_entry_ptr(index: i32) -> i32 {
    module_table_base() + index * MODULE_ENTRY_SIZE
}

fn module_entry_path_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_PATH_PTR_OFFSET
}

fn module_entry_path_len_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_PATH_LEN_OFFSET
}

fn module_entry_content_ptr_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_CONTENT_PTR_OFFSET
}

fn module_entry_content_len_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_CONTENT_LEN_OFFSET
}

fn module_entry_flags_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_FLAGS_OFFSET
}

fn module_entry_flags(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_flags_ptr(entry_ptr))
}

fn module_entry_set_flags(index: i32, flags: i32) {
    let entry_ptr: i32 = module_entry_ptr(index);
    store_i32(module_entry_flags_ptr(entry_ptr), flags);
}

fn module_clear_flags() {
    let count: i32 = module_count();
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        module_entry_set_flags(idx, 0);
        idx = idx + 1;
    };
}

fn module_content_base() -> i32 {
    MODULE_STATE_BASE + MODULE_CONTENT_BASE_OFFSET
}

fn module_count() -> i32 {
    load_i32(module_count_ptr())
}

fn module_set_count(count: i32) {
    store_i32(module_count_ptr(), count);
}

fn module_storage_top() -> i32 {
    load_i32(module_storage_top_ptr())
}

fn module_set_storage_top(value: i32) {
    store_i32(module_storage_top_ptr(), value);
}

fn module_ensure_state_initialized() {
    let top: i32 = module_storage_top();
    if top == 0 {
        module_set_storage_top(module_content_base());
        module_set_count(0);
    };
}

fn module_allocate_bytes(len: i32) -> i32 {
    module_ensure_state_initialized();
    if len < 0 {
        return -1;
    };
    let mut top: i32 = module_storage_top();
    if top <= 0 {
        return -1;
    };
    top = align_to(top, WORD_SIZE);
    let start: i32 = top;
    let mut end: i32 = start + len;
    if len == 0 {
        end = start;
    };
    if ensure_memory_capacity(end + 1) < 0 {
        return -1;
    };
    module_set_storage_top(end);
    start
}

fn module_find_index(path_ptr: i32, path_len: i32) -> i32 {
    let count: i32 = module_count();
    if count <= 0 {
        return -1;
    };
    let mut index: i32 = 0;
    loop {
        if index >= count {
            break;
        };
        let entry_ptr: i32 = module_entry_ptr(index);
        let stored_len: i32 = load_i32(module_entry_path_len_ptr(entry_ptr));
        if stored_len == path_len {
            let stored_ptr: i32 = load_i32(module_entry_path_ptr(entry_ptr));
            if stored_ptr > 0 && memory_equal(stored_ptr, path_ptr, path_len) {
                return index;
            };
        };
        index = index + 1;
    };
    -1
}

fn module_entry_path(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_path_ptr(entry_ptr))
}

fn module_entry_path_len(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_path_len_ptr(entry_ptr))
}

fn module_entry_content(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_content_ptr_ptr(entry_ptr))
}

fn module_entry_content_len(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_content_len_ptr(entry_ptr))
}

fn module_write_entry(index: i32, path_ptr: i32, path_len: i32, content_ptr: i32, content_len: i32) {
    let entry_ptr: i32 = module_entry_ptr(index);
    store_i32(module_entry_path_ptr(entry_ptr), path_ptr);
    store_i32(module_entry_path_len_ptr(entry_ptr), path_len);
    store_i32(module_entry_content_ptr_ptr(entry_ptr), content_ptr);
    store_i32(module_entry_content_len_ptr(entry_ptr), content_len);
    store_i32(module_entry_flags_ptr(entry_ptr), 0);
}

fn scratch_instr_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_INSTR_OFFSET
}

fn scratch_expr_type_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_EXPR_TYPE_OFFSET
}

fn scratch_instr_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_INSTR_BASE_OFFSET
}

fn scratch_fn_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FN_COUNT_OFFSET
}

fn scratch_fn_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FN_BASE_OFFSET
}

fn scratch_types_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_TYPES_COUNT_OFFSET
}

fn scratch_types_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_TYPES_BASE_OFFSET
}

fn scratch_type_entry_ptr(out_ptr: i32, index: i32) -> i32 {
    scratch_types_base(out_ptr) + index * TYPE_ENTRY_SIZE
}

fn scratch_type_entry_type_id_ptr(out_ptr: i32, index: i32) -> i32 {
    scratch_type_entry_ptr(out_ptr, index) + TYPE_ENTRY_TYPE_ID_OFFSET
}

fn scratch_types_count(out_ptr: i32) -> i32 {
    load_i32(scratch_types_count_ptr(out_ptr))
}

fn scratch_types_set_count(out_ptr: i32, count: i32) {
    store_i32(scratch_types_count_ptr(out_ptr), count);
}

const AST_MAX_FUNCTIONS: i32 = 1024;

const AST_FUNCTION_ENTRY_SIZE: i32 = 36;

const FUNCTION_FLAG_CONST: i32 = 1;

const AST_NAMES_CAPACITY: i32 = 131072;

const AST_CONSTANTS_CAPACITY: i32 = 1024;

const AST_CONSTANT_ENTRY_SIZE: i32 = 16;

const AST_CONSTANTS_SECTION_SIZE: i32 = WORD_SIZE + AST_CONSTANTS_CAPACITY * AST_CONSTANT_ENTRY_SIZE;

const AST_CONSTANTS_SECTION_WORDS: i32 = AST_CONSTANTS_SECTION_SIZE >> 2;

const AST_CALL_DATA_CAPACITY: i32 = 65536 - AST_CONSTANTS_SECTION_WORDS;

fn ast_output_reserve(input_len: i32) -> i32 {
    let after_output: i32 = input_len + SCRATCH_INSTR_CAPACITY;
    let scratch_end: i32 = SCRATCH_FN_BASE_OFFSET + 16384;
    if after_output > scratch_end { after_output } else { scratch_end }
}

fn ast_program_base(out_ptr: i32, input_len: i32) -> i32 {
    out_ptr + ast_output_reserve(input_len)
}

fn ast_functions_count_ptr(ast_base: i32) -> i32 {
    ast_base
}

fn ast_function_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_base + WORD_SIZE + index * AST_FUNCTION_ENTRY_SIZE
}

fn ast_function_flags_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 32
}

fn ast_function_flags(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_flags_ptr(ast_base, index))
}

fn ast_function_is_const(ast_base: i32, index: i32) -> bool {
    (ast_function_flags(ast_base, index) & FUNCTION_FLAG_CONST) != 0
}

fn ast_names_len_ptr(ast_base: i32) -> i32 {
    ast_base + WORD_SIZE + AST_MAX_FUNCTIONS * AST_FUNCTION_ENTRY_SIZE
}

fn ast_names_base(ast_base: i32) -> i32 {
    ast_names_len_ptr(ast_base) + WORD_SIZE
}

fn ast_call_data_len_ptr(ast_base: i32) -> i32 {
    ast_names_base(ast_base) + AST_NAMES_CAPACITY
}

fn ast_call_data_base(ast_base: i32) -> i32 {
    ast_call_data_len_ptr(ast_base) + WORD_SIZE
}

fn ast_reset(ast_base: i32) {
    store_i32(ast_functions_count_ptr(ast_base), 0);
    store_i32(ast_names_len_ptr(ast_base), 0);
    store_i32(ast_call_data_len_ptr(ast_base), 0);
    ast_constants_reset(ast_base);
    ast_array_types_reset(ast_base);
    ast_tuple_types_reset(ast_base);
    ast_type_definitions_reset(ast_base);
    ast_expr_reset(ast_base);
}

fn ast_store_name(ast_base: i32, source_base: i32, start: i32, len: i32) -> i32 {
    let name_len_ptr: i32 = ast_names_len_ptr(ast_base);
    let mut used: i32 = load_i32(name_len_ptr);
    if used + len > AST_NAMES_CAPACITY {
        return -1;
    };
    let name_ptr: i32 = ast_names_base(ast_base) + used;
    let mut idx: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(source_base + start + idx);
        store_u8(name_ptr + idx, byte);
        idx = idx + 1;
    };
    used = used + len;
    store_i32(name_len_ptr, used);
    name_ptr
}

fn ast_call_data_alloc(ast_base: i32, word_count: i32) -> i32 {
    if word_count <= 0 {
        return -1;
    };
    let used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let used: i32 = load_i32(used_ptr);
    if used + word_count > AST_CALL_DATA_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_call_data_base(ast_base) + used * WORD_SIZE;
    store_i32(used_ptr, used + word_count);
    entry_ptr
}

fn inline_wasm_literal_byte(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind != 0 {
        return -1;
    };
    let literal_type: i32 = ast_expr_type(ast_base, expr_index);
    if literal_type < 0 {
        return -1;
    };
    if !type_id_is_integer(literal_type) {
        return -1;
    };
    let value: i32 = load_i32(entry_ptr + 4);
    let normalized: i32 = normalize_integer_value(value, literal_type);
    if normalized < 0 {
        return -1;
    };
    if normalized > 255 {
        return -1;
    };
    normalized
}

fn inline_wasm_collect_bytes(
    ast_base: i32,
    expr_index: i32,
    out_ptr_ptr: i32,
    out_len_ptr: i32,
) -> i32 {
    if out_ptr_ptr < 0 {
        return -1;
    };
    if out_len_ptr < 0 {
        return -1;
    };
    store_i32(out_ptr_ptr, 0);
    store_i32(out_len_ptr, 0);
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        if length == 0 {
            return 0;
        };
        let byte_value: i32 = inline_wasm_literal_byte(ast_base, element_index);
        if byte_value < 0 {
            return -1;
        };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let bytes_ptr: i32 = ast_call_data_alloc(ast_base, length);
        if bytes_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let mut idx: i32 = 0;
        loop {
            if idx >= length {
                break;
            };
            store_i32(bytes_ptr + idx * WORD_SIZE, byte_value);
            idx = idx + 1;
        };
        store_i32(out_ptr_ptr, bytes_ptr);
        store_i32(out_len_ptr, length);
        return 0;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        if element_count == 0 {
            return 0;
        };
        if values_ptr < 0 {
            return -1;
        };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let bytes_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if bytes_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let byte_value: i32 = inline_wasm_literal_byte(ast_base, element_index);
            if byte_value < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            store_i32(bytes_ptr + idx * WORD_SIZE, byte_value);
            idx = idx + 1;
        };
        store_i32(out_ptr_ptr, bytes_ptr);
        store_i32(out_len_ptr, element_count);
        return 0;
    };
    -1
}

fn call_metadata_name_ptr(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr)
}

fn call_metadata_name_len(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 4)
}

fn call_metadata_arg_count(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 8)
}

fn call_metadata_callee_index_ptr(metadata_ptr: i32) -> i32 {
    metadata_ptr + 12
}

fn call_metadata_args_base(metadata_ptr: i32) -> i32 {
    metadata_ptr + 16
}

fn ast_write_function_entry(
    ast_base: i32,
    index: i32,
    name_ptr: i32,
    name_len: i32,
    param_count: i32,
    body_kind: i32,
    body_data0: i32,
    locals_count: i32,
    param_types_ptr: i32,
    return_type_id: i32,
    flags: i32,
) {
    let entry_ptr: i32 = ast_function_entry_ptr(ast_base, index);
    store_i32(entry_ptr, name_ptr);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, param_count);
    store_i32(entry_ptr + 12, body_kind);
    store_i32(entry_ptr + 16, body_data0);
    store_i32(entry_ptr + 20, locals_count);
    store_i32(entry_ptr + 24, param_types_ptr);
    store_i32(entry_ptr + 28, return_type_id);
    store_i32(entry_ptr + 32, flags);
}

fn ast_constants_count_ptr(ast_base: i32) -> i32 {
    ast_call_data_base(ast_base) + AST_CALL_DATA_CAPACITY * WORD_SIZE
}

fn ast_constant_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + WORD_SIZE + index * AST_CONSTANT_ENTRY_SIZE
}

fn ast_constants_count(ast_base: i32) -> i32 {
    load_i32(ast_constants_count_ptr(ast_base))
}

fn ast_constants_reset(ast_base: i32) {
    store_i32(ast_constants_count_ptr(ast_base), 0);
}

const AST_ARRAY_TYPES_CAPACITY: i32 = ARRAY_TYPE_CAPACITY;

const AST_ARRAY_TYPE_ENTRY_SIZE: i32 = 12;

const AST_ARRAY_TYPE_ELEMENT_OFFSET: i32 = 0;

const AST_ARRAY_TYPE_LENGTH_OFFSET: i32 = 4;

const AST_ARRAY_TYPE_CACHE_OFFSET: i32 = 8;

const AST_ARRAY_TYPES_SECTION_SIZE: i32 = WORD_SIZE + AST_ARRAY_TYPES_CAPACITY * AST_ARRAY_TYPE_ENTRY_SIZE;

fn ast_array_types_count_ptr(ast_base: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + AST_CONSTANTS_SECTION_SIZE
}

fn ast_array_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + WORD_SIZE + index * AST_ARRAY_TYPE_ENTRY_SIZE
}

fn ast_array_type_element_type(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_ELEMENT_OFFSET)
}

fn ast_array_type_length(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_LENGTH_OFFSET)
}

fn alias_type_metadata_index(index: i32) -> i32 {
    ARRAY_TYPE_CAPACITY + TUPLE_TYPE_CAPACITY + index
}

fn tuple_type_metadata_index(index: i32) -> i32 {
    ARRAY_TYPE_CAPACITY + index
}

fn ast_array_type_payload_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_type_entry_ptr(ast_base, index)
}

fn ast_array_types_count(ast_base: i32) -> i32 {
    load_i32(ast_array_types_count_ptr(ast_base))
}

fn ast_array_types_reset(ast_base: i32) {
    store_i32(ast_array_types_count_ptr(ast_base), 0);
}

const AST_TUPLE_TYPES_CAPACITY: i32 = TUPLE_TYPE_CAPACITY;

const AST_TUPLE_TYPE_ENTRY_SIZE: i32 = 12;

const AST_TUPLE_TYPE_COUNT_OFFSET: i32 = 0;

const AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET: i32 = 4;

const AST_TUPLE_TYPE_CACHE_OFFSET: i32 = 8;

const AST_TUPLE_TYPES_SECTION_SIZE: i32 =
    WORD_SIZE + AST_TUPLE_TYPES_CAPACITY * AST_TUPLE_TYPE_ENTRY_SIZE;

fn ast_tuple_types_count_ptr(ast_base: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + AST_ARRAY_TYPES_SECTION_SIZE
}

const AST_ARRAY_HEAP_INDEX_SECTION_SIZE: i32 = ARRAY_TYPE_CAPACITY * WORD_SIZE;

fn ast_array_heap_indices_base(ast_base: i32) -> i32 {
    ast_tuple_types_count_ptr(ast_base) + AST_TUPLE_TYPES_SECTION_SIZE
}

fn ast_array_heap_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_heap_indices_base(ast_base) + index * WORD_SIZE
}

fn ast_array_heap_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_heap_index_ptr(ast_base, index))
}

fn ast_array_heap_index_set(ast_base: i32, index: i32, heap_index: i32) {
    store_i32(ast_array_heap_index_ptr(ast_base, index), heap_index);
}

const AST_TUPLE_HEAP_INDEX_SECTION_SIZE: i32 = TUPLE_TYPE_CAPACITY * WORD_SIZE;

fn ast_tuple_heap_indices_base(ast_base: i32) -> i32 {
    ast_array_heap_indices_base(ast_base) + AST_ARRAY_HEAP_INDEX_SECTION_SIZE
}

fn ast_tuple_heap_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_tuple_heap_indices_base(ast_base) + index * WORD_SIZE
}

fn ast_tuple_heap_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_heap_index_ptr(ast_base, index))
}

fn ast_tuple_heap_index_set(ast_base: i32, index: i32, heap_index: i32) {
    store_i32(ast_tuple_heap_index_ptr(ast_base, index), heap_index);
}

fn ast_tuple_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_tuple_types_count_ptr(ast_base) + WORD_SIZE + index * AST_TUPLE_TYPE_ENTRY_SIZE
}

fn ast_tuple_types_count(ast_base: i32) -> i32 {
    load_i32(ast_tuple_types_count_ptr(ast_base))
}

fn ast_tuple_types_reset(ast_base: i32) {
    store_i32(ast_tuple_types_count_ptr(ast_base), 0);
}

fn ast_tuple_type_element_count(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_COUNT_OFFSET)
}

fn ast_tuple_type_elements_ptr(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET)
}

fn tuple_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_CACHE_OFFSET)
}

fn tuple_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_CACHE_OFFSET, type_id);
}

fn array_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET)
}

fn array_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET, type_id);
}

const AST_TYPE_DEFINITIONS_CAPACITY: i32 = TYPE_ALIAS_CAPACITY;

const AST_TYPE_DEFINITION_ENTRY_SIZE: i32 = 16;

const AST_TYPE_DEFINITION_NAME_START_OFFSET: i32 = 0;

const AST_TYPE_DEFINITION_NAME_LEN_OFFSET: i32 = 4;

const AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET: i32 = 8;

const AST_TYPE_DEFINITION_NAME_PTR_OFFSET: i32 = 12;

const AST_TYPE_DEFINITIONS_SECTION_SIZE: i32 =
    WORD_SIZE + AST_TYPE_DEFINITIONS_CAPACITY * AST_TYPE_DEFINITION_ENTRY_SIZE;

fn ast_type_definitions_count_ptr(ast_base: i32) -> i32 {
    ast_tuple_heap_indices_base(ast_base) + AST_TUPLE_HEAP_INDEX_SECTION_SIZE
}

fn ast_type_definition_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_type_definitions_count_ptr(ast_base) + WORD_SIZE + index * AST_TYPE_DEFINITION_ENTRY_SIZE
}

fn ast_type_definitions_count(ast_base: i32) -> i32 {
    load_i32(ast_type_definitions_count_ptr(ast_base))
}

fn ast_type_definitions_reset(ast_base: i32) {
    store_i32(ast_type_definitions_count_ptr(ast_base), 0);
}

fn ast_type_definition_name_start(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_NAME_START_OFFSET)
}

fn ast_type_definition_name_len(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_NAME_LEN_OFFSET)
}

fn ast_type_definition_target_type(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET)
}

fn ast_type_definition_name_ptr(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_NAME_PTR_OFFSET)
}

fn ast_type_definition_append(
    ast_base: i32,
    name_start: i32,
    name_len: i32,
    name_ptr: i32,
    target_type_id: i32,
) -> i32 {
    let count_ptr: i32 = ast_type_definitions_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_TYPE_DEFINITIONS_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_type_definition_entry_ptr(ast_base, count);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_START_OFFSET, name_start);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_LEN_OFFSET, name_len);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET, target_type_id);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_PTR_OFFSET, name_ptr);
    store_i32(count_ptr, count + 1);
    count
}

fn find_type_definition_entry_index(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let count: i32 = ast_type_definitions_count(ast_base);
    if count <= 0 {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_type_definition_entry_ptr(ast_base, idx);
        let def_start: i32 = load_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_START_OFFSET);
        let def_len: i32 = load_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_LEN_OFFSET);
        if identifiers_match_source(base, def_start, def_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn find_type_definition_target_type(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let index: i32 = find_type_definition_entry_index(base, ast_base, ident_start, ident_len);
    if index < 0 {
        return -1;
    };
    ast_type_definition_target_type(ast_base, index)
}

fn array_type_id(index: i32) -> i32 {
    TYPE_ID_ARRAY_BASE + index
}

fn array_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_ARRAY_BASE
}

fn array_type_element_type(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    ast_array_type_element_type(ast_base, index)
}

fn array_type_length(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    ast_array_type_length(ast_base, index)
}

fn tuple_type_id(index: i32) -> i32 {
    TYPE_ID_TUPLE_BASE + index
}

fn tuple_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_TUPLE_BASE
}

fn array_type_heap_index(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    let heap_index: i32 = ast_array_heap_index(ast_base, index);
    if heap_index < 0 {
        return -1;
    };
    heap_index
}

fn tuple_type_heap_index(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_tuple(type_id) {
        return -1;
    };
    let index: i32 = tuple_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_tuple_types_count(ast_base) {
        return -1;
    };
    let heap_index: i32 = ast_tuple_heap_index(ast_base, index);
    if heap_index < 0 {
        return -1;
    };
    heap_index
}

fn type_id_heap_type_index(ast_base: i32, type_id: i32) -> i32 {
    if type_id_is_array(type_id) {
        return array_type_heap_index(ast_base, type_id);
    };
    if type_id_is_tuple(type_id) {
        return tuple_type_heap_index(ast_base, type_id);
    };
    -1
}

fn composite_type_dependency_resolved(
    ast_base: i32,
    array_count: i32,
    tuple_count: i32,
    resolved_ptr: i32,
    type_id: i32,
) -> bool {
    if type_id_is_array(type_id) {
        let dep_index: i32 = array_type_index(type_id);
        if dep_index < 0 {
            return false;
        };
        if dep_index >= array_count {
            return false;
        };
        let resolved: i32 = load_i32(resolved_ptr + dep_index * WORD_SIZE);
        return resolved != 0;
    };
    if type_id_is_tuple(type_id) {
        let dep_index: i32 = tuple_type_index(type_id);
        if dep_index < 0 {
            return false;
        };
        if dep_index >= tuple_count {
            return false;
        };
        let resolved: i32 =
            load_i32(resolved_ptr + (array_count + dep_index) * WORD_SIZE);
        return resolved != 0;
    };
    true
}

fn composite_type_dependencies_resolved(
    ast_base: i32,
    array_count: i32,
    tuple_count: i32,
    resolved_ptr: i32,
    node_index: i32,
) -> bool {
    if node_index < array_count {
        let element_type_id: i32 = ast_array_type_element_type(ast_base, node_index);
        if element_type_id < 0 {
            return false;
        };
        return composite_type_dependency_resolved(
            ast_base,
            array_count,
            tuple_count,
            resolved_ptr,
            element_type_id,
        );
    };
    let tuple_idx: i32 = node_index - array_count;
    if tuple_idx < 0 {
        return false;
    };
    if tuple_idx >= tuple_count {
        return false;
    };
    let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
    if element_count < 0 {
        return false;
    };
    if element_count == 0 {
        return true;
    };
    let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
    if elements_ptr < 0 {
        return false;
    };
    let mut field_idx: i32 = 0;
    loop {
        if field_idx >= element_count {
            break;
        };
        let field_type_id: i32 = load_i32(elements_ptr + field_idx * WORD_SIZE);
        if field_type_id < 0 {
            return false;
        };
        if !composite_type_dependency_resolved(
            ast_base,
            array_count,
            tuple_count,
            resolved_ptr,
            field_type_id,
        ) {
            return false;
        };
        field_idx = field_idx + 1;
    };
    true
}

fn assign_heap_type_indices(out_ptr: i32, ast_base: i32) -> i32 {
    let array_count: i32 = ast_array_types_count(ast_base);
    if array_count < 0 {
        return -1;
    };
    let tuple_count: i32 = ast_tuple_types_count(ast_base);
    if tuple_count < 0 {
        return -1;
    };
    let total: i32 = array_count + tuple_count;
    let mut idx: i32 = 0;
    loop {
        if idx >= array_count {
            break;
        };
        ast_array_heap_index_set(ast_base, idx, -1);
        idx = idx + 1;
    };
    idx = 0;
    loop {
        if idx >= tuple_count {
            break;
        };
        ast_tuple_heap_index_set(ast_base, idx, -1);
        idx = idx + 1;
    };
    if total <= 0 {
        return 0;
    };
    let resolved_ptr: i32 = ast_temp_base(ast_base);
    let indices_ptr: i32 = resolved_ptr + total * WORD_SIZE;
    idx = 0;
    loop {
        if idx >= total {
            break;
        };
        store_i32(resolved_ptr + idx * WORD_SIZE, 0);
        store_i32(indices_ptr + idx * WORD_SIZE, -1);
        idx = idx + 1;
    };
    let mut assigned: i32 = 0;
    let mut next_index: i32 = 0;
    loop {
        if assigned >= total {
            break;
        };
        let mut progress: bool = false;
        let mut node: i32 = 0;
        loop {
            if node >= total {
                break;
            };
            let resolved: i32 = load_i32(resolved_ptr + node * WORD_SIZE);
            if resolved != 0 {
                node = node + 1;
                continue;
            };
            if composite_type_dependencies_resolved(
                ast_base,
                array_count,
                tuple_count,
                resolved_ptr,
                node,
            ) {
                store_i32(indices_ptr + node * WORD_SIZE, next_index);
                store_i32(resolved_ptr + node * WORD_SIZE, 1);
                next_index = next_index + 1;
                assigned = assigned + 1;
                progress = true;
            };
            node = node + 1;
        };
        if !progress {
            return -1;
        };
    };
    idx = 0;
    loop {
        if idx >= array_count {
            break;
        };
        let heap_index: i32 = load_i32(indices_ptr + idx * WORD_SIZE);
        if heap_index < 0 {
            return -1;
        };
        ast_array_heap_index_set(ast_base, idx, heap_index);
        idx = idx + 1;
    };
    idx = 0;
    loop {
        if idx >= tuple_count {
            break;
        };
        let node: i32 = array_count + idx;
        let heap_index: i32 = load_i32(indices_ptr + node * WORD_SIZE);
        if heap_index < 0 {
            return -1;
        };
        ast_tuple_heap_index_set(ast_base, idx, heap_index);
        idx = idx + 1;
    };
    0
}

fn ast_register_array_type(ast_base: i32, element_type_id: i32, length: i32) -> i32 {
    if length < 0 {
        return -1;
    };
    let count_ptr: i32 = ast_array_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, idx);
        let existing_element: i32 = load_i32(entry_ptr);
        let existing_length: i32 = load_i32(entry_ptr + 4);
        if existing_element == element_type_id && existing_length == length {
            return array_type_id(idx);
        };
        idx = idx + 1;
    };
    if count >= AST_ARRAY_TYPES_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, count);
    store_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET, element_type_id);
    store_i32(entry_ptr + AST_ARRAY_TYPE_LENGTH_OFFSET, length);
    store_i32(entry_ptr + AST_ARRAY_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    array_type_id(count)
}

fn ast_register_tuple_type(ast_base: i32, elements_ptr: i32, element_count: i32) -> i32 {
    if element_count < 0 {
        return -1;
    };
    if element_count > 0 && elements_ptr < 0 {
        return -1;
    };
    let count_ptr: i32 = ast_tuple_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, idx);
        let existing_count: i32 =
            load_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET);
        if existing_count != element_count {
            idx = idx + 1;
            continue;
        };
        if element_count == 0 {
            return tuple_type_id(idx);
        };
        let existing_ptr: i32 =
            load_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET);
        if existing_ptr < 0 {
            return -1;
        };
        let mut match_idx: i32 = 0;
        let mut matches: bool = true;
        loop {
            if match_idx >= element_count {
                break;
            };
            let existing_type: i32 =
                load_i32(existing_ptr + match_idx * WORD_SIZE);
            let new_type: i32 =
                load_i32(elements_ptr + match_idx * WORD_SIZE);
            if existing_type != new_type {
                matches = false;
                break;
            };
            match_idx = match_idx + 1;
        };
        if matches {
            return tuple_type_id(idx);
        };
        idx = idx + 1;
    };
    if count >= AST_TUPLE_TYPES_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, count);
    let stored_ptr: i32 = if element_count == 0 { 0 } else { elements_ptr };
    store_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET, element_count);
    store_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET, stored_ptr);
    store_i32(entry_ptr + AST_TUPLE_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    tuple_type_id(count)
}

fn ensure_array_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    };
    let cached: i32 = array_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    };
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_array_type_payload_ptr(ast_base, index),
    );
    array_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if index + 1 > current_count {
        scratch_types_set_count(out_ptr, index + 1);
    };
    0
}

fn ensure_tuple_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    let metadata_index: i32 = tuple_type_metadata_index(index);
    if metadata_index < 0 {
        return -1;
    };
    if metadata_index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    };
    let cached: i32 = tuple_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    };
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, metadata_index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_tuple_type_entry_ptr(ast_base, index),
    );
    tuple_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if metadata_index + 1 > current_count {
        scratch_types_set_count(out_ptr, metadata_index + 1);
    };
    0
}

fn ensure_alias_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= TYPE_ALIAS_CAPACITY {
        return -1;
    };
    let metadata_index: i32 = alias_type_metadata_index(index);
    if metadata_index < 0 {
        return -1;
    };
    if metadata_index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    };
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, metadata_index);
    let cached_type_id: i32 = load_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET);
    if cached_type_id == type_id {
        return 0;
    };
    let name_ptr: i32 = ast_type_definition_name_ptr(ast_base, index);
    let name_len: i32 = ast_type_definition_name_len(ast_base, index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, name_ptr);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, name_len);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_type_definition_entry_ptr(ast_base, index),
    );
    let current_count: i32 = scratch_types_count(out_ptr);
    if metadata_index + 1 > current_count {
        scratch_types_set_count(out_ptr, metadata_index + 1);
    };
    0
}

fn resolve_array_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    let mut element_type_id: i32 = ast_array_type_element_type(ast_base, index);
    let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type_id);
    if resolved_element < 0 {
        return -1;
    };
    if resolved_element != element_type_id {
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, index);
        store_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET, resolved_element);
        element_type_id = resolved_element;
    };
    let length: i32 = ast_array_type_length(ast_base, index);
    if length < 0 {
        return -1;
    };
    if ensure_array_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        return -1;
    };
    type_id
}

fn resolve_tuple_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_tuple(type_id) {
        return -1;
    };
    let index: i32 = tuple_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_tuple_types_count(ast_base) {
        return -1;
    };
    let element_count: i32 = ast_tuple_type_element_count(ast_base, index);
    if element_count < 0 {
        return -1;
    };
    if element_count > 0 {
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, index);
        if elements_ptr < 0 {
            return -1;
        };
        let mut elem_idx: i32 = 0;
        loop {
            if elem_idx >= element_count {
                break;
            };
            let type_ptr: i32 = elements_ptr + elem_idx * WORD_SIZE;
            let element_type_id: i32 = load_i32(type_ptr);
            let resolved_element: i32 =
                resolve_type_id(out_ptr, ast_base, element_type_id);
            if resolved_element < 0 {
                return -1;
            };
            if resolved_element != element_type_id {
                store_i32(type_ptr, resolved_element);
            };
            elem_idx = elem_idx + 1;
        };
    };
    if ensure_tuple_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        return -1;
    };
    type_id
}

fn resolve_alias_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_alias(type_id) {
        return -1;
    };
    let mut guard: i32 = 0;
    let mut current_type_id: i32 = type_id;
    loop {
        if guard >= TYPE_ALIAS_CAPACITY {
            return -1;
        };
        guard = guard + 1;
        let index: i32 = alias_type_index(current_type_id);
        if index < 0 {
            return -1;
        };
        if index >= ast_type_definitions_count(ast_base) {
            return -1;
        };
        if ensure_alias_type_metadata(out_ptr, ast_base, index, current_type_id) < 0 {
            return -1;
        };
        let target_type_id: i32 = ast_type_definition_target_type(ast_base, index);
        if target_type_id < 0 {
            return -1;
        };
        if type_id_is_alias(target_type_id) {
            current_type_id = target_type_id;
            continue;
        };
        let resolved: i32 = resolve_type_id(out_ptr, ast_base, target_type_id);
        if resolved < 0 {
            return -1;
        };
        return resolved;
    };
}

fn resolve_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if type_id < 0 {
        return -1;
    };
    if type_id_is_array(type_id) {
        return resolve_array_type_id(out_ptr, ast_base, type_id);
    };
    if type_id_is_tuple(type_id) {
        return resolve_tuple_type_id(out_ptr, ast_base, type_id);
    };
    if type_id_is_alias(type_id) {
        return resolve_alias_type_id(out_ptr, ast_base, type_id);
    };
    if type_id_is_builtin(type_id) {
        return type_id;
    };
    -1
}

fn ast_extra_base(ast_base: i32) -> i32 {
    ast_type_definitions_count_ptr(ast_base) + AST_TYPE_DEFINITIONS_SECTION_SIZE
}

const AST_EXPR_ENTRY_SIZE: i32 = 16;

const AST_EXPR_CAPACITY: i32 = 131072;

fn ast_expr_count_ptr(ast_base: i32) -> i32 {
    ast_extra_base(ast_base)
}

fn ast_expr_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_extra_base(ast_base) + WORD_SIZE + index * AST_EXPR_ENTRY_SIZE
}

fn ast_expr_types_base(ast_base: i32) -> i32 {
    ast_extra_base(ast_base) + 524292
}

fn ast_expr_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_expr_types_base(ast_base) + index * WORD_SIZE
}

fn ast_expr_set_type(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_expr_type_entry_ptr(ast_base, index), type_id);
}

fn ast_expr_type(ast_base: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= ast_expr_count(ast_base) {
        return -1;
    };
    load_i32(ast_expr_type_entry_ptr(ast_base, index))
}

fn ast_temp_base(ast_base: i32) -> i32 {
    ast_expr_types_base(ast_base) + 131072
}

fn ast_expr_reset(ast_base: i32) {
    store_i32(ast_expr_count_ptr(ast_base), 0);
}

fn ast_expr_count(ast_base: i32) -> i32 {
    load_i32(ast_expr_count_ptr(ast_base))
}

fn ast_expr_alloc(ast_base: i32, kind: i32, data0: i32, data1: i32, data2: i32) -> i32 {
    let count_ptr: i32 = ast_expr_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_EXPR_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, count);
    store_i32(entry_ptr, kind);
    store_i32(entry_ptr + 4, data0);
    store_i32(entry_ptr + 8, data1);
    store_i32(entry_ptr + 12, data2);
    store_i32(count_ptr, count + 1);
    ast_expr_set_type(ast_base, count, -1);
    count
}

fn ast_expr_alloc_literal(ast_base: i32, value: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 0, value, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_call(ast_base: i32, metadata_ptr: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 1, metadata_ptr, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_add(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 2, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_sub(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 3, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_mul(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 4, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_div(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 5, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_or(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 25, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_and(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 26, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_load_u8(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 29, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_load_u16(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 30, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_load_i32(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 31, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_u8(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 32, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_u16(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 33, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_i32(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 34, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_inline_wasm(ast_base: i32, bytes_ptr: i32, byte_count: i32) -> i32 {
    if byte_count < 0 {
        return -1;
    };
    if byte_count > 0 && bytes_ptr < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 42, bytes_ptr, byte_count, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_array_repeat(ast_base: i32, element_index: i32, length: i32) -> i32 {
    if length < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 35, element_index, length, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_list(ast_base: i32, values_ptr: i32, count: i32) -> i32 {
    if count <= 0 {
        return -1;
    };
    if values_ptr < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 37, values_ptr, count, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_get(ast_base: i32, array_index: i32, index_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 36, array_index, index_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_tuple_get(ast_base: i32, tuple_index: i32, field_index: i32) -> i32 {
    if field_index < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 41, tuple_index, field_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_len(ast_base: i32, array_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 38, array_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_tuple(ast_base: i32, values_ptr: i32, count: i32) -> i32 {
    if count < 0 {
        return -1;
    };
    if count > 0 && values_ptr < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 40, values_ptr, count, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_cast(ast_base: i32, value_index: i32, target_type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 39, value_index, target_type_id, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, target_type_id);
    index
}

fn ast_expr_alloc_shl(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 27, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_shr_s(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 28, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_eq(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 14, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ne(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 15, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_lt(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 16, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_gt(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 17, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_le(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 18, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ge(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 19, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_or(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 20, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_and(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 21, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_not(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 22, value_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_param(ast_base: i32, param_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 6, param_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_if(
    ast_base: i32,
    condition_index: i32,
    then_index: i32,
    else_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 7, condition_index, then_index, else_index);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_local(ast_base: i32, local_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 8, local_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_let(
    ast_base: i32,
    local_index: i32,
    init_index: i32,
    body_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 9, local_index, init_index, body_index);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_set_local(ast_base: i32, local_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 10, local_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn ast_expr_alloc_sequence(ast_base: i32, first_index: i32, then_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 11, first_index, then_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_loop(ast_base: i32, body_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 12, body_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_break(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 13, -1, value_index, 0);
    if index < 0 {
        return -1;
    };
    let value_type: i32 = if value_index >= 0 {
        ast_expr_type(ast_base, value_index)
    } else {
        -1
    };
    ast_expr_set_type(ast_base, index, value_type);
    index
}

fn ast_expr_alloc_continue(ast_base: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 24, -1, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_return(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 23, value_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn expression_node_from_parts(ast_base: i32, kind: i32, data0: i32, data1: i32) -> i32 {
    if kind == 0 {
        return ast_expr_alloc_literal(ast_base, data0, data1);
    };
    if kind == 1 {
        return ast_expr_alloc_call(ast_base, data0);
    };
    if kind == 6 {
        return ast_expr_alloc_param(ast_base, data0, data1);
    };
    if kind == 8 {
        return ast_expr_alloc_local(ast_base, data0, data1);
    };
    data0
}

fn load_expression_parts(kind_ptr: i32, data0_ptr: i32, data1_ptr: i32) -> (i32, i32, i32) {
    (
        load_i32(kind_ptr),
        load_i32(data0_ptr),
        load_i32(data1_ptr),
    )
}

fn store_expression_parts(
    kind_ptr: i32,
    data0_ptr: i32,
    data1_ptr: i32,
    parts: (i32, i32, i32),
) {
    store_i32(kind_ptr, parts.0);
    store_i32(data0_ptr, parts.1);
    store_i32(data1_ptr, parts.2);
}

fn expression_index_from_parts(ast_base: i32, parts: (i32, i32, i32)) -> i32 {
    expression_node_from_parts(ast_base, parts.0, parts.1, parts.2)
}

fn parse_basic_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    nested_temp_base: i32,
) -> i32 {
    if cursor >= len {
        return -1;
    };
    let first_byte: i32 = load_u8(base + cursor);
    if first_byte == '{' {
        let block_status_ptr: i32 = nested_temp_base + 4096;
        let block_cursor: i32 = parse_block_expression_body(
            base,
            len,
            cursor + 1,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            literal_ptr,
            nested_temp_base,
            0,
            loop_depth_ptr,
            out_kind_ptr,
            out_data0_ptr,
            out_data1_ptr,
            block_status_ptr,
        );
        if block_cursor < 0 {
            return -1;
        };
        return block_cursor;
    };
    if first_byte == 'i' {
        let mut if_cursor: i32 = expect_keyword_if(base, len, cursor);
        if if_cursor >= 0 {
            let cond_kind_ptr: i32 = nested_temp_base;
            let cond_data0_ptr: i32 = nested_temp_base + 4;
            let cond_data1_ptr: i32 = nested_temp_base + 8;
            let then_kind_ptr: i32 = nested_temp_base + 12;
            let then_data0_ptr: i32 = nested_temp_base + 16;
            let then_data1_ptr: i32 = nested_temp_base + 20;
            let then_status_ptr: i32 = nested_temp_base + 24;
            let else_kind_ptr: i32 = nested_temp_base + 28;
            let else_data0_ptr: i32 = nested_temp_base + 32;
            let else_data1_ptr: i32 = nested_temp_base + 36;
            let else_status_ptr: i32 = nested_temp_base + 40;
            let cond_nested_base: i32 = nested_temp_base + 160;
            let then_nested_base: i32 = nested_temp_base + 320;
            let else_nested_base: i32 = nested_temp_base + 480;
            if_cursor = skip_whitespace(base, len, if_cursor);
            if_cursor = parse_expression(
                base,
                len,
                if_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                cond_nested_base,
                loop_depth_ptr,
                cond_kind_ptr,
                cond_data0_ptr,
                cond_data1_ptr,
            );
            if if_cursor < 0 {
                return -1;
            };
            if_cursor = skip_whitespace(base, len, if_cursor);
            if_cursor = expect_char(base, len, if_cursor, '{');
            if if_cursor < 0 {
                return -1;
            };
            if_cursor = parse_block_expression_body(
                base,
                len,
                if_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                then_nested_base,
                1,
                loop_depth_ptr,
                then_kind_ptr,
                then_data0_ptr,
                then_data1_ptr,
                then_status_ptr,
            );
            if if_cursor < 0 {
                return -1;
            };
            store_i32(else_kind_ptr, 0);
            store_i32(else_data0_ptr, 0);
            store_i32(else_data1_ptr, 0);
            store_i32(else_status_ptr, 1);
            store_i32(literal_ptr, if_cursor);
            if_cursor = expect_keyword_else(base, len, if_cursor);
            if if_cursor >= 0 {
                if_cursor = skip_whitespace(base, len, if_cursor);
                if if_cursor >= len {
                    return -1;
                };
                let after_else_byte: i32 = load_u8(base + if_cursor);
                if after_else_byte == '{' {
                    if_cursor = expect_char(base, len, if_cursor, '{');
                    if if_cursor < 0 {
                        return -1;
                    };
                    if_cursor = parse_block_expression_body(
                        base,
                        len,
                        if_cursor,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        locals_table_ptr,
                        locals_stack_count_ptr,
                        locals_next_index_ptr,
                        literal_ptr,
                        else_nested_base,
                        1,
                        loop_depth_ptr,
                        else_kind_ptr,
                        else_data0_ptr,
                        else_data1_ptr,
                        else_status_ptr,
                    );
                    if if_cursor < 0 {
                        return -1;
                    };
                } else {
                    let else_if_cursor: i32 = if_cursor;
                    let maybe_else_if: i32 = expect_keyword_if(base, len, else_if_cursor);
                    if maybe_else_if < 0 {
                        return -1;
                    };
                    if_cursor = parse_expression(
                        base,
                        len,
                        else_if_cursor,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        locals_table_ptr,
                        locals_stack_count_ptr,
                        locals_next_index_ptr,
                        else_nested_base,
                        loop_depth_ptr,
                        else_kind_ptr,
                        else_data0_ptr,
                        else_data1_ptr,
                    );
                    if if_cursor < 0 {
                        return -1;
                    };
                    store_i32(else_status_ptr, -1);
                    if_cursor = skip_whitespace(base, len, if_cursor);
                };
            } else {
                if_cursor = load_i32(literal_ptr);
            };
            let cond_kind: i32 = load_i32(cond_kind_ptr);
            let cond_data0: i32 = load_i32(cond_data0_ptr);
            let cond_data1: i32 = load_i32(cond_data1_ptr);
            let cond_index: i32 =
                expression_node_from_parts(ast_base, cond_kind, cond_data0, cond_data1);
            if cond_index < 0 {
                return -1;
            };
            let then_parts: (i32, i32, i32) =
                load_expression_parts(then_kind_ptr, then_data0_ptr, then_data1_ptr);
            let then_index: i32 = expression_index_from_parts(ast_base, then_parts);
            if then_index < 0 {
                return -1;
            };
            let else_parts: (i32, i32, i32) =
                load_expression_parts(else_kind_ptr, else_data0_ptr, else_data1_ptr);
            let else_index: i32 = expression_index_from_parts(ast_base, else_parts);
            if else_index < 0 {
                return -1;
            };
            if load_i32(else_status_ptr) < 0 {
                let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
                let else_has_value: i32 = if else_diverges { 0 } else { 1 };
                store_i32(else_status_ptr, else_has_value);
            };
            let then_has_value: i32 = load_i32(then_status_ptr);
            let else_has_value: i32 = load_i32(else_status_ptr);
            let if_index: i32 = ast_expr_alloc_if(ast_base, cond_index, then_index, else_index);
            if if_index < 0 {
                return -1;
            };
            store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, if_index, 0));
            let both_have_values: i32 = if then_has_value != 0 && else_has_value != 0 {
                0
            } else {
                -1
            };
            store_i32(out_data1_ptr, both_have_values);
            return skip_whitespace(base, len, if_cursor);
        };
    };
    if first_byte == '[' {
        let element_kind_ptr: i32 = nested_temp_base;
        let element_data0_ptr: i32 = nested_temp_base + 4;
        let element_data1_ptr: i32 = nested_temp_base + 8;
        let values_list_ptr: i32 = nested_temp_base + 16;
        let element_temp_base: i32 =
            nested_temp_base + 16 + MAX_ARRAY_LITERAL_ELEMENTS * WORD_SIZE + 64;
        let mut array_cursor: i32 = cursor + 1;
        array_cursor = skip_whitespace(base, len, array_cursor);
        array_cursor = parse_expression(
            base,
            len,
            array_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            element_temp_base,
            loop_depth_ptr,
            element_kind_ptr,
            element_data0_ptr,
            element_data1_ptr,
        );
        if array_cursor < 0 {
            return -1;
        };
        let element_kind: i32 = load_i32(element_kind_ptr);
        let element_data0: i32 = load_i32(element_data0_ptr);
        let element_data1: i32 = load_i32(element_data1_ptr);
        let element_index: i32 =
            expression_node_from_parts(ast_base, element_kind, element_data0, element_data1);
        if element_index < 0 {
            return -1;
        };
        array_cursor = skip_whitespace(base, len, array_cursor);
        if array_cursor >= len {
            return -1;
        };
        let mut delimiter: i32 = load_u8(base + array_cursor);
        if delimiter == ';' {
            array_cursor = expect_char(base, len, array_cursor, ';');
            if array_cursor < 0 {
                return -1;
            };
            array_cursor = skip_whitespace(base, len, array_cursor);
            let literal_cursor: i32 = parse_i32_literal(base, len, array_cursor, literal_ptr);
            let mut length: i32 = -1;
            if literal_cursor >= 0 {
                length = load_i32(literal_ptr);
                if length < 0 {
                    return -1;
                };
                array_cursor = literal_cursor;
            } else {
                let length_temp_root: i32 = ast_temp_base(ast_base);
                let length_params_table_ptr: i32 = length_temp_root;
                let length_kind_ptr: i32 = length_params_table_ptr + MAX_PARAMS * 8;
                let length_data0_ptr: i32 = length_kind_ptr + 4;
                let length_data1_ptr: i32 = length_kind_ptr + 8;
                let length_locals_stack_count_ptr: i32 = length_kind_ptr + 12;
                let length_locals_table_ptr: i32 = length_locals_stack_count_ptr + 4;
                let length_locals_next_index_ptr: i32 =
                    length_locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
                let length_loop_depth_ptr: i32 = length_locals_next_index_ptr + 4;
                let length_temp_base: i32 = length_loop_depth_ptr + 4;
                store_i32(length_locals_stack_count_ptr, 0);
                store_i32(length_locals_next_index_ptr, 0);
                store_i32(length_loop_depth_ptr, 0);
                array_cursor = parse_expression(
                    base,
                    len,
                    array_cursor,
                    ast_base,
                    length_params_table_ptr,
                    0,
                    length_locals_table_ptr,
                    length_locals_stack_count_ptr,
                    length_locals_next_index_ptr,
                    length_temp_base,
                    length_loop_depth_ptr,
                    length_kind_ptr,
                    length_data0_ptr,
                    length_data1_ptr,
                );
                if array_cursor < 0 {
                    return -1;
                };
                let length_value_ptr: i32 = length_temp_base;
                let length_type_ptr: i32 = length_value_ptr + 4;
                let length_scratch_base: i32 = length_type_ptr + 4;
                if evaluate_expression_literal(
                    ast_base,
                    length_kind_ptr,
                    length_data0_ptr,
                    length_data1_ptr,
                    length_scratch_base,
                    length_value_ptr,
                    length_type_ptr,
                ) < 0 {
                    return -1;
                };
                let length_type: i32 = load_i32(length_type_ptr);
                if !constant_eval_integer_type_supported(length_type) {
                    return -1;
                };
                length =
                    normalize_integer_value(load_i32(length_value_ptr), length_type);
                if length < 0 {
                    return -1;
                };
            };
            array_cursor = skip_whitespace(base, len, array_cursor);
            array_cursor = expect_char(base, len, array_cursor, ']');
            if array_cursor < 0 {
                return -1;
            };
            let expr_index: i32 = ast_expr_alloc_array_repeat(ast_base, element_index, length);
            if expr_index < 0 {
                return -1;
            };
            store_i32(out_kind_ptr, 35);
            store_i32(out_data0_ptr, expr_index);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, array_cursor);
        };
        store_i32(values_list_ptr, element_index);
        let mut element_count: i32 = 1;
        loop {
            if delimiter == ',' {
                array_cursor = skip_whitespace(base, len, array_cursor + 1);
                if array_cursor >= len {
                    return -1;
                };
                let after_comma: i32 = load_u8(base + array_cursor);
                if after_comma == ']' {
                    array_cursor = array_cursor + 1;
                    break;
                };
                array_cursor = parse_expression(
                    base,
                    len,
                    array_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    element_temp_base,
                    loop_depth_ptr,
                    element_kind_ptr,
                    element_data0_ptr,
                    element_data1_ptr,
                );
                if array_cursor < 0 {
                    return -1;
                };
                let next_kind: i32 = load_i32(element_kind_ptr);
                let next_data0: i32 = load_i32(element_data0_ptr);
                let next_data1: i32 = load_i32(element_data1_ptr);
                let next_index: i32 = expression_node_from_parts(
                    ast_base,
                    next_kind,
                    next_data0,
                    next_data1,
                );
                if next_index < 0 {
                    return -1;
                };
                if element_count >= MAX_ARRAY_LITERAL_ELEMENTS {
                    return -1;
                };
                store_i32(values_list_ptr + element_count * WORD_SIZE, next_index);
                element_count = element_count + 1;
                array_cursor = skip_whitespace(base, len, array_cursor);
                if array_cursor >= len {
                    return -1;
                };
                delimiter = load_u8(base + array_cursor);
                continue;
            };
            if delimiter == ']' {
                array_cursor = array_cursor + 1;
                break;
            };
            return -1;
        };
        let metadata_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if metadata_ptr < 0 {
            return -1;
        };
        let mut copy_idx: i32 = 0;
        loop {
            if copy_idx >= element_count {
                break;
            };
            let value_index: i32 = load_i32(values_list_ptr + copy_idx * WORD_SIZE);
            store_i32(metadata_ptr + copy_idx * WORD_SIZE, value_index);
            copy_idx = copy_idx + 1;
        };
        let expr_index: i32 = ast_expr_alloc_array_list(ast_base, metadata_ptr, element_count);
        if expr_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, 37);
        store_i32(out_data0_ptr, expr_index);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, array_cursor);
    };
    if first_byte == '(' {
        let mut paren_cursor: i32 = cursor + 1;
        paren_cursor = skip_whitespace(base, len, paren_cursor);
        if paren_cursor >= len {
            return -1;
        };
        let maybe_close: i32 = load_u8(base + paren_cursor);
        if maybe_close == ')' {
            let expr_index: i32 = ast_expr_alloc_tuple(ast_base, 0, 0);
            if expr_index < 0 {
                return -1;
            };
            store_i32(out_kind_ptr, 40);
            store_i32(out_data0_ptr, expr_index);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, paren_cursor + 1);
        };
        let first_kind_ptr: i32 = nested_temp_base;
        let first_data0_ptr: i32 = nested_temp_base + 4;
        let first_data1_ptr: i32 = nested_temp_base + 8;
        let values_list_ptr: i32 = nested_temp_base + 16;
        let element_temp_base: i32 =
            nested_temp_base + 16 + MAX_TUPLE_ELEMENTS * WORD_SIZE + 64;
        paren_cursor = parse_expression(
            base,
            len,
            paren_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            element_temp_base,
            loop_depth_ptr,
            first_kind_ptr,
            first_data0_ptr,
            first_data1_ptr,
        );
        if paren_cursor < 0 {
            return -1;
        };
        paren_cursor = skip_whitespace(base, len, paren_cursor);
        if paren_cursor >= len {
            return -1;
        };
        let mut delimiter: i32 = load_u8(base + paren_cursor);
        if delimiter != ',' {
            if delimiter != ')' {
                return -1;
            };
            let first_kind: i32 = load_i32(first_kind_ptr);
            let first_data0: i32 = load_i32(first_data0_ptr);
            let first_data1: i32 = load_i32(first_data1_ptr);
            store_i32(out_kind_ptr, first_kind);
            store_i32(out_data0_ptr, first_data0);
            store_i32(out_data1_ptr, first_data1);
            return skip_whitespace(base, len, paren_cursor + 1);
        };
        let first_kind: i32 = load_i32(first_kind_ptr);
        let first_data0: i32 = load_i32(first_data0_ptr);
        let first_data1: i32 = load_i32(first_data1_ptr);
        let first_index: i32 =
            expression_node_from_parts(ast_base, first_kind, first_data0, first_data1);
        if first_index < 0 {
            return -1;
        };
        store_i32(values_list_ptr, first_index);
        let mut element_count: i32 = 1;
        let mut tuple_cursor: i32 = skip_whitespace(base, len, paren_cursor + 1);
        loop {
            if tuple_cursor >= len {
                return -1;
            };
            let tuple_byte: i32 = load_u8(base + tuple_cursor);
            if tuple_byte == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            };
            if element_count >= MAX_TUPLE_ELEMENTS {
                return -1;
            };
            tuple_cursor = parse_expression(
                base,
                len,
                tuple_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                element_temp_base,
                loop_depth_ptr,
                first_kind_ptr,
                first_data0_ptr,
                first_data1_ptr,
            );
            if tuple_cursor < 0 {
                return -1;
            };
            let value_kind: i32 = load_i32(first_kind_ptr);
            let value_data0: i32 = load_i32(first_data0_ptr);
            let value_data1: i32 = load_i32(first_data1_ptr);
            let value_index: i32 = expression_node_from_parts(
                ast_base,
                value_kind,
                value_data0,
                value_data1,
            );
            if value_index < 0 {
                return -1;
            };
            store_i32(values_list_ptr + element_count * WORD_SIZE, value_index);
            element_count = element_count + 1;
            tuple_cursor = skip_whitespace(base, len, tuple_cursor);
            if tuple_cursor >= len {
                return -1;
            };
            delimiter = load_u8(base + tuple_cursor);
            if delimiter == ',' {
                tuple_cursor = skip_whitespace(base, len, tuple_cursor + 1);
                continue;
            };
            if delimiter == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            };
            return -1;
        };
        let metadata_ptr: i32 = if element_count == 0 {
            0
        } else {
            ast_call_data_alloc(ast_base, element_count)
        };
        if element_count > 0 && metadata_ptr < 0 {
            return -1;
        };
        if element_count > 0 {
            let mut copy_idx: i32 = 0;
            loop {
                if copy_idx >= element_count {
                    break;
                };
                let value_index: i32 =
                    load_i32(values_list_ptr + copy_idx * WORD_SIZE);
                store_i32(metadata_ptr + copy_idx * WORD_SIZE, value_index);
                copy_idx = copy_idx + 1;
            };
        };
        let expr_index: i32 = ast_expr_alloc_tuple(ast_base, metadata_ptr, element_count);
        if expr_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, 40);
        store_i32(out_data0_ptr, expr_index);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, tuple_cursor);
    };
    if first_byte == '"' {
        let values_list_ptr: i32 = nested_temp_base;
        let mut string_cursor: i32 = cursor + 1;
        let mut element_count: i32 = 0;
        loop {
            if string_cursor >= len {
                return -1;
            };
            let byte: i32 = load_u8(base + string_cursor);
            if byte == '"' {
                string_cursor = string_cursor + 1;
                break;
            };
            let mut value: i32 = byte;
            string_cursor = string_cursor + 1;
            if value == '\\' {
                if string_cursor >= len {
                    return -1;
                };
                let escape: i32 = load_u8(base + string_cursor);
                value = if escape == 'n' {
                    '\n'
                } else if escape == 'r' {
                    '\r'
                } else if escape == 't' {
                    '\t'
                } else if escape == '0' {
                    '\0'
                } else if escape == '\\' {
                    '\\'
                } else if escape == '\'' {
                    '\''
                } else if escape == 34 {
                    34
                } else {
                    return -1;
                };
                string_cursor = string_cursor + 1;
            } else if value == '\n' || value == '\r' {
                return -1;
            };
            if element_count >= MAX_ARRAY_LITERAL_ELEMENTS {
                return -1;
            };
            let literal_index: i32 =
                ast_expr_alloc_literal(ast_base, value, BUILTIN_TYPE_ID_U8);
            if literal_index < 0 {
                return -1;
            };
            store_i32(values_list_ptr + element_count * WORD_SIZE, literal_index);
            element_count = element_count + 1;
        };
        let expr_index: i32 = if element_count == 0 {
            let zero_index: i32 = ast_expr_alloc_literal(ast_base, 0, BUILTIN_TYPE_ID_U8);
            if zero_index < 0 {
                return -1;
            };
            ast_expr_alloc_array_repeat(ast_base, zero_index, 0)
        } else {
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
            if metadata_ptr < 0 {
                return -1;
            };
            let mut copy_idx: i32 = 0;
            loop {
                if copy_idx >= element_count {
                    break;
                };
                let value_index: i32 =
                    load_i32(values_list_ptr + copy_idx * WORD_SIZE);
                store_i32(metadata_ptr + copy_idx * WORD_SIZE, value_index);
                copy_idx = copy_idx + 1;
            };
            ast_expr_alloc_array_list(ast_base, metadata_ptr, element_count)
        };
        if expr_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, if element_count == 0 { 35 } else { 37 });
        store_i32(out_data0_ptr, expr_index);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, string_cursor);
    };
    if first_byte == '\'' {
        let next_cursor: i32 = parse_char_literal(base, len, cursor, literal_ptr);
        if next_cursor < 0 {
            return -1;
        };
        let value: i32 = load_i32(literal_ptr);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, value);
        store_i32(out_data1_ptr, BUILTIN_TYPE_ID_I32);
        return skip_whitespace(base, len, next_cursor);
    };
    if first_byte == '-' || is_digit(first_byte) {
        let next_cursor: i32 = parse_i32_literal(base, len, cursor, literal_ptr);
        if next_cursor < 0 {
            return -1;
        };
        let value: i32 = load_i32(literal_ptr);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, value);
        store_i32(out_data1_ptr, BUILTIN_TYPE_ID_I32);
        return skip_whitespace(base, len, next_cursor);
    };
    if first_byte == 't' {
        let next_cursor: i32 = expect_keyword_true(base, len, cursor);
        if next_cursor >= 0 {
            store_i32(out_kind_ptr, 0);
            store_i32(out_data0_ptr, 1);
            store_i32(out_data1_ptr, BUILTIN_TYPE_ID_BOOL);
            return skip_whitespace(base, len, next_cursor);
        };
    };
    if first_byte == 'f' {
        let next_cursor: i32 = expect_keyword_false(base, len, cursor);
        if next_cursor >= 0 {
            store_i32(out_kind_ptr, 0);
            store_i32(out_data0_ptr, 0);
            store_i32(out_data1_ptr, BUILTIN_TYPE_ID_BOOL);
            return skip_whitespace(base, len, next_cursor);
        };
    };
    if !is_identifier_start(first_byte) {
        return -1;
    };
    let ident: (i32, i32, i32) = parse_identifier(base, len, cursor);
    let mut next_cursor: i32 = ident.0;
    if next_cursor < 0 {
        return -1;
    };
    let ident_start: i32 = ident.1;
    let ident_len: i32 = ident.2;
    next_cursor = skip_whitespace(base, len, next_cursor);
    if next_cursor < len {
        let next_byte: i32 = load_u8(base + next_cursor);
        if next_byte == '(' {
            let mut call_cursor: i32 = next_cursor + 1;
            call_cursor = skip_whitespace(base, len, call_cursor);
            let args_limit: i32 = MAX_PARAMS;
            let arg_kind_ptr: i32 = nested_temp_base;
            let arg_data0_ptr: i32 = nested_temp_base + 4;
            let arg_data1_ptr: i32 = nested_temp_base + 8;
            let args_list_ptr: i32 = nested_temp_base + 16;
            let arg_nested_base: i32 = nested_temp_base + 160;
            let mut arg_count: i32 = 0;
            if call_cursor < len {
                let maybe_close: i32 = load_u8(base + call_cursor);
                if maybe_close == ')' {
                    call_cursor = call_cursor + 1;
                } else {
                    loop {
                        if arg_count >= args_limit {
                            return -1;
                        };
                        call_cursor = parse_expression(
                            base,
                            len,
                            call_cursor,
                            ast_base,
                            params_table_ptr,
                            params_count,
                            locals_table_ptr,
                            locals_stack_count_ptr,
                            locals_next_index_ptr,
                            arg_nested_base,
                            loop_depth_ptr,
                            arg_kind_ptr,
                            arg_data0_ptr,
                            arg_data1_ptr,
                        );
                        if call_cursor < 0 {
                            return -1;
                        };
                        let arg_kind: i32 = load_i32(arg_kind_ptr);
                        let arg_data0: i32 = load_i32(arg_data0_ptr);
                        let arg_data1: i32 = load_i32(arg_data1_ptr);
                        let arg_index: i32 =
                            expression_node_from_parts(ast_base, arg_kind, arg_data0, arg_data1);
                        if arg_index < 0 {
                            return -1;
                        };
                        store_i32(args_list_ptr + arg_count * 4, arg_index);
                        arg_count = arg_count + 1;
                        call_cursor = skip_whitespace(base, len, call_cursor);
                        if call_cursor >= len {
                            return -1;
                        };
                        let delimiter: i32 = load_u8(base + call_cursor);
                        if delimiter == ',' {
                            call_cursor = skip_whitespace(base, len, call_cursor + 1);
                            if call_cursor >= len {
                                return -1;
                            };
                            let after_comma: i32 = load_u8(base + call_cursor);
                            if after_comma == ')' {
                                call_cursor = call_cursor + 1;
                                break;
                            };
                            continue;
                        };
                        if delimiter == ')' {
                            call_cursor = call_cursor + 1;
                            break;
                        };
                        return -1;
                    };
                };
            } else {
                return -1;
            };
            let intrinsic_kind: i32 =
                identify_intrinsic(base, len, ident_start, ident_len);
            if intrinsic_kind != INTRINSIC_KIND_NONE {
                if intrinsic_kind == INTRINSIC_KIND_LEN {
                    if arg_count != 1 {
                        return -1;
                    };
                    let array_index: i32 = load_i32(args_list_ptr);
                    let expr_index: i32 = ast_expr_alloc_array_len(ast_base, array_index);
                    if expr_index < 0 {
                        return -1;
                    };
                    store_i32(out_kind_ptr, 38);
                    store_i32(out_data0_ptr, expr_index);
                    store_i32(out_data1_ptr, 0);
                    return skip_whitespace(base, len, call_cursor);
                };
                if intrinsic_kind == INTRINSIC_KIND_INLINE_WASM {
                    if arg_count != 1 {
                        return -1;
                    };
                    let arg_index: i32 = load_i32(args_list_ptr);
                    let bytes_ptr_ptr: i32 = arg_nested_base;
                    let byte_count_ptr: i32 = arg_nested_base + 4;
                    if inline_wasm_collect_bytes(
                        ast_base,
                        arg_index,
                        bytes_ptr_ptr,
                        byte_count_ptr,
                    ) < 0 {
                        return -1;
                    };
                    let bytes_ptr: i32 = load_i32(bytes_ptr_ptr);
                    let byte_count: i32 = load_i32(byte_count_ptr);
                    let expr_index: i32 =
                        ast_expr_alloc_inline_wasm(ast_base, bytes_ptr, byte_count);
                    if expr_index < 0 {
                        return -1;
                    };
                    store_i32(out_kind_ptr, 42);
                    store_i32(out_data0_ptr, expr_index);
                    store_i32(out_data1_ptr, 0);
                    return skip_whitespace(base, len, call_cursor);
                };
                return -1;
            };
            let name_ptr: i32 = ast_store_name(ast_base, base, ident_start, ident_len);
            if name_ptr < 0 {
                return -1;
            };
            let metadata_words: i32 = 4 + arg_count;
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, metadata_words);
            if metadata_ptr < 0 {
                return -1;
            };
            store_i32(metadata_ptr, name_ptr);
            store_i32(metadata_ptr + 4, ident_len);
            store_i32(metadata_ptr + 8, arg_count);
            store_i32(metadata_ptr + 12, -1);
            let mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= arg_count {
                    break;
                };
                let arg_value: i32 = load_i32(args_list_ptr + arg_idx * 4);
                store_i32(metadata_ptr + 16 + arg_idx * 4, arg_value);
                arg_idx = arg_idx + 1;
            };
            store_i32(out_kind_ptr, 1);
            store_i32(out_data0_ptr, metadata_ptr);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, call_cursor);
        };
    };
    let param_index: i32 =
        find_parameter_index(base, params_table_ptr, params_count, ident_start, ident_len);
    if param_index >= 0 {
        let param_types_table_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
        let param_type_id: i32 = load_i32(param_types_table_ptr + param_index * 4);
        store_i32(out_kind_ptr, 6);
        store_i32(out_data0_ptr, param_index);
        store_i32(out_data1_ptr, param_type_id);
        return skip_whitespace(base, len, next_cursor);
    };
    let locals_stack: i32 = load_i32(locals_stack_count_ptr);
    let local_entry_index: i32 = find_local_entry_index(
        base,
        locals_table_ptr,
        locals_stack,
        ident_start,
        ident_len,
    );
    if local_entry_index < 0 {
        let constant_entry_index: i32 =
            find_constant_entry_index(base, ast_base, ident_start, ident_len);
        if constant_entry_index < 0 {
            return -1;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, constant_entry_index);
        let const_value: i32 = load_i32(const_entry_ptr + 8);
        let const_type: i32 = load_i32(const_entry_ptr + 12);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, const_value);
        store_i32(out_data1_ptr, const_type);
        return skip_whitespace(base, len, next_cursor);
    };
    let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, local_entry_index);
    let local_index: i32 = locals_entry_local_index(entry_ptr);
    let local_type_id: i32 = locals_entry_type_id(entry_ptr);
    store_i32(out_kind_ptr, 8);
    store_i32(out_data0_ptr, local_index);
    store_i32(out_data1_ptr, local_type_id);
    skip_whitespace(base, len, next_cursor)
}

fn parse_unary_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    nested_temp_base: i32,
) -> i32 {
    let mut current_cursor: i32 = cursor;
    let mut not_count: i32 = 0;
    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '!' {
            break;
        };
        not_count = not_count + 1;
        current_cursor = skip_whitespace(base, len, current_cursor + 1);
    };

    let mut resolved_cursor: i32 = parse_basic_expression(
        base,
        len,
        current_cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        literal_ptr,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
        nested_temp_base,
    );
    if resolved_cursor < 0 {
        return -1;
    };

    let index_kind_ptr: i32 = nested_temp_base;
    let index_data0_ptr: i32 = nested_temp_base + 4;
    let index_data1_ptr: i32 = nested_temp_base + 8;
    let index_temp_base: i32 = nested_temp_base + 32;

    loop {
        if resolved_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + resolved_cursor);
        if next_byte == '[' {
            let mut index_cursor: i32 = skip_whitespace(base, len, resolved_cursor + 1);
            index_cursor = parse_expression(
                base,
                len,
                index_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                index_temp_base,
                loop_depth_ptr,
                index_kind_ptr,
                index_data0_ptr,
                index_data1_ptr,
            );
            if index_cursor < 0 {
                return -1;
            };
            index_cursor = skip_whitespace(base, len, index_cursor);
            index_cursor = expect_char(base, len, index_cursor, ']');
            if index_cursor < 0 {
                return -1;
            };

            let array_parts: (i32, i32, i32) =
                load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
            let array_expr_index: i32 = expression_index_from_parts(ast_base, array_parts);
            if array_expr_index < 0 {
                return -1;
            };

            let idx_parts: (i32, i32, i32) =
                load_expression_parts(index_kind_ptr, index_data0_ptr, index_data1_ptr);
            let idx_expr_index: i32 = expression_index_from_parts(ast_base, idx_parts);
            if idx_expr_index < 0 {
                return -1;
            };

            let get_index: i32 =
                ast_expr_alloc_array_get(ast_base, array_expr_index, idx_expr_index);
            if get_index < 0 {
                return -1;
            };

            let array_type_id: i32 = ast_expr_type(ast_base, array_expr_index);
            if type_id_is_array(array_type_id) {
                let element_type_id: i32 =
                    array_type_element_type(ast_base, array_type_id);
                if element_type_id >= 0 {
                    ast_expr_set_type(ast_base, get_index, element_type_id);
                };
            };

            store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, get_index, 0));

            resolved_cursor = skip_whitespace(base, len, index_cursor);
            continue;
        };
        if next_byte != '.' {
            break;
        };
        let mut field_cursor: i32 = resolved_cursor + 1;
        if field_cursor >= len {
            return -1;
        };
        let mut field_index: i32 = 0;
        let mut digits: i32 = 0;
        loop {
            if field_cursor >= len {
                break;
            };
            let digit_byte: i32 = load_u8(base + field_cursor);
            if !is_digit(digit_byte) {
                break;
            };
            field_index = field_index * 10 + (digit_byte - '0');
            field_cursor = field_cursor + 1;
            digits = digits + 1;
        };
        if digits == 0 {
            return -1;
        };

        let tuple_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let tuple_expr_index: i32 = expression_index_from_parts(ast_base, tuple_parts);
        if tuple_expr_index < 0 {
            return -1;
        };

        let get_index: i32 =
            ast_expr_alloc_tuple_get(ast_base, tuple_expr_index, field_index);
        if get_index < 0 {
            return -1;
        };

        let tuple_type_id: i32 = ast_expr_type(ast_base, tuple_expr_index);
        if type_id_is_tuple(tuple_type_id) {
            let tuple_idx: i32 = tuple_type_index(tuple_type_id);
            if tuple_idx >= 0 {
                let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
                if field_index < element_count {
                    let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
                    if elements_ptr >= 0 {
                        let field_type_id: i32 =
                            load_i32(elements_ptr + field_index * WORD_SIZE);
                        if field_type_id >= 0 {
                            ast_expr_set_type(ast_base, get_index, field_type_id);
                        };
                    };
                };
            };
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, get_index, 0));

        resolved_cursor = skip_whitespace(base, len, field_cursor);
    };

    if (not_count & 1) != 0 {
        let value_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let value_index: i32 = expression_index_from_parts(ast_base, value_parts);
        if value_index < 0 {
            return -1;
        };
        let not_index: i32 = ast_expr_alloc_logical_not(ast_base, value_index);
        if not_index < 0 {
            return -1;
        };
        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, not_index, 0));
    };

    loop {
        resolved_cursor = skip_whitespace(base, len, resolved_cursor);
        let as_cursor: i32 = expect_keyword_as(base, len, resolved_cursor);
        if as_cursor < 0 {
            break;
        };
        let mut type_cursor: i32 = skip_whitespace(base, len, as_cursor);
        type_cursor = parse_type(base, len, type_cursor, ast_base, literal_ptr);
        if type_cursor < 0 {
            return -1;
        };
        let target_type_id: i32 = load_i32(literal_ptr);
        let value_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let value_index: i32 = expression_index_from_parts(ast_base, value_parts);
        if value_index < 0 {
            return -1;
        };
        let cast_index: i32 = ast_expr_alloc_cast(ast_base, value_index, target_type_id);
        if cast_index < 0 {
            return -1;
        };
        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, cast_index, 0));
        resolved_cursor = type_cursor;
    };

    skip_whitespace(base, len, resolved_cursor)
}

fn parse_multiplicative_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let literal_ptr: i32 = temp_base;
    let next_kind_ptr: i32 = temp_base + 4;
    let next_data0_ptr: i32 = temp_base + 8;
    let next_data1_ptr: i32 = temp_base + 12;
    let nested_temp_base: i32 = temp_base + 32;

    let mut current_cursor: i32 = parse_unary_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        literal_ptr,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
        nested_temp_base,
    );
    if current_cursor < 0 {
        return -1;
    };

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '*' && next_byte != '/' {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_unary_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            literal_ptr,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
            nested_temp_base,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == '*' {
            ast_expr_alloc_mul(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_div(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_additive_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let mut current_cursor: i32 = parse_multiplicative_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;
    let nested_temp_base: i32 = temp_base + 32;

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '+' && next_byte != '-' {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_multiplicative_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == '+' {
            ast_expr_alloc_add(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_sub(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_shift_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_additive_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        let second: i32 = load_u8(base + current_cursor + 1);
        let mut op_kind: i32 = -1;
        if first == '<' && second == '<' {
            op_kind = 0;
        } else if first == '>' && second == '>' {
            op_kind = 1;
        } else {
            break;
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_additive_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if op_kind == 0 {
            ast_expr_alloc_shl(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_shr_s(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_relational_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_shift_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        let mut relation_op: i32 = -1;
        let mut consume: i32 = 1;
        if operator_byte == '<' {
            if current_cursor + 1 < len {
                let next: i32 = load_u8(base + current_cursor + 1);
                if next == '=' {
                    relation_op = 2;
                    consume = 2;
                } else if next == '<' {
                    return -1;
                } else {
                    relation_op = 0;
                };
            } else {
                relation_op = 0;
            };
        } else if operator_byte == '>' {
            if current_cursor + 1 < len {
                let next: i32 = load_u8(base + current_cursor + 1);
                if next == '=' {
                    relation_op = 3;
                    consume = 2;
                } else if next == '>' {
                    return -1;
                } else {
                    relation_op = 1;
                };
            } else {
                relation_op = 1;
            };
        };

        if relation_op < 0 {
            break;
        };

        current_cursor = current_cursor + consume;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_additive_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if relation_op == 0 {
            ast_expr_alloc_lt(ast_base, left_index, right_index)
        } else if relation_op == 1 {
            ast_expr_alloc_gt(ast_base, left_index, right_index)
        } else if relation_op == 2 {
            ast_expr_alloc_le(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_ge(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_equality_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_relational_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        let next_byte: i32 = load_u8(base + current_cursor + 1);
        let mut equality_op: i32 = -1;
        if operator_byte == '=' {
            if next_byte != '=' {
                break;
            };
            equality_op = 0;
        } else if operator_byte == '!' {
            if next_byte != '=' {
                break;
            };
            equality_op = 1;
        } else {
            break;
        };

        current_cursor = current_cursor + 2;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_relational_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if equality_op == 0 {
            ast_expr_alloc_eq(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_ne(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_bitwise_and_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_equality_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        if operator_byte != '&' {
            break;
        };
        if current_cursor + 1 < len {
            let next: i32 = load_u8(base + current_cursor + 1);
            if next == '&' {
                break;
            };
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 1);
        current_cursor = parse_equality_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_bitwise_and(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_bitwise_or_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_bitwise_and_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        if operator_byte != '|' {
            break;
        };
        if current_cursor + 1 < len {
            let next: i32 = load_u8(base + current_cursor + 1);
            if next == '|' {
                break;
            };
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 1);
        current_cursor = parse_bitwise_and_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_bitwise_or(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_logical_and_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_bitwise_or_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        if first != '&' {
            break;
        };
        let second: i32 = load_u8(base + current_cursor + 1);
        if second != '&' {
            return -1;
        };
        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_bitwise_or_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_logical_and(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_logical_or_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_logical_and_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        if first != '|' {
            break;
        };
        let second: i32 = load_u8(base + current_cursor + 1);
        if second != '|' {
            return -1;
        };
        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_logical_and_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let left_parts: (i32, i32, i32) =
            load_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr);
        let left_index: i32 = expression_index_from_parts(ast_base, left_parts);
        if left_index < 0 {
            return -1;
        };

        let right_parts: (i32, i32, i32) =
            load_expression_parts(next_kind_ptr, next_data0_ptr, next_data1_ptr);
        let right_index: i32 = expression_index_from_parts(ast_base, right_parts);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_logical_or(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, (2, new_index, 0));
    };

    current_cursor
}

fn parse_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    parse_logical_or_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    )
}

fn parse_function(base: i32, len: i32, offset: i32, ast_base: i32, func_index: i32) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, offset);
    let mut is_const_fn: bool = false;
    let mut maybe_const: i32 = expect_keyword_const(base, len, cursor);
    if maybe_const >= 0 {
        if maybe_const >= len {
            return -1;
        };
        let after_const: i32 = load_u8(base + maybe_const);
        if !is_whitespace(after_const) {
            return -1;
        };
        is_const_fn = true;
        cursor = skip_whitespace(base, len, maybe_const);
    };
    cursor = expect_keyword_fn(base, len, cursor);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let params_count_ptr: i32 = temp_base;
    let params_table_ptr: i32 = temp_base + 4;
    let params_table_end: i32 = params_table_ptr + MAX_PARAMS * 8;
    let param_types_table_ptr: i32 = params_table_end;
    let param_type_temp_ptr: i32 = param_types_table_ptr + MAX_PARAMS * 4;
    let expr_kind_ptr: i32 = param_type_temp_ptr + 4;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_kind_ptr + 8;
    let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
    let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
    let locals_next_index_ptr: i32 = locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
    let expr_temp_base: i32 = locals_next_index_ptr + 4;
    let name_ident: (i32, i32, i32) = parse_identifier(base, len, cursor);
    cursor = name_ident.0;
    if cursor < 0 {
        return -1;
    };
    let name_start: i32 = name_ident.1;
    let name_len: i32 = name_ident.2;

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_start: i32 = load_i32(entry_ptr);
        let const_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, const_start, const_len, name_start, name_len) {
            return -1;
        };
        const_idx = const_idx + 1;
    };

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, '(');
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);
    store_i32(params_count_ptr, 0);
    let mut param_count: i32 = 0;
    loop {
        if cursor >= len {
            return -1;
        };
        let next_byte: i32 = load_u8(base + cursor);
        if next_byte == ')' {
            cursor = cursor + 1;
            break;
        };
        if param_count >= MAX_PARAMS {
            return -1;
        };
        let param_ident: (i32, i32, i32) = parse_identifier(base, len, cursor);
        cursor = param_ident.0;
        if cursor < 0 {
            return -1;
        };
        let param_start: i32 = param_ident.1;
        let param_len: i32 = param_ident.2;
        let mut existing_idx: i32 = 0;
        loop {
            if existing_idx >= param_count {
                break;
            };
            let existing_ptr: i32 = params_table_ptr + existing_idx * 8;
            let existing_start: i32 = load_i32(existing_ptr);
            let existing_len: i32 = load_i32(existing_ptr + 4);
            if identifiers_match_source(base, existing_start, existing_len, param_start, param_len) {
                return -1;
            };
            existing_idx = existing_idx + 1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ':');
        if cursor < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_type(base, len, cursor, ast_base, param_type_temp_ptr);
        if cursor < 0 {
            return -1;
        };
        let param_type_id: i32 = load_i32(param_type_temp_ptr);
        store_i32(params_table_ptr + param_count * 8, param_start);
        store_i32(params_table_ptr + param_count * 8 + 4, param_len);
        store_i32(param_types_table_ptr + param_count * 4, param_type_id);
        param_count = param_count + 1;
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            return -1;
        };
        let delimiter: i32 = load_u8(base + cursor);
        if delimiter == ',' {
            cursor = skip_whitespace(base, len, cursor + 1);
            if cursor >= len {
                return -1;
            };
            let maybe_close: i32 = load_u8(base + cursor);
            if maybe_close == ')' {
                cursor = cursor + 1;
                break;
            };
            continue;
        };
        if delimiter == ')' {
            cursor = cursor + 1;
            break;
        };
        return -1;
    };
    store_i32(params_count_ptr, param_count);
    store_i32(locals_stack_count_ptr, 0);
    store_i32(locals_next_index_ptr, 0);
    cursor = skip_whitespace(base, len, cursor);

    let mut block_allow_empty: i32 = 0;
    let mut has_return_type: bool = false;
    let mut return_type_id: i32 = -1;
    if cursor < len {
        let maybe_arrow: i32 = load_u8(base + cursor);
        if maybe_arrow == '-' {
            has_return_type = true;
            cursor = expect_char(base, len, cursor, '-');
            if cursor < 0 {
                return -1;
            };
            cursor = expect_char(base, len, cursor, '>');
            if cursor < 0 {
                return -1;
            };
            cursor = skip_whitespace(base, len, cursor);
            cursor = parse_type(base, len, cursor, ast_base, param_type_temp_ptr);
            if cursor < 0 {
                return -1;
            };
            return_type_id = load_i32(param_type_temp_ptr);
        };
    };
    if !has_return_type {
        block_allow_empty = 1;
        return_type_id = BUILTIN_TYPE_ID_I32;
    };

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, '{');
    if cursor < 0 {
        return -1;
    };

    let block_literal_ptr: i32 = expr_temp_base;
    let block_value_status_ptr: i32 = expr_temp_base + 12;
    let loop_depth_ptr: i32 = expr_temp_base + 16;
    let block_temp_base: i32 = expr_temp_base + 48;

    store_i32(loop_depth_ptr, 0);
    cursor = parse_block_expression_body(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        param_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        block_literal_ptr,
        block_temp_base,
        block_allow_empty,
        loop_depth_ptr,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
        block_value_status_ptr,
    );
    if cursor < 0 {
        return -1;
    };

    let name_ptr: i32 = ast_store_name(ast_base, base, name_start, name_len);
    if name_ptr < 0 {
        return -1;
    };
    let body_kind: i32 = load_i32(expr_kind_ptr);
    let body_data0: i32 = load_i32(expr_data0_ptr);
    if body_kind < 0 {
        return -1;
    };
    let locals_total: i32 = load_i32(locals_next_index_ptr);
    let mut param_types_ptr: i32 = -1;
    if param_count > 0 {
        param_types_ptr = ast_call_data_alloc(ast_base, param_count);
        if param_types_ptr < 0 {
            return -1;
        };
        let mut copy_idx: i32 = 0;
        loop {
            if copy_idx >= param_count {
                break;
            };
            let type_id: i32 = load_i32(param_types_table_ptr + copy_idx * 4);
            store_i32(param_types_ptr + copy_idx * 4, type_id);
            copy_idx = copy_idx + 1;
        };
    };
    let mut flags: i32 = 0;
    if is_const_fn {
        flags = FUNCTION_FLAG_CONST;
    };
    ast_write_function_entry(
        ast_base,
        func_index,
        name_ptr,
        name_len,
        param_count,
        body_kind,
        body_data0,
        locals_total,
        param_types_ptr,
        return_type_id,
        flags,
    );
    cursor
}

fn parse_type_declaration(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    func_count: i32,
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, cursor);
    let mut type_cursor: i32 = expect_keyword_type(base, len, idx);
    if type_cursor < 0 {
        return -2;
    };
    if type_cursor >= len {
        return -1;
    };
    let after_keyword: i32 = load_u8(base + type_cursor);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, type_cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let type_ptr: i32 = temp_base;

    let ident: (i32, i32, i32) = parse_identifier(base, len, idx);
    idx = ident.0;
    if idx < 0 {
        return -1;
    };
    let name_start: i32 = ident.1;
    let name_len: i32 = ident.2;

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };
    if find_constant_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };
    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let func_name_ptr: i32 = load_i32(entry_ptr);
        let func_name_len: i32 = load_i32(entry_ptr + 4);
        if func_name_len == name_len {
            let mut match_idx: i32 = 0;
            let mut matches: bool = true;
            loop {
                if match_idx >= name_len {
                    break;
                };
                let func_byte: i32 = load_u8(func_name_ptr + match_idx);
                let type_byte: i32 = load_u8(base + name_start + match_idx);
                if func_byte != type_byte {
                    matches = false;
                    break;
                };
                match_idx = match_idx + 1;
            };
            if matches {
                return -1;
            };
        };
        func_idx = func_idx + 1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, '=');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_type(base, len, idx, ast_base, type_ptr);
    if idx < 0 {
        return -1;
    };
    let target_type_id: i32 = load_i32(type_ptr);
    if target_type_id < 0 {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ';');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);

    let name_ptr: i32 = ast_store_name(ast_base, base, name_start, name_len);
    if name_ptr < 0 {
        return -1;
    };

    if ast_type_definition_append(ast_base, name_start, name_len, name_ptr, target_type_id) < 0 {
        return -1;
    };

    idx
}

fn evaluate_expression_literal(
    ast_base: i32,
    value_kind_ptr: i32,
    value_data0_ptr: i32,
    value_data1_ptr: i32,
    scratch_base: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
) -> i32 {
    let mut value_kind: i32 = load_i32(value_kind_ptr);
    if value_kind == 1 {
        let part_data0: i32 = load_i32(value_data0_ptr);
        let part_data1: i32 = load_i32(value_data1_ptr);
        let expr_index: i32 =
            expression_node_from_parts(ast_base, value_kind, part_data0, part_data1);
        if expr_index < 0 {
            return -1;
        };
        value_kind = 2;
        store_i32(value_kind_ptr, value_kind);
        store_i32(value_data0_ptr, expr_index);
        store_i32(value_data1_ptr, 0);
    };
    if value_kind == 0 {
        store_i32(out_value_ptr, load_i32(value_data0_ptr));
        store_i32(out_type_ptr, load_i32(value_data1_ptr));
        return 0;
    };
    if value_kind != 2 {
        return -1;
    };
    let expr_index: i32 = load_i32(value_data0_ptr);
    if expr_index < 0 {
        return -1;
    };
    let eval_value_ptr: i32 = scratch_base;
    let eval_type_ptr: i32 = eval_value_ptr + 4;
    let eval_stack_top_ptr: i32 = eval_type_ptr + 4;
    let eval_stack_base: i32 = eval_stack_top_ptr + 4;
    store_i32(eval_stack_top_ptr, 0);
    if interpret_constant_expression(
        ast_base,
        expr_index,
        eval_stack_base,
        eval_stack_top_ptr,
        eval_value_ptr,
        eval_type_ptr,
        0,
        0,
        0,
    ) < 0 {
        return -1;
    };
    store_i32(out_value_ptr, load_i32(eval_value_ptr));
    store_i32(out_type_ptr, load_i32(eval_type_ptr));
    0
}

fn parse_constant_declaration(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    func_count: i32,
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, cursor);
    let mut const_cursor: i32 = expect_keyword_const(base, len, idx);
    if const_cursor < 0 {
        return -2;
    };
    if const_cursor >= len {
        return -1;
    };
    let after_keyword: i32 = load_u8(base + const_cursor);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, const_cursor);

    let maybe_function: i32 = expect_keyword_fn(base, len, idx);
    if maybe_function >= 0 {
        return -2;
    };

    let temp_base: i32 = ast_temp_base(ast_base);
    let params_table_ptr: i32 = temp_base;
    let type_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
    let expr_kind_ptr: i32 = type_ptr + 4;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_kind_ptr + 8;
    let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
    let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
    let locals_next_index_ptr: i32 = locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
    let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
    let expr_temp_base: i32 = loop_depth_ptr + 4;

    store_i32(locals_stack_count_ptr, 0);
    store_i32(locals_next_index_ptr, 0);
    store_i32(loop_depth_ptr, 0);

    let ident: (i32, i32, i32) = parse_identifier(base, len, idx);
    idx = ident.0;
    if idx < 0 {
        return -1;
    };
    let name_start: i32 = ident.1;
    let name_len: i32 = ident.2;

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    if find_constant_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let func_name_ptr: i32 = load_i32(entry_ptr);
        let func_name_len: i32 = load_i32(entry_ptr + 4);
        if func_name_len == name_len {
            let mut match_idx: i32 = 0;
            let mut matches: bool = true;
            loop {
                if match_idx >= name_len {
                    break;
                };
                let func_byte: i32 = load_u8(func_name_ptr + match_idx);
                let const_byte: i32 = load_u8(base + name_start + match_idx);
                if func_byte != const_byte {
                    matches = false;
                    break;
                };
                match_idx = match_idx + 1;
            };
            if matches {
                return -1;
            };
        };
        func_idx = func_idx + 1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ':');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_type(base, len, idx, ast_base, type_ptr);
    if idx < 0 {
        return -1;
    };
    let type_id: i32 = load_i32(type_ptr);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, '=');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_expression(
        base,
        len,
        idx,
        ast_base,
        params_table_ptr,
        0,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        expr_temp_base,
        loop_depth_ptr,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
    );
    if idx < 0 {
        return -1;
    };
    let literal_value_ptr: i32 = expr_temp_base;
    let literal_type_ptr: i32 = literal_value_ptr + 4;
    let eval_scratch_base: i32 = literal_type_ptr + 4;
    if evaluate_expression_literal(
        ast_base,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
        eval_scratch_base,
        literal_value_ptr,
        literal_type_ptr,
    ) < 0 {
        return -1;
    };
    let mut literal_value: i32 = load_i32(literal_value_ptr);
    let mut literal_type: i32 = load_i32(literal_type_ptr);
    if literal_type == type_id {
        if type_id_is_integer(type_id) {
            literal_value = normalize_integer_value(literal_value, type_id);
        } else if type_id == BUILTIN_TYPE_ID_BOOL {
            literal_value = if literal_value != 0 { 1 } else { 0 };
        };
    } else if type_id_is_integer(literal_type) && type_id_is_integer(type_id) {
        literal_value = normalize_integer_value(literal_value, type_id);
    } else {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ';');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);

    let count_ptr: i32 = ast_constants_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_CONSTANTS_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, count);
    store_i32(entry_ptr, name_start);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, literal_value);
    store_i32(entry_ptr + 12, type_id);
    store_i32(count_ptr, count + 1);

    idx
}

fn parse_string_literal_to_buffer(
    base: i32,
    len: i32,
    cursor: i32,
    out_ptr: i32,
    out_capacity: i32,
    out_len_ptr: i32,
) -> i32 {
    if cursor >= len {
        return -1;
    };
    if out_capacity <= 0 {
        return -1;
    };
    let first: i32 = load_u8(base + cursor);
    if first != '"' {
        return -1;
    };
    let mut idx: i32 = cursor + 1;
    let mut out_len: i32 = 0;
    loop {
        if idx >= len {
            return -1;
        };
        let byte: i32 = load_u8(base + idx);
        if byte == '"' {
            idx = idx + 1;
            break;
        };
        let mut value: i32 = byte;
        idx = idx + 1;
        if value == '\\' {
            if idx >= len {
                return -1;
            };
            let escape: i32 = load_u8(base + idx);
            value = if escape == 'n' {
                '\n'
            } else if escape == 'r' {
                '\r'
            } else if escape == 't' {
                '\t'
            } else if escape == '0' {
                '\0'
            } else if escape == '\\' {
                '\\'
            } else if escape == '\'' {
                '\''
            } else if escape == 34 {
                34
            } else {
                return -1;
            };
            idx = idx + 1;
        } else if value == '\n' || value == '\r' {
            return -1;
        };
        if out_len >= out_capacity {
            return -1;
        };
        store_u8(out_ptr + out_len, value);
        out_len = out_len + 1;
    };
    store_i32(out_len_ptr, out_len);
    idx
}

fn module_resolve_import_path(
    current_module_index: i32,
    import_ptr: i32,
    import_len: i32,
    out_ptr: i32,
    out_capacity: i32,
    out_len_ptr: i32,
) -> i32 {
    if import_ptr <= 0 {
        return -1;
    };
    if import_len <= 0 {
        return -1;
    };
    if out_capacity <= 0 {
        return -1;
    };
    let first: i32 = load_u8(import_ptr);
    if first == '/' {
        if import_len > out_capacity {
            return -1;
        };
        copy_bytes(out_ptr, import_ptr, import_len);
        if load_u8(out_ptr + import_len - 1) == '/' {
            return -1;
        };
        store_i32(out_len_ptr, import_len);
        return 0;
    };
    if current_module_index < 0 {
        return -1;
    };
    let base_ptr: i32 = module_entry_path(current_module_index);
    let base_len: i32 = module_entry_path_len(current_module_index);
    if base_ptr <= 0 {
        return -1;
    };
    if base_len <= 0 {
        return -1;
    };
    let mut out_len: i32 = 0;
    let mut idx: i32 = 0;
    let mut last_slash: i32 = -1;
    loop {
        if idx >= base_len {
            break;
        };
        let byte: i32 = load_u8(base_ptr + idx);
        if byte == '/' {
            last_slash = idx;
        };
        idx = idx + 1;
    };
    if last_slash >= 0 {
        let dir_len: i32 = last_slash + 1;
        if dir_len > out_capacity {
            return -1;
        };
        copy_bytes(out_ptr, base_ptr, dir_len);
        out_len = dir_len;
    };
    let mut import_idx: i32 = 0;
    let mut last_segment_type: i32 = -1;
    loop {
        if import_idx >= import_len {
            break;
        };
        let segment_start: i32 = import_idx;
        loop {
            if import_idx >= import_len {
                break;
            };
            let byte: i32 = load_u8(import_ptr + import_idx);
            if byte == '/' {
                break;
            };
            if byte == '\\' {
                return -1;
            };
            import_idx = import_idx + 1;
        };
        let segment_len: i32 = import_idx - segment_start;
        if segment_len <= 0 {
            return -1;
        };
        let mut segment_type: i32 = 0;
        if segment_len == 1 {
            let ch: i32 = load_u8(import_ptr + segment_start);
            if ch == '.' {
                segment_type = 1;
            };
        } else if segment_len == 2 {
            let ch0: i32 = load_u8(import_ptr + segment_start);
            let ch1: i32 = load_u8(import_ptr + segment_start + 1);
            if ch0 == '.' && ch1 == '.' {
                segment_type = 2;
            };
        };
        if segment_type == 1 {
            // no-op for '.'
        } else if segment_type == 2 {
            if out_len <= 0 {
                return -1;
            };
            let mut new_len: i32 = out_len;
            if new_len > 0 {
                let last: i32 = load_u8(out_ptr + new_len - 1);
                if last == '/' {
                    new_len = new_len - 1;
                };
            };
            if new_len <= 0 {
                return -1;
            };
            let mut back_idx: i32 = new_len - 1;
            let mut found: bool = false;
            loop {
                if back_idx < 0 {
                    break;
                };
                let byte: i32 = load_u8(out_ptr + back_idx);
                if byte == '/' {
                    new_len = back_idx + 1;
                    found = true;
                    break;
                };
                back_idx = back_idx - 1;
            };
            if !found {
                new_len = 0;
            };
            out_len = new_len;
        } else {
            if out_len > 0 {
                let last: i32 = load_u8(out_ptr + out_len - 1);
                if last != '/' {
                    if out_len + 1 > out_capacity {
                        return -1;
                    };
                    store_u8(out_ptr + out_len, '/');
                    out_len = out_len + 1;
                };
            };
            if out_len + segment_len > out_capacity {
                return -1;
            };
            copy_bytes(out_ptr + out_len, import_ptr + segment_start, segment_len);
            out_len = out_len + segment_len;
        };
        last_segment_type = segment_type;
        if import_idx >= import_len {
            break;
        };
        let slash: i32 = load_u8(import_ptr + import_idx);
        if slash != '/' {
            return -1;
        };
        import_idx = import_idx + 1;
        if segment_type == 0 {
            if out_len >= out_capacity {
                return -1;
            };
            store_u8(out_ptr + out_len, '/');
            out_len = out_len + 1;
        };
    };
    if last_segment_type != 0 {
        return -1;
    };
    if out_len <= 0 {
        return -1;
    };
    if load_u8(out_ptr + out_len - 1) == '/' {
        return -1;
    };
    store_i32(out_len_ptr, out_len);
    0
}

fn parse_use_declaration(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    func_count: i32,
    current_module_index: i32,
) -> (i32, i32) {
    let mut idx: i32 = skip_whitespace(base, len, cursor);
    let mut use_cursor: i32 = expect_keyword_use(base, len, idx);
    if use_cursor < 0 {
        return (-2, func_count);
    };
    if current_module_index < 0 {
        return (-1, func_count);
    };
    if use_cursor < len {
        let after_keyword: i32 = load_u8(base + use_cursor);
        if after_keyword != '"' && !is_whitespace(after_keyword) {
            return (-1, func_count);
        };
    };
    idx = skip_whitespace(base, len, use_cursor);
    let temp_base: i32 = ast_temp_base(ast_base);
    let literal_ptr: i32 = temp_base;
    let literal_len_ptr: i32 = literal_ptr + MODULE_PATH_MAX_LENGTH;
    let literal_cursor: i32 = parse_string_literal_to_buffer(
        base,
        len,
        idx,
        literal_ptr,
        MODULE_PATH_MAX_LENGTH,
        literal_len_ptr,
    );
    if literal_cursor < 0 {
        return (-1, func_count);
    };
    let literal_len: i32 = load_i32(literal_len_ptr);
    if literal_len <= 0 {
        return (-1, func_count);
    };
    idx = skip_whitespace(base, len, literal_cursor);
    idx = expect_char(base, len, idx, ';');
    if idx < 0 {
        return (-1, func_count);
    };
    idx = skip_whitespace(base, len, idx);
    let resolved_ptr: i32 = literal_len_ptr + 4;
    let resolved_len_ptr: i32 = resolved_ptr + MODULE_PATH_MAX_LENGTH;
    if module_resolve_import_path(
        current_module_index,
        literal_ptr,
        literal_len,
        resolved_ptr,
        MODULE_PATH_MAX_LENGTH,
        resolved_len_ptr,
    ) < 0 {
        return (-1, func_count);
    };
    let resolved_len: i32 = load_i32(resolved_len_ptr);
    if resolved_len <= 0 {
        return (-1, func_count);
    };
    let import_index: i32 = module_find_index(resolved_ptr, resolved_len);
    if import_index < 0 {
        return (-1, func_count);
    };
    if import_index == current_module_index {
        return (-1, func_count);
    };
    let existing_flags: i32 = module_entry_flags(import_index);
    if (existing_flags & MODULE_FLAG_IMPORTING) != 0 {
        return (-1, func_count);
    };
    let mut new_count: i32 = func_count;
    if (existing_flags & MODULE_FLAG_IMPORTED) == 0 {
        module_entry_set_flags(import_index, existing_flags | MODULE_FLAG_IMPORTING);
        let import_base: i32 = module_entry_content(import_index);
        let import_len: i32 = module_entry_content_len(import_index);
        if import_base <= 0 || import_len <= 0 {
            module_entry_set_flags(import_index, existing_flags);
            return (-1, func_count);
        };
        new_count = parse_program(
            import_base,
            import_len,
            ast_base,
            func_count,
            import_index,
        );
        if new_count < 0 {
            module_entry_set_flags(import_index, existing_flags);
            return (-1, func_count);
        };
        let mut updated_flags: i32 = existing_flags | MODULE_FLAG_IMPORTED;
        if (updated_flags & MODULE_FLAG_IMPORTING) != 0 {
            updated_flags = updated_flags - MODULE_FLAG_IMPORTING;
        };
        module_entry_set_flags(import_index, updated_flags);
    } else {
        module_entry_set_flags(import_index, existing_flags);
    };
    (idx, new_count)
}

fn parse_program(
    base: i32,
    len: i32,
    ast_base: i32,
    initial_count: i32,
    current_module_index: i32,
) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, 0);
    let mut count: i32 = initial_count;
    store_i32(ast_functions_count_ptr(ast_base), count);
    loop {
        if cursor >= len {
            break;
        };
        let use_result: (i32, i32) =
            parse_use_declaration(base, len, cursor, ast_base, count, current_module_index);
        let use_cursor: i32 = use_result.0;
        if use_cursor == -1 {
            return -1;
        };
        if use_cursor >= 0 {
            count = use_result.1;
            store_i32(ast_functions_count_ptr(ast_base), count);
            cursor = skip_whitespace(base, len, use_cursor);
            continue;
        };
        let type_cursor: i32 = parse_type_declaration(base, len, cursor, ast_base, count);
        if type_cursor >= 0 {
            cursor = skip_whitespace(base, len, type_cursor);
            continue;
        };
        if type_cursor == -1 {
            return -1;
        };
        let const_cursor: i32 = parse_constant_declaration(base, len, cursor, ast_base, count);
        if const_cursor >= 0 {
            cursor = skip_whitespace(base, len, const_cursor);
            continue;
        };
        if const_cursor == -1 {
            return -1;
        };
        if count >= AST_MAX_FUNCTIONS {
            return -1;
        };
        cursor = parse_function(base, len, cursor, ast_base, count);
        if cursor < 0 {
            return -1;
        };
        count = count + 1;
        store_i32(ast_functions_count_ptr(ast_base), count);
        cursor = skip_whitespace(base, len, cursor);
    };
    store_i32(ast_functions_count_ptr(ast_base), count);
    count
}

fn identifiers_match(ptr_a: i32, len_a: i32, ptr_b: i32, len_b: i32) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(ptr_a + idx);
        let b_byte: i32 = load_u8(ptr_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn resolve_call_metadata(
    out_ptr: i32,
    ast_base: i32,
    metadata_ptr: i32,
    func_count: i32,
    caller_is_const: bool,
) -> i32 {
    if metadata_ptr < 0 {
        return -1;
    };
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        };
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
        if resolve_expression(out_ptr, ast_base, arg_expr_index, func_count, caller_is_const) < 0 {
            return -1;
        };
        arg_idx = arg_idx + 1;
    };

    let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
    let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
    let mut target_idx: i32 = 0;
    let mut found_idx: i32 = -1;
    loop {
        if target_idx >= func_count {
            break;
        };
        let target_entry_ptr: i32 = ast_function_entry_ptr(ast_base, target_idx);
        let target_name_ptr: i32 = load_i32(target_entry_ptr);
        let target_name_len: i32 = load_i32(target_entry_ptr + 4);
        if call_name_len == target_name_len {
            if identifiers_match(call_name_ptr, call_name_len, target_name_ptr, target_name_len) {
                let expected_params: i32 = load_i32(target_entry_ptr + 8);
                if expected_params != arg_count {
                    return -1;
                };
                let param_types_ptr: i32 = load_i32(target_entry_ptr + 24);
                if arg_count > 0 {
                    if param_types_ptr < 0 {
                        return -1;
                    };
                };
                if caller_is_const {
                    if !ast_function_is_const(ast_base, target_idx) {
                        return -1;
                    };
                };
                let mut verify_idx: i32 = 0;
                loop {
                    if verify_idx >= arg_count {
                        break;
                    };
                    let expected_type: i32 = if param_types_ptr >= 0 {
                        load_i32(param_types_ptr + verify_idx * 4)
                    } else {
                        -1
                    };
                    if expected_type < 0 {
                        return -1;
                    };
                    let resolved_expected: i32 =
                        resolve_type_id(out_ptr, ast_base, expected_type);
                    if resolved_expected < 0 {
                        return -1;
                    };
                    if param_types_ptr >= 0 {
                        store_i32(param_types_ptr + verify_idx * 4, resolved_expected);
                    };
                    let arg_expr_index: i32 = load_i32(args_base + verify_idx * 4);
                    let arg_type: i32 = ast_expr_type(ast_base, arg_expr_index);
                    if arg_type < 0 {
                        return -1;
                    };
                    let resolved_arg: i32 =
                        resolve_type_id(out_ptr, ast_base, arg_type);
                    if resolved_arg < 0 {
                        return -1;
                    };
                    ast_expr_set_type(ast_base, arg_expr_index, resolved_arg);
                    if resolved_expected != resolved_arg {
                        return -1;
                    };
                    verify_idx = verify_idx + 1;
                };
                found_idx = target_idx;
                break;
            };
        };
        target_idx = target_idx + 1;
    };
    if found_idx < 0 {
        return -1;
    };
    store_i32(call_metadata_callee_index_ptr(metadata_ptr), found_idx);
    0
}

fn validate_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    if func_count <= 0 {
        return -1;
    };
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_type_ptr: i32 = const_entry_ptr + 12;
        let const_type_id: i32 = load_i32(const_type_ptr);
        let resolved_const_type: i32 = resolve_type_id(out_ptr, ast_base, const_type_id);
        if resolved_const_type < 0 {
            return -1;
        };
        if resolved_const_type != const_type_id {
            store_i32(const_type_ptr, resolved_const_type);
        };
        const_idx = const_idx + 1;
    };
    let mut main_count: i32 = 0;
    let main_name_ptr: i32 = ast_temp_base(ast_base);
    store_u8(main_name_ptr + 0, 'm');
    store_u8(main_name_ptr + 1, 'a');
    store_u8(main_name_ptr + 2, 'i');
    store_u8(main_name_ptr + 3, 'n');
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let caller_is_const: bool = ast_function_is_const(ast_base, idx);
        store_u8(main_name_ptr + 0, 'm');
        store_u8(main_name_ptr + 1, 'a');
        store_u8(main_name_ptr + 2, 'i');
        store_u8(main_name_ptr + 3, 'n');
        if name_len == 4 {
            if identifiers_match(name_ptr, name_len, main_name_ptr, 4) {
                main_count = main_count + 1;
                if param_count != 0 {
                    return -1;
                };
            };
        };
        let mut other_idx: i32 = idx + 1;
        loop {
            if other_idx >= func_count {
                break;
            };
            let other_entry_ptr: i32 = ast_function_entry_ptr(ast_base, other_idx);
            let other_name_ptr: i32 = load_i32(other_entry_ptr);
            let other_name_len: i32 = load_i32(other_entry_ptr + 4);
            if name_len == other_name_len {
                if identifiers_match(name_ptr, name_len, other_name_ptr, other_name_len) {
                    return -1;
                };
            };
            other_idx = other_idx + 1;
        };

        if param_count > 0 {
            let param_types_ptr: i32 = load_i32(entry_ptr + 24);
            if param_types_ptr < 0 {
                return -1;
            };
            let mut param_idx: i32 = 0;
            loop {
                if param_idx >= param_count {
                    break;
                };
                let param_type_ptr: i32 = param_types_ptr + param_idx * 4;
                let param_type_id: i32 = load_i32(param_type_ptr);
                let resolved_param_type: i32 =
                    resolve_type_id(out_ptr, ast_base, param_type_id);
                if resolved_param_type < 0 {
                    return -1;
                };
                if resolved_param_type != param_type_id {
                    store_i32(param_type_ptr, resolved_param_type);
                };
                param_idx = param_idx + 1;
            };
        };
        let mut fn_return_type: i32 = load_i32(entry_ptr + 28);
        if fn_return_type >= 0 {
            let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, fn_return_type);
            if resolved_return < 0 {
                return -1;
            };
            if resolved_return != fn_return_type {
                store_i32(entry_ptr + 28, resolved_return);
                fn_return_type = resolved_return;
            };
        };

        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if resolve_call_metadata(out_ptr, ast_base, metadata_ptr, func_count, caller_is_const) < 0 {
                return -1;
            };
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if resolve_expression(out_ptr, ast_base, expr_index, func_count, caller_is_const) < 0 {
                return -1;
            };
            if fn_return_type >= 0 {
                let expr_type: i32 = ast_expr_type(ast_base, expr_index);
                let expect_array: bool = type_id_is_array(fn_return_type);
                let expr_is_array: bool = expr_type >= 0 && type_id_is_array(expr_type);
                if expect_array || expr_is_array {
                    if expr_type >= 0 {
                        if expr_type != fn_return_type {
                            return -1;
                        };
                    } else if !expression_guaranteed_diverges(ast_base, expr_index) {
                        return -1;
                    };
                };
            };
        };
        idx = idx + 1;
    };
    if main_count != 1 {
        return -1;
    };
    0
}

const RESOLVE_CONTROL_STACK_CAPACITY: i32 = 128;

const RESOLVE_LOOP_STACK_CAPACITY: i32 = 64;

fn resolve_expression_internal(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    loop_stack_base: i32,
    loop_stack_count_ptr: i32,
    caller_is_const: bool,
) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        if resolve_call_metadata(out_ptr, ast_base, metadata_ptr, func_count, caller_is_const) < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, callee_index);
        let mut return_type_id: i32 = load_i32(callee_entry_ptr + 28);
        if return_type_id >= 0 {
            let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, return_type_id);
            if resolved_return < 0 {
                return -1;
            };
            return_type_id = resolved_return;
        };
        ast_expr_set_type(ast_base, expr_index, return_type_id);
        return 0;
    };
    if kind == 6 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            };
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
            };
        };
        return 0;
    };
    if kind == 8 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            };
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
            };
        };
        return 0;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            element_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let element_type: i32 = ast_expr_type(ast_base, element_index);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        if resolved_element != element_type {
            ast_expr_set_type(ast_base, element_index, resolved_element);
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, resolved_element, length);
        if array_type_id < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut element_type: i32 = -1;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                element_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                caller_is_const,
            ) < 0 {
                return -1;
            };
            let current_type: i32 = ast_expr_type(ast_base, element_index);
            if current_type < 0 {
                return -1;
            };
            let resolved_current: i32 = resolve_type_id(out_ptr, ast_base, current_type);
            if resolved_current < 0 {
                return -1;
            };
            if resolved_current != current_type {
                ast_expr_set_type(ast_base, element_index, resolved_current);
            };
            if element_type < 0 {
                element_type = resolved_current;
            } else if resolved_current != element_type {
                return -1;
            };
            idx = idx + 1;
        };
        if element_type < 0 {
            return -1;
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, element_type, element_count);
        if array_type_id < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            index_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        };
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        };
        if !type_id_is_array(resolved_array_type) {
            return -1;
        };
        let index_type: i32 = ast_expr_type(ast_base, index_index);
        if index_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        let element_type: i32 = array_type_element_type(ast_base, resolved_array_type);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        };
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        };
        if !type_id_is_array(resolved_array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, resolved_array_type);
        if length < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
        return 0;
    };
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            tuple_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if tuple_type < 0 {
            return -1;
        };
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type);
        if resolved_tuple < 0 {
            return -1;
        };
        if resolved_tuple != tuple_type {
            ast_expr_set_type(ast_base, tuple_index, resolved_tuple);
        };
        if !type_id_is_tuple(resolved_tuple) {
            return -1;
        };
        let tuple_idx: i32 = tuple_type_index(resolved_tuple);
        if tuple_idx < 0 {
            return -1;
        };
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            return -1;
        };
        if ensure_tuple_type_metadata(out_ptr, ast_base, tuple_idx, resolved_tuple) < 0 {
            return -1;
        };
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count <= field_index {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return -1;
        };
        let element_type_ptr: i32 = elements_ptr + field_index * WORD_SIZE;
        let element_type: i32 = load_i32(element_type_ptr);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        if resolved_element != element_type {
            store_i32(element_type_ptr, resolved_element);
        };
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    };
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        if element_count == 0 {
            let tuple_type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
            if tuple_type_id < 0 {
                return -1;
            };
            let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
            if resolved_tuple < 0 {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, resolved_tuple);
            return 0;
        };
        if values_ptr < 0 {
            return -1;
        };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let elements_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if elements_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                caller_is_const,
            ) < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let element_type: i32 = ast_expr_type(ast_base, value_index);
            if element_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
            if resolved_element < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            if resolved_element != element_type {
                ast_expr_set_type(ast_base, value_index, resolved_element);
            };
            store_i32(elements_ptr + idx * WORD_SIZE, resolved_element);
            idx = idx + 1;
        };
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let tuple_type_id: i32 =
            ast_register_tuple_type(ast_base, elements_ptr, element_count);
        if tuple_type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        };
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
        if resolved_tuple < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_tuple);
        return 0;
    };
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + 4);
        let byte_count: i32 = load_i32(entry_ptr + 8);
        if byte_count < 0 {
            return -1;
        };
        if byte_count > 0 && bytes_ptr < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        return 0;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if type_id_is_array(value_type) {
            return -1;
        };
        return 0;
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let resolved_target: i32 = resolve_type_id(out_ptr, ast_base, target_type);
        if resolved_target < 0 {
            return -1;
        };
        if !type_id_is_integer(resolved_target) {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type < 0 {
            return -1;
        };
        let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
        if resolved_value < 0 {
            return -1;
        };
        if !type_id_is_integer(resolved_value) {
            return -1;
        };
        if resolved_value != value_type {
            ast_expr_set_type(ast_base, value_index, resolved_value);
        };
        ast_expr_set_type(ast_base, expr_index, resolved_target);
        return 0;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            left_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            right_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let left_type: i32 = ast_expr_type(ast_base, left_index);
        let right_type: i32 = ast_expr_type(ast_base, right_index);
        if left_type < 0 {
            return -1;
        };
        if right_type < 0 {
            return -1;
        };
        let resolved_left: i32 = resolve_type_id(out_ptr, ast_base, left_type);
        if resolved_left < 0 {
            return -1;
        };
        if resolved_left != left_type {
            ast_expr_set_type(ast_base, left_index, resolved_left);
        };
        let resolved_right: i32 = resolve_type_id(out_ptr, ast_base, right_type);
        if resolved_right < 0 {
            return -1;
        };
        if resolved_right != right_type {
            ast_expr_set_type(ast_base, right_index, resolved_right);
        };
        if kind == 20 || kind == 21 {
            if !type_id_is_bool(resolved_left) {
                return -1;
            };
            if !type_id_is_bool(resolved_right) {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if kind == 14
            || kind == 15
            || kind == 16
            || kind == 17
            || kind == 18
            || kind == 19
        {
            if !type_id_is_integer(resolved_left) {
                return -1;
            };
            if !type_id_is_integer(resolved_right) {
                return -1;
            };
            if resolved_left != resolved_right {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if !type_id_is_integer(resolved_left) {
            return -1;
        };
        if !type_id_is_integer(resolved_right) {
            return -1;
        };
        if resolved_left != resolved_right {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_left);
        return 0;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if !type_id_is_bool(value_type) {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
        return 0;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
        return 0;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            condition_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let control_count: i32 = load_i32(control_stack_count_ptr);
        if control_count >= RESOLVE_CONTROL_STACK_CAPACITY {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            else_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        store_i32(control_stack_count_ptr, control_count);
        let condition_type: i32 = ast_expr_type(ast_base, condition_index);
        if !type_id_is_bool(condition_type) {
            if !type_id_is_integer(condition_type) {
                return -1;
            };
        };
        let then_type: i32 = ast_expr_type(ast_base, then_index);
        let else_type: i32 = ast_expr_type(ast_base, else_index);
        if then_type != else_type {
            let then_diverges: bool = expression_guaranteed_diverges(ast_base, then_index);
            let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
            if then_diverges && !else_diverges {
                ast_expr_set_type(ast_base, expr_index, else_type);
                return 0;
            };
            if else_diverges && !then_diverges {
                ast_expr_set_type(ast_base, expr_index, then_type);
                return 0;
            };
            if then_diverges && else_diverges {
                return 0;
            };
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, then_type);
        return 0;
    };
    if kind == 9 {
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            init_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
        return 0;
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            first_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, then_index));
        return 0;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
        if control_count + 2 > control_capacity {
            return -1;
        };
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        let loop_capacity: i32 = RESOLVE_LOOP_STACK_CAPACITY;
        if loop_count >= loop_capacity {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        store_i32(control_stack_base + (control_count + 1) * 4, 1);
        store_i32(control_stack_count_ptr, control_count + 2);
        store_i32(loop_stack_base + loop_count * 4, control_count);
        store_i32(loop_stack_count_ptr, loop_count + 1);
        let body_result: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            caller_is_const,
        );
        store_i32(loop_stack_count_ptr, loop_count);
        store_i32(control_stack_count_ptr, control_count);
        if body_result < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 13 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - target_index;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            if resolve_expression_internal(out_ptr, ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                caller_is_const,
            ) < 0 {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
            return 0;
        };
        ast_expr_set_type(ast_base, expr_index, -1);
        return 0;
    };
    if kind == 24 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let continue_target: i32 = target_index + 1;
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - continue_target;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        return 0;
    };
    -1
}

fn resolve_expression(out_ptr: i32, ast_base: i32, expr_index: i32, func_count: i32, caller_is_const: bool) -> i32 {
    let temp_base: i32 = ast_temp_base(ast_base);
    let control_count_ptr: i32 = temp_base;
    let loop_count_ptr: i32 = temp_base + 4;
    let control_stack_base: i32 = temp_base + 8;
    let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
    let loop_stack_base: i32 = control_stack_base + control_capacity * 4;
    let saved_control_count: i32 = load_i32(control_count_ptr);
    let saved_loop_count: i32 = load_i32(loop_count_ptr);
    store_i32(control_count_ptr, 0);
    store_i32(loop_count_ptr, 0);
    let result: i32 = resolve_expression_internal(
        out_ptr,
        ast_base,
        expr_index,
        func_count,
        control_stack_base,
        control_count_ptr,
        loop_stack_base,
        loop_count_ptr,
        caller_is_const,
    );
    store_i32(control_count_ptr, saved_control_count);
    store_i32(loop_count_ptr, saved_loop_count);
    result
}


const COMPILER_MEMORY_PAGES: i32 = 64;

fn initialize_layout(out_ptr: i32) {
    store_i32(scratch_instr_offset_ptr(out_ptr), 0);
    store_i32(scratch_expr_type_ptr(out_ptr), -1);
    store_i32(scratch_fn_count_ptr(out_ptr), 0);
    store_i32(scratch_types_count_ptr(out_ptr), 0);
}

fn compile_impl(
    input_ptr: i32,
    input_len: i32,
    out_ptr: i32,
    current_module_index: i32,
) -> i32 {
    if input_len <= 0 {
        return -1;
    };

    initialize_layout(out_ptr);
    let ast_base: i32 = ast_program_base(out_ptr, input_len);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(
        input_ptr,
        input_len,
        ast_base,
        0,
        current_module_index,
    );
    if func_count <= 0 {
        return -1;
    };
    if validate_program(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };

    if write_type_metadata(out_ptr, ast_base) < 0 {
        return -1;
    };

    let produced_len: i32 = emit_program(out_ptr, ast_base, func_count);
    if produced_len <= 0 {
        return -1;
    };
    produced_len
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    compile_impl(input_ptr, input_len, out_ptr, -1)
}

fn loadModuleFromSource(path_ptr: i32, content_ptr: i32) -> i32 {
    if path_ptr <= 0 || content_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        return -1;
    };
    let content_len: i32 = string_length(content_ptr);
    if content_len < 0 {
        return -1;
    };
    let existing_index: i32 = module_find_index(path_ptr, path_len);
    let mut stored_path_ptr: i32 = 0;
    if existing_index >= 0 {
        stored_path_ptr = module_entry_path(existing_index);
    } else {
        if module_count() >= MODULE_MAX_COUNT {
            return -1;
        };
        let allocated_path_ptr: i32 = module_allocate_bytes(path_len + 1);
        if allocated_path_ptr <= 0 {
            return -1;
        };
        copy_bytes(allocated_path_ptr, path_ptr, path_len);
        store_u8(allocated_path_ptr + path_len, 0);
        stored_path_ptr = allocated_path_ptr;
    };
    let allocated_content_ptr: i32 = module_allocate_bytes(content_len + 1);
    if allocated_content_ptr <= 0 {
        return -1;
    };
    copy_bytes(allocated_content_ptr, content_ptr, content_len);
    store_u8(allocated_content_ptr + content_len, 0);
    let mut store_index: i32 = existing_index;
    if store_index < 0 {
        store_index = module_count();
        module_set_count(store_index + 1);
    };
    module_write_entry(store_index, stored_path_ptr, path_len, allocated_content_ptr, content_len);
    0
}

fn compileFromPath(path_ptr: i32) -> i32 {
    if path_ptr <= 0 {
        return -1;
    };
    module_ensure_state_initialized();
    let path_len: i32 = string_length(path_ptr);
    if path_len <= 0 {
        return -1;
    };
    let index: i32 = module_find_index(path_ptr, path_len);
    if index < 0 {
        return -1;
    };
    module_clear_flags();
    module_entry_set_flags(index, MODULE_FLAG_IMPORTING);
    let input_ptr: i32 = module_entry_content(index);
    let input_len: i32 = module_entry_content_len(index);
    if input_ptr <= 0 || input_len <= 0 {
        return -1;
    };
    let mut out_ptr: i32 = module_storage_top();
    if out_ptr <= 0 {
        module_ensure_state_initialized();
        out_ptr = module_storage_top();
    };
    out_ptr = align_to(out_ptr, WORD_SIZE);
    module_set_storage_top(out_ptr);
    let required: i32 = out_ptr + ast_output_reserve(input_len);
    if ensure_memory_capacity(required) < 0 {
        return -1;
    };
    let status: i32 = compile_impl(input_ptr, input_len, out_ptr, index);
    if status > 0 {
        module_entry_set_flags(index, MODULE_FLAG_IMPORTED);
    } else {
        module_entry_set_flags(index, 0);
    };
    status
}

fn main() -> i32 {
    0
}
