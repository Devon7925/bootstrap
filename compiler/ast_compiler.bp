fn write_byte(base: i32, offset: i32, value: i32) -> i32 {
    store_u8(base + offset, value & 255);
    offset + 1
}

fn write_u32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let mut byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        if remaining != 0 {
            byte = byte | 128;
        };
        out = write_byte(base, out, byte);
        if remaining == 0 {
            break;
        };
    };
    out
}

fn write_i32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        let mut out_byte: i32 = byte;
        if !done {
            out_byte = out_byte | 128;
        };
        out = write_byte(base, out, out_byte);
        if done {
            break;
        };
    };
    out
}

fn leb_u32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        count = count + 1;
        remaining = remaining >> 7;
        if remaining == 0 {
            break;
        };
    };
    count
}

fn leb_i32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        count = count + 1;
        if done {
            break;
        };
    };
    count
}

fn write_magic(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, '\0');
    out = write_byte(base, out, 'a');
    out = write_byte(base, out, 's');
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out
}

fn is_whitespace(byte: i32) -> bool {
    byte == ' ' || byte == '\t' || byte == '\n' || byte == '\r'
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if byte == '/' {
            if idx + 1 < len {
                let next: i32 = load_u8(base + idx + 1);
                if next == '/' {
                    idx = idx + 2;
                    loop {
                        if idx >= len {
                            break;
                        };
                        let comment_byte: i32 = load_u8(base + idx);
                        if comment_byte == '\n' {
                            idx = idx + 1;
                            break;
                        };
                        idx = idx + 1;
                    };
                    continue;
                };
            };
        };
        if !is_whitespace(byte) {
            break;
        };
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    };
    offset + 1
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 'A' && byte <= 'Z') || (byte >= 'a' && byte <= 'z') || byte == '_'
}

fn is_digit(byte: i32) -> bool {
    byte >= '0' && byte <= '9'
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || is_digit(byte)
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "fn\0\0\0\0\0\0\0\0")
}

fn expect_keyword_type(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "type\0\0\0\0\0\0")
}

fn expect_keyword_if(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "if\0\0\0\0\0\0\0\0")
}

fn expect_keyword_as(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "as\0\0\0\0\0\0\0\0")
}

fn expect_keyword_true(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "true\0\0\0\0\0\0")
}

fn expect_keyword_false(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "false\0\0\0\0\0")
}

fn expect_keyword_else(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "else\0\0\0\0\0\0")
}

fn expect_keyword_loop(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "loop\0\0\0\0\0\0")
}

fn expect_keyword_break(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "break\0\0\0\0\0")
}

fn expect_keyword_continue(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "continue\0\0")
}

fn expect_keyword_return(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "return\0\0\0\0")
}

fn parse_identifier(base: i32, len: i32, offset: i32, out_start_ptr: i32, out_len_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let first: i32 = load_u8(base + offset);
    if !is_identifier_start(first) {
        return -1;
    };
    let mut idx: i32 = offset + 1;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_identifier_continue(byte) {
            break;
        };
        idx = idx + 1;
    };
    store_i32(out_start_ptr, offset);
    store_i32(out_len_ptr, idx - offset);
    idx
}

const MAX_PARAMS: i32 = 64;

const MAX_ARRAY_LITERAL_ELEMENTS: i32 = 256;

const INTRINSIC_KIND_NONE: i32 = -1;

const INTRINSIC_KIND_LOAD_U8: i32 = 0;

const INTRINSIC_KIND_STORE_U8: i32 = 1;

const INTRINSIC_KIND_LOAD_I32: i32 = 2;

const INTRINSIC_KIND_STORE_I32: i32 = 3;

const INTRINSIC_KIND_LOAD_U16: i32 = 4;

const INTRINSIC_KIND_STORE_U16: i32 = 5;

const INTRINSIC_KIND_LEN: i32 = 6;

fn padded_string_len(keyword: [u8; 10]) -> i32 {
    let capacity: i32 = len(keyword);
    let mut length: i32 = 0;
    loop {
        if length >= capacity {
            break;
        };
        let value: i32 = keyword[length] as i32;
        if value == 0 {
            break;
        };
        length = length + 1;
    };
    length
}

fn identifier_matches_keyword(
    base: i32,
    source_len: i32,
    start: i32,
    ident_len: i32,
    keyword: [u8; 10],
) -> bool {
    if start < 0 || start + ident_len > source_len {
        return false;
    };
    let keyword_len: i32 = padded_string_len(keyword);
    if keyword_len <= 0 {
        return false;
    };
    if ident_len != keyword_len {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= keyword_len {
            break;
        };
        if load_u8(base + start + idx) != keyword[idx] as i32 {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn expect_keyword_literal(base: i32, len: i32, offset: i32, keyword: [u8; 10]) -> i32 {
    let keyword_len: i32 = padded_string_len(keyword);
    if keyword_len <= 0 {
        return -1;
    };
    if offset < 0 || offset + keyword_len > len {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= keyword_len {
            break;
        };
        if load_u8(base + offset + idx) != keyword[idx] as i32 {
            return -1;
        };
        idx = idx + 1;
    };
    let next: i32 = offset + keyword_len;
    if next < len {
        let after: i32 = load_u8(base + next);
        if is_identifier_continue(after) {
            return -1;
        };
    };
    next
}

fn identify_intrinsic(base: i32, len: i32, start: i32, ident_len: i32) -> i32 {
    let names: [[u8; 10]; 7] = [
        "load_u8\0\0\0",
        "store_u8\0\0",
        "load_i32\0\0",
        "store_i32\0",
        "load_u16\0\0",
        "store_u16\0",
        "len\0\0\0\0\0\0\0",
    ];
    let kinds: [i32; 7] = [
        INTRINSIC_KIND_LOAD_U8,
        INTRINSIC_KIND_STORE_U8,
        INTRINSIC_KIND_LOAD_I32,
        INTRINSIC_KIND_STORE_I32,
        INTRINSIC_KIND_LOAD_U16,
        INTRINSIC_KIND_STORE_U16,
        INTRINSIC_KIND_LEN,
    ];
    let mut idx: i32 = 0;
    let count: i32 = len(kinds);
    loop {
        if idx >= count {
            break;
        };
        if identifier_matches_keyword(base, len, start, ident_len, names[idx]) {
            return kinds[idx];
        };
        idx = idx + 1;
    };
    INTRINSIC_KIND_NONE
}

fn identifiers_match_source(
    base: i32,
    start_a: i32,
    len_a: i32,
    start_b: i32,
    len_b: i32,
) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(base + start_a + idx);
        let b_byte: i32 = load_u8(base + start_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn find_parameter_index(
    base: i32,
    params_table_ptr: i32,
    params_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let mut idx: i32 = 0;
    loop {
        if idx >= params_count {
            break;
        };
        let entry_ptr: i32 = params_table_ptr + idx * 8;
        let param_start: i32 = load_i32(entry_ptr);
        let param_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, param_start, param_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn expect_keyword_const(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "const\0\0\0\0\0")
}

fn expect_keyword_let(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, "let\0\0\0\0\0\0\0")
}

const MAX_LOCALS: i32 = 512;

const LOCALS_ENTRY_SIZE: i32 = 20;

fn locals_entry_ptr(locals_table_ptr: i32, index: i32) -> i32 {
    locals_table_ptr + index * LOCALS_ENTRY_SIZE
}

fn find_local_entry_index(
    base: i32,
    locals_table_ptr: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= 0 {
        return -1;
    };
    let mut idx: i32 = locals_stack_count - 1;
    loop {
        if idx < 0 {
            break;
        };
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx - 1;
    };
    -1
}

fn find_local_entry_index_in_scope(
    base: i32,
    locals_table_ptr: i32,
    scope_start: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= scope_start {
        return -1;
    };
    let mut idx: i32 = locals_stack_count - 1;
    loop {
        if idx < scope_start {
            break;
        };
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx - 1;
    };
    -1
}

fn locals_entry_local_index(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 8)
}

fn locals_entry_type_id(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 12)
}

fn locals_entry_is_mut(entry_ptr: i32) -> bool {
    load_i32(entry_ptr + 16) != 0
}

fn find_constant_entry_index(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let count: i32 = ast_constants_count(ast_base);
    if count <= 0 {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, idx);
        let const_start: i32 = load_i32(entry_ptr);
        let const_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, const_start, const_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn expression_guaranteed_diverges(ast_base: i32, expr_index: i32) -> bool {
    if expr_index < 0 {
        return false;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return false;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 13 {
        return true;
    };
    if kind == 24 {
        return true;
    };
    if kind == 23 {
        return true;
    };
    if kind == 11 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        return expression_guaranteed_diverges(ast_base, then_index);
    };
    if kind == 9 {
        let body_index: i32 = load_i32(entry_ptr + 12);
        return expression_guaranteed_diverges(ast_base, body_index);
    };
    if kind == 7 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if !expression_guaranteed_diverges(ast_base, then_index) {
            return false;
        };
        if !expression_guaranteed_diverges(ast_base, else_index) {
            return false;
        };
        return true;
    };
    false
}

const BLOCK_STATEMENT_ENTRY_SIZE: i32 = 12;

const BLOCK_STATEMENTS_CAPACITY: i32 = 512;

fn parse_block_expression_body(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    ident_start_ptr: i32,
    ident_len_ptr: i32,
    temp_base: i32,
    allow_empty_final_expr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    out_value_status_ptr: i32,
) -> i32 {
    let saved_stack_count: i32 = load_i32(locals_stack_count_ptr);
    let saved_next_index: i32 = load_i32(locals_next_index_ptr);
    let mut idx: i32 = skip_whitespace(base, len, cursor);

    let statement_count_ptr: i32 = temp_base;
    store_i32(statement_count_ptr, 0);
    let statements_base: i32 = statement_count_ptr + 4;
    let statements_capacity: i32 = BLOCK_STATEMENTS_CAPACITY;
    let statement_entry_size: i32 = BLOCK_STATEMENT_ENTRY_SIZE;
    let statements_end: i32 = statements_base + statements_capacity * statement_entry_size;
    let stmt_expr_kind_ptr: i32 = statements_end;
    let stmt_expr_data0_ptr: i32 = stmt_expr_kind_ptr + 4;
    let stmt_expr_data1_ptr: i32 = stmt_expr_kind_ptr + 8;
    let stmt_expr_value_status_ptr: i32 = stmt_expr_kind_ptr + 12;
    let stmt_local_type_ptr: i32 = stmt_expr_value_status_ptr + 4;
    let stmt_nested_temp_base: i32 = stmt_expr_kind_ptr + 64;

    let allow_empty_value: bool = allow_empty_final_expr != 0;
    let mut have_value_expr: bool = false;
    let mut final_kind: i32 = -1;
    let mut final_data0: i32 = 0;
    let mut final_data1: i32 = 0;
    store_i32(out_value_status_ptr, 0);

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };
        let next_byte: i32 = load_u8(base + idx);
        if next_byte == '}' {
            if !have_value_expr {
                if allow_empty_value {
                    have_value_expr = true;
                    final_kind = 0;
                    final_data0 = 0;
                    final_data1 = 0;
                } else {
                    let stmt_count: i32 = load_i32(statement_count_ptr);
                    let mut diverges: bool = false;
                    if stmt_count > 0 {
                        let last_ptr: i32 =
                            statements_base + (stmt_count - 1) * statement_entry_size;
                        let last_kind: i32 = load_i32(last_ptr);
                        if last_kind == 1 {
                            let last_expr_index: i32 = load_i32(last_ptr + 4);
                            if expression_guaranteed_diverges(ast_base, last_expr_index) {
                                diverges = true;
                            };
                        };
                    };
                    if diverges {
                        have_value_expr = true;
                        final_kind = 0;
                        final_data0 = 0;
                        final_data1 = 0;
                    } else {
                        store_i32(locals_stack_count_ptr, saved_stack_count);
                        store_i32(locals_next_index_ptr, saved_next_index);
                        return -1;
                    };
                };
            };
            idx = idx + 1;
            idx = skip_whitespace(base, len, idx);
            break;
        };
        if have_value_expr {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };

        let mut handled_statement: bool = false;
        let mut let_cursor: i32 = expect_keyword_let(base, len, idx);
        if let_cursor >= 0 {
            if let_cursor >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let after_keyword: i32 = load_u8(base + let_cursor);
            if !is_whitespace(after_keyword) {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, let_cursor);
            let mut is_mut: bool = false;
            if idx + 3 <= len {
                let m: i32 = load_u8(base + idx);
                if m == 'm' {
                    let u: i32 = load_u8(base + idx + 1);
                    let t: i32 = load_u8(base + idx + 2);
                    if u == 'u' && t == 't' {
                        let after_mut: i32 = idx + 3;
                        if after_mut >= len {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let after_mut_byte: i32 = load_u8(base + after_mut);
                        if is_whitespace(after_mut_byte) {
                            is_mut = true;
                            idx = skip_whitespace(base, len, after_mut);
                        };
                    };
                };
            };

            idx = parse_identifier(base, len, idx, ident_start_ptr, ident_len_ptr);
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let name_start: i32 = load_i32(ident_start_ptr);
            let name_len: i32 = load_i32(ident_len_ptr);

            let current_stack: i32 = load_i32(locals_stack_count_ptr);
            let existing: i32 = find_local_entry_index_in_scope(
                base,
                locals_table_ptr,
                saved_stack_count,
                current_stack,
                name_start,
                name_len,
            );
            if existing >= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };

            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, ':');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, idx);
            idx = parse_type(base, len, idx, ast_base, stmt_local_type_ptr);
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, '=');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, idx);
            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let init_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let init_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let init_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let init_index: i32 =
                expression_node_from_parts(ast_base, init_kind, init_data0, init_data1);
            if init_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, ';');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };

            let stack_count: i32 = load_i32(locals_stack_count_ptr);
            if stack_count >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let next_local_offset: i32 = load_i32(locals_next_index_ptr);
            if next_local_offset >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let local_index: i32 = params_count + next_local_offset;
            let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, stack_count);
            store_i32(entry_ptr, name_start);
            store_i32(entry_ptr + 4, name_len);
            store_i32(entry_ptr + 8, local_index);
            let local_type_id: i32 = load_i32(stmt_local_type_ptr);
            store_i32(entry_ptr + 12, local_type_id);
            store_i32(entry_ptr + 16, if is_mut { 1 } else { 0 });
            store_i32(locals_stack_count_ptr, stack_count + 1);
            store_i32(locals_next_index_ptr, next_local_offset + 1);

            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 0);
            store_i32(stmt_ptr + 4, local_index);
            store_i32(stmt_ptr + 8, init_index);
            store_i32(statement_count_ptr, stmt_count + 1);
            handled_statement = true;
        };

        if handled_statement {
            continue;
        };

        let mut expression_parsed: bool = false;

        let mut break_cursor: i32 = expect_keyword_break(base, len, idx);
        if break_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let mut after_break: i32 = skip_whitespace(base, len, break_cursor);
            if after_break >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let mut value_index: i32 = -1;
            let after_byte: i32 = load_u8(base + after_break);
            if after_byte != ';' {
                after_break = parse_expression(
                    base,
                    len,
                    after_break,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                value_index = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                after_break = skip_whitespace(base, len, after_break);
                after_break = expect_char(base, len, after_break, ';');
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
            } else {
                after_break = skip_whitespace(base, len, after_break + 1);
            };
            let break_expr_index: i32 = ast_expr_alloc_break(ast_base, value_index);
            if break_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, break_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = after_break;
            continue;
        };

        let mut continue_cursor: i32 = expect_keyword_continue(base, len, idx);
        if continue_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            if continue_cursor < len {
                let after_byte: i32 = load_u8(base + continue_cursor);
                if after_byte != ';' && !is_whitespace(after_byte) {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
            };
            let mut after_continue: i32 = skip_whitespace(base, len, continue_cursor);
            after_continue = expect_char(base, len, after_continue, ';');
            if after_continue < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let continue_expr_index: i32 = ast_expr_alloc_continue(ast_base);
            if continue_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, continue_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = skip_whitespace(base, len, after_continue);
            continue;
        };

        let mut return_cursor: i32 = expect_keyword_return(base, len, idx);
        if return_cursor >= 0 {
            let mut after_return: i32 = skip_whitespace(base, len, return_cursor);
            after_return = parse_expression(
                base,
                len,
                after_return,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if after_return < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let value_index: i32 = expression_node_from_parts(
                ast_base,
                value_kind,
                value_data0,
                value_data1,
            );
            if value_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            after_return = skip_whitespace(base, len, after_return);
            after_return = expect_char(base, len, after_return, ';');
            if after_return < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let return_expr_index: i32 = ast_expr_alloc_return(ast_base, value_index);
            if return_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            have_value_expr = true;
            final_kind = 23;
            final_data0 = return_expr_index;
            final_data1 = 0;
            store_i32(out_value_status_ptr, 1);
            idx = skip_whitespace(base, len, after_return);
            continue;
        };

        let mut loop_cursor: i32 = expect_keyword_loop(base, len, idx);
        if loop_cursor >= 0 {
            let mut after_loop: i32 = skip_whitespace(base, len, loop_cursor);
            after_loop = expect_char(base, len, after_loop, '{');
            if after_loop < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let saved_loop_depth: i32 = load_i32(loop_depth_ptr);
            store_i32(loop_depth_ptr, saved_loop_depth + 1);
            after_loop = parse_block_expression_body(
                base,
                len,
                after_loop,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                ident_start_ptr,
                ident_len_ptr,
                stmt_nested_temp_base,
                1,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
                stmt_expr_value_status_ptr,
            );
            if after_loop < 0 {
                store_i32(loop_depth_ptr, saved_loop_depth);
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            store_i32(loop_depth_ptr, saved_loop_depth);
            let body_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let body_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let body_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let body_index: i32 = expression_node_from_parts(
                ast_base,
                body_kind,
                body_data0,
                body_data1,
            );
            if body_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let loop_expr_index: i32 = ast_expr_alloc_loop(ast_base, body_index);
            if loop_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            store_i32(stmt_expr_kind_ptr, 12);
            store_i32(stmt_expr_data0_ptr, loop_expr_index);
            store_i32(stmt_expr_data1_ptr, 0);
            idx = after_loop;
            expression_parsed = true;
        };

        let statement_start: i32 = idx;
        let mut assignment_identified: bool = false;
        let mut assignment_local_index: i32 = -1;
        let mut assignment_cursor: i32 = idx;
        if !expression_parsed {
            if is_identifier_start(next_byte) {
                assignment_cursor = parse_identifier(
                    base,
                    len,
                    idx,
                    ident_start_ptr,
                    ident_len_ptr,
                );
                if assignment_cursor >= 0 {
                    let name_start: i32 = load_i32(ident_start_ptr);
                    let name_len: i32 = load_i32(ident_len_ptr);
                    let mut after_ident: i32 = skip_whitespace(base, len, assignment_cursor);
                    if after_ident < len {
                        let assign_byte: i32 = load_u8(base + after_ident);
                        if assign_byte == '=' {
                            let mut after_equal: i32 = after_ident + 1;
                            if after_equal >= len {
                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                store_i32(locals_next_index_ptr, saved_next_index);
                                return -1;
                            };
                            let maybe_second_equal: i32 = load_u8(base + after_equal);
                            if maybe_second_equal != '=' {
                                let current_stack: i32 = load_i32(locals_stack_count_ptr);
                                let entry_index: i32 = find_local_entry_index(
                                    base,
                                    locals_table_ptr,
                                    current_stack,
                                    name_start,
                                    name_len,
                                );
                                if entry_index < 0 {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                };
                                let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, entry_index);
                                if !locals_entry_is_mut(entry_ptr) {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                };
                                assignment_local_index = locals_entry_local_index(entry_ptr);
                                assignment_identified = true;
                                assignment_cursor = skip_whitespace(base, len, after_equal);
                            };
                        };
                    };
                };
            };
        };

        if !expression_parsed {
            idx = statement_start;
            if assignment_identified {
                idx = parse_expression(
                    base,
                    len,
                    assignment_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                let value_index: i32 = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                idx = skip_whitespace(base, len, idx);
                idx = expect_char(base, len, idx, ';');
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let assign_expr_index: i32 =
                    ast_expr_alloc_set_local(ast_base, assignment_local_index, value_index);
                if assign_expr_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let stmt_count: i32 = load_i32(statement_count_ptr);
                if stmt_count >= statements_capacity {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                };
                let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                store_i32(stmt_ptr, 1);
                store_i32(stmt_ptr + 4, assign_expr_index);
                store_i32(stmt_ptr + 8, 0);
                store_i32(statement_count_ptr, stmt_count + 1);
                continue;
            };

            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
        };
        let expr_kind: i32 = load_i32(stmt_expr_kind_ptr);
        let expr_data0: i32 = load_i32(stmt_expr_data0_ptr);
        let expr_data1: i32 = load_i32(stmt_expr_data1_ptr);
        let mut next_cursor: i32 = skip_whitespace(base, len, idx);
        let mut treat_as_statement: bool = false;
        if next_cursor < len {
            let delimiter: i32 = load_u8(base + next_cursor);
            if delimiter == ';' {
                let after_semicolon: i32 = skip_whitespace(base, len, next_cursor + 1);
                if after_semicolon < len {
                    let after_byte: i32 = load_u8(base + after_semicolon);
                    if after_byte == '}' && !have_value_expr {
                        next_cursor = after_semicolon;
                    } else {
                        treat_as_statement = true;
                        next_cursor = after_semicolon;
                    };
                } else {
                    treat_as_statement = true;
                    next_cursor = after_semicolon;
                };
            };
        };
        if !treat_as_statement {
            if expr_kind == 12 {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte != '}' {
                        treat_as_statement = true;
                    };
                };
            };
        };
        if treat_as_statement {
            let expr_index: i32 = expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
            if expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = next_cursor;
            continue;
        };

        let expr_metadata: i32 = load_i32(stmt_expr_data1_ptr);
        if expr_metadata < 0 {
            if allow_empty_value {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte == '}' {
                        let expr_index: i32 =
                            expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
                        if expr_index < 0 {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let stmt_count: i32 = load_i32(statement_count_ptr);
                        if stmt_count >= statements_capacity {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        };
                        let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                        store_i32(stmt_ptr, 1);
                        store_i32(stmt_ptr + 4, expr_index);
                        store_i32(stmt_ptr + 8, 0);
                        store_i32(statement_count_ptr, stmt_count + 1);
                        idx = next_cursor;
                        continue;
                    };
                };
            };
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        };
        have_value_expr = true;
        final_kind = expr_kind;
        final_data0 = expr_data0;
        final_data1 = expr_data1;
        store_i32(out_value_status_ptr, 1);
        idx = next_cursor;
    };

    store_i32(locals_stack_count_ptr, saved_stack_count);

    let mut final_index: i32 =
        expression_node_from_parts(ast_base, final_kind, final_data0, final_data1);
    if final_index < 0 {
        store_i32(locals_next_index_ptr, saved_next_index);
        return -1;
    };
    let stmt_count: i32 = load_i32(statement_count_ptr);
    if stmt_count > 0 {
        let mut stmt_idx: i32 = stmt_count - 1;
        loop {
            if stmt_idx < 0 {
                break;
            };
            let stmt_ptr: i32 = statements_base + stmt_idx * statement_entry_size;
            let stmt_kind: i32 = load_i32(stmt_ptr);
            if stmt_kind == 0 {
                let local_index: i32 = load_i32(stmt_ptr + 4);
                let init_index: i32 = load_i32(stmt_ptr + 8);
                final_index = ast_expr_alloc_let(ast_base, local_index, init_index, final_index);
            } else {
                let first_index: i32 = load_i32(stmt_ptr + 4);
                final_index = ast_expr_alloc_sequence(ast_base, first_index, final_index);
            };
            if final_index < 0 {
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            };
            stmt_idx = stmt_idx - 1;
        };
    };

    store_i32(out_kind_ptr, 2);
    store_i32(out_data0_ptr, final_index);
    store_i32(out_data1_ptr, 0);
    idx
}

const BUILTIN_TYPE_ID_I32: i32 = 0;

const BUILTIN_TYPE_ID_BOOL: i32 = 1;

const BUILTIN_TYPE_ID_I8: i32 = 2;

const BUILTIN_TYPE_ID_I16: i32 = 3;

const BUILTIN_TYPE_ID_I64: i32 = 4;

const BUILTIN_TYPE_ID_U8: i32 = 5;

const BUILTIN_TYPE_ID_U16: i32 = 6;

const BUILTIN_TYPE_ID_U32: i32 = 7;

const BUILTIN_TYPE_ID_U64: i32 = 8;

const BUILTIN_INTEGER_VARIANT_COUNT: i32 = 4;

const SCRATCH_TYPES_CAPACITY: i32 = 2048;

const BUILTIN_TYPE_ID_MAX: i32 = BUILTIN_TYPE_ID_U64;

const TYPE_ID_KIND_SHIFT: i32 = 24;

const TYPE_ID_KIND_USER_COMPOSITE: i32 = 1;

fn type_id_array_base() -> i32 {
    TYPE_ID_KIND_USER_COMPOSITE << TYPE_ID_KIND_SHIFT
}

fn type_id_array_limit() -> i32 {
    type_id_array_base() + SCRATCH_TYPES_CAPACITY
}

fn type_id_is_builtin(type_id: i32) -> bool {
    type_id >= 0 && type_id <= BUILTIN_TYPE_ID_MAX
}

fn type_id_is_array(type_id: i32) -> bool {
    let base: i32 = type_id_array_base();
    let limit: i32 = type_id_array_limit();
    type_id >= base && type_id < limit
}

fn type_id_is_bool(type_id: i32) -> bool {
    type_id == BUILTIN_TYPE_ID_BOOL
}

fn integer_type_variant_index(type_id: i32) -> i32 {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == signed[idx] {
            return idx;
        };
        if type_id == unsigned[idx] {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn type_id_is_integer(type_id: i32) -> bool {
    integer_type_variant_index(type_id) >= 0
}

fn type_id_is_signed_integer(type_id: i32) -> bool {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == signed[idx] {
            return true;
        };
        idx = idx + 1;
    };
    false
}

fn type_id_is_unsigned_integer(type_id: i32) -> bool {
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    let count: i32 = len(unsigned);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        if type_id == unsigned[idx] {
            return true;
        };
        idx = idx + 1;
    };
    false
}

fn type_id_is_64_bit_integer(type_id: i32) -> bool {
    let variant_index: i32 = integer_type_variant_index(type_id);
    if variant_index < 0 {
        return false;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[variant_index] == 64
}

const WASM_VALUE_TYPE_I32: i32 = 127;

const WASM_VALUE_TYPE_I64: i32 = 126;

const WASM_REF_TYPE_REF: i32 = -28;

const WASM_COMPOSITE_TYPE_ARRAY: i32 = -34;

const WASM_MUTABILITY_VAR: i32 = 1;

fn type_id_to_wasm_value_type(type_id: i32) -> i32 {
    if type_id_is_64_bit_integer(type_id) {
        return WASM_VALUE_TYPE_I64;
    };
    if type_id_is_integer(type_id) || type_id_is_bool(type_id) {
        return WASM_VALUE_TYPE_I32;
    };
    -1
}

fn type_id_wasm_value_type_len(type_id: i32) -> i32 {
    if type_id_is_array(type_id) {
        let heap_index: i32 = array_type_index(type_id);
        if heap_index < 0 {
            return -1;
        };
        return leb_i32_len(WASM_REF_TYPE_REF) + leb_i32_len(heap_index);
    };
    let numeric: i32 = type_id_to_wasm_value_type(type_id);
    if numeric < 0 {
        return -1;
    };
    1
}

fn write_type_id_as_wasm_value_type(base: i32, offset: i32, type_id: i32) -> i32 {
    if type_id_is_array(type_id) {
        let heap_index: i32 = array_type_index(type_id);
        if heap_index < 0 {
            return -1;
        };
        let mut out: i32 = write_i32_leb(base, offset, WASM_REF_TYPE_REF);
        out = write_i32_leb(base, out, heap_index);
        return out;
    };
    let numeric: i32 = type_id_to_wasm_value_type(type_id);
    if numeric < 0 {
        return -1;
    };
    write_byte(base, offset, numeric)
}

fn integer_type_bit_width(type_id: i32) -> i32 {
    let variant_index: i32 = integer_type_variant_index(type_id);
    if variant_index < 0 {
        return -1;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[variant_index]
}

fn mask_i32_code_size(width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    let mask: i32 = (1 << width) - 1;
    1 + leb_i32_len(mask) + 1
}

fn mask_i32_value(base: i32, offset: i32, width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    let mask: i32 = (1 << width) - 1;
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, mask);
    out = write_byte(base, out, 113);
    out
}

fn sign_extend_i32_code_size(width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    let shift: i32 = 32 - width;
    let len: i32 = leb_i32_len(shift);
    2 * (1 + len) + 2
}

fn sign_extend_i32_value(base: i32, offset: i32, width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    let shift: i32 = 32 - width;
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, shift);
    out = write_byte(base, out, 116);
    out = write_byte(base, out, 65);
    out = write_i32_leb(base, out, shift);
    out = write_byte(base, out, 117);
    out
}

fn canonicalize_i32_code_size(width: i32, signed: bool) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    if signed {
        return sign_extend_i32_code_size(width);
    };
    mask_i32_code_size(width)
}

fn canonicalize_i32_value(base: i32, offset: i32, width: i32, signed: bool) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    if signed {
        return sign_extend_i32_value(base, offset, width);
    };
    mask_i32_value(base, offset, width)
}

fn cast_expression_extra_code_size(source_type: i32, target_type: i32) -> i32 {
    if source_type == target_type {
        return 0;
    };
    if !type_id_is_integer(source_type) {
        return -1;
    };
    if !type_id_is_integer(target_type) {
        return -1;
    };
    let source_width: i32 = integer_type_bit_width(source_type);
    let target_width: i32 = integer_type_bit_width(target_type);
    if source_width < 0 {
        return -1;
    };
    if target_width < 0 {
        return -1;
    };
    let source_signed: bool = type_id_is_signed_integer(source_type);
    let target_signed: bool = type_id_is_signed_integer(target_type);
    let mut total: i32 = 0;
    let mut working_is_64: bool = type_id_is_64_bit_integer(source_type);
    let target_is_64: bool = type_id_is_64_bit_integer(target_type);
    if !working_is_64 {
        let canonical: i32 = canonicalize_i32_code_size(source_width, source_signed);
        if canonical < 0 {
            return -1;
        };
        total = total + canonical;
    };
    if working_is_64 && !target_is_64 {
        total = total + 1;
        working_is_64 = false;
    };
    if !working_is_64 && target_is_64 {
        total = total + 1;
        return total;
    };
    if working_is_64 && target_is_64 {
        return total;
    };
    if target_width < 32 {
        let adjust: i32 = if target_signed {
            sign_extend_i32_code_size(target_width)
        } else {
            mask_i32_code_size(target_width)
        };
        if adjust < 0 {
            return -1;
        };
        total = total + adjust;
    };
    total
}

fn emit_cast_value(base: i32, offset: i32, source_type: i32, target_type: i32) -> i32 {
    if source_type == target_type {
        return offset;
    };
    if !type_id_is_integer(source_type) {
        return -1;
    };
    if !type_id_is_integer(target_type) {
        return -1;
    };
    let source_width: i32 = integer_type_bit_width(source_type);
    let target_width: i32 = integer_type_bit_width(target_type);
    if source_width < 0 {
        return -1;
    };
    if target_width < 0 {
        return -1;
    };
    let source_signed: bool = type_id_is_signed_integer(source_type);
    let target_signed: bool = type_id_is_signed_integer(target_type);
    let mut out: i32 = offset;
    let mut working_is_64: bool = type_id_is_64_bit_integer(source_type);
    let target_is_64: bool = type_id_is_64_bit_integer(target_type);
    if !working_is_64 {
        out = canonicalize_i32_value(base, out, source_width, source_signed);
        if out < 0 {
            return -1;
        };
    };
    if working_is_64 && !target_is_64 {
        out = write_byte(base, out, 167);
        working_is_64 = false;
    };
    if !working_is_64 && target_is_64 {
        let opcode: i32 = if source_signed { 172 } else { 173 };
        out = write_byte(base, out, opcode);
        return out;
    };
    if working_is_64 && target_is_64 {
        return out;
    };
    if target_width < 32 {
        if target_signed {
            out = sign_extend_i32_value(base, out, target_width);
        } else {
            out = mask_i32_value(base, out, target_width);
        };
    };
    out
}

fn builtin_integer_variant_width(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[index]
}

fn builtin_signed_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    signed[index]
}

fn builtin_unsigned_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    };
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    unsigned[index]
}

fn builtin_integer_type_keyword_to_id(base: i32, start: i32, ident_len: i32) -> i32 {
    if ident_len <= 1 {
        return -1;
    };
    let first: i32 = load_u8(base + start);
    if first != 'i' && first != 'u' {
        return -1;
    };
    let mut idx: i32 = 1;
    let mut width: i32 = 0;
    loop {
        if idx >= ident_len {
            break;
        };
        let digit: i32 = load_u8(base + start + idx);
        if !is_digit(digit) {
            return -1;
        };
        width = width * 10 + (digit - '0');
        idx = idx + 1;
    };
    let variant_count: i32 = BUILTIN_INTEGER_VARIANT_COUNT;
    let mut variant_index: i32 = 0;
    loop {
        if variant_index >= variant_count {
            break;
        };
        let expected_width: i32 = builtin_integer_variant_width(variant_index);
        if expected_width == width {
            if first == 'i' {
                return builtin_signed_integer_type_id_for_variant(variant_index);
            };
            return builtin_unsigned_integer_type_id_for_variant(variant_index);
        };
        variant_index = variant_index + 1;
    };
    -1
}

fn parse_type(base: i32, len: i32, offset: i32, ast_base: i32, out_type_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let first: i32 = load_u8(base + offset);
    if first == '[' {
        if out_type_ptr < 0 {
            return -1;
        };
        let mut cursor: i32 = offset + 1;
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_type(base, len, cursor, ast_base, out_type_ptr);
        if cursor < 0 {
            return -1;
        };
        let element_type_id: i32 = load_i32(out_type_ptr);
        if element_type_id < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ';');
        if cursor < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_i32_literal(base, len, cursor, out_type_ptr);
        if cursor < 0 {
            return -1;
        };
        let length: i32 = load_i32(out_type_ptr);
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ']');
        if cursor < 0 {
            return -1;
        };
        let type_id: i32 = ast_register_array_type(ast_base, element_type_id, length);
        if type_id < 0 {
            return -1;
        };
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return cursor;
    };
    if !is_identifier_start(first) {
        return -1;
    };
    let mut next: i32 = offset + 1;
    loop {
        if next >= len {
            break;
        };
        let byte: i32 = load_u8(base + next);
        if !is_identifier_continue(byte) {
            break;
        };
        next = next + 1;
    };
    let ident_len: i32 = next - offset;
    if ident_len <= 0 {
        return -1;
    };
    let type_id: i32 = builtin_integer_type_keyword_to_id(base, offset, ident_len);
    if type_id >= 0 {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        };
        return next;
    };
    let bool_keyword: [u8; 10] = "bool\0\0\0\0\0\0";
    if identifier_matches_keyword(base, len, offset, ident_len, bool_keyword) {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        };
        return next;
    };
    -1
}

fn parse_i32_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let mut idx: i32 = offset;
    let mut sign: i32 = 1;
    let first: i32 = load_u8(base + idx);
    if first == '-' {
        sign = -1;
        idx = idx + 1;
        if idx >= len {
            return -1;
        };
    };
    let mut digits: i32 = 0;
    let mut value: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_digit(byte) {
            break;
        };
        value = value * 10 + (byte - '0');
        idx = idx + 1;
        digits = digits + 1;
    };
    if digits == 0 {
        return -1;
    };
    store_i32(out_value_ptr, value * sign);
    idx
}

fn parse_char_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let quote: i32 = load_u8(base + offset);
    if quote != '\'' {
        return -1;
    };
    let mut idx: i32 = offset + 1;
    if idx >= len {
        return -1;
    };
    let mut value: i32 = load_u8(base + idx);
    if value == '\\' {
        idx = idx + 1;
        if idx >= len {
            return -1;
        };
        let escape: i32 = load_u8(base + idx);
        value = if escape == 'n' {
            '\n'
        } else if escape == 'r' {
            '\r'
        } else if escape == 't' {
            '\t'
        } else if escape == '0' {
            '\0'
        } else if escape == '\\' {
            '\\'
        } else if escape == '\'' {
            '\''
        } else {
            return -1;
        };
    } else if value == '\n' || value == '\r' {
        return -1;
    };
    idx = idx + 1;
    if idx >= len {
        return -1;
    };
    let closing: i32 = load_u8(base + idx);
    if closing != '\'' {
        return -1;
    };
    store_i32(out_value_ptr, value);
    idx + 1
}

const WORD_SIZE: i32 = 4;

const SCRATCH_INSTR_OFFSET: i32 = 4096;

const SCRATCH_EXPR_TYPE_OFFSET: i32 = 4092;

const SCRATCH_INSTR_BASE_OFFSET: i32 = 8192;

const SCRATCH_INSTR_CAPACITY: i32 = 65536;

const SCRATCH_FN_COUNT_OFFSET: i32 = 851960;

const SCRATCH_FN_BASE_OFFSET: i32 = 851968;

const TYPE_ENTRY_SIZE: i32 = 16;

const TYPE_ENTRY_TYPE_ID_OFFSET: i32 = 0;

const TYPE_ENTRY_NAME_PTR_OFFSET: i32 = 4;

const TYPE_ENTRY_NAME_LEN_OFFSET: i32 = 8;

const TYPE_ENTRY_EXTRA_OFFSET: i32 = 12;

fn scratch_types_base_offset() -> i32 {
    SCRATCH_FN_BASE_OFFSET - SCRATCH_TYPES_CAPACITY * TYPE_ENTRY_SIZE
}

fn scratch_types_count_offset() -> i32 {
    scratch_types_base_offset() - WORD_SIZE
}

fn scratch_instr_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_INSTR_OFFSET
}

fn scratch_expr_type_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_EXPR_TYPE_OFFSET
}

fn scratch_instr_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_INSTR_BASE_OFFSET
}

fn scratch_fn_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FN_COUNT_OFFSET
}

fn scratch_fn_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FN_BASE_OFFSET
}

fn scratch_types_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_count_offset()
}

fn scratch_types_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_base_offset()
}

fn scratch_type_entry_ptr(out_ptr: i32, index: i32) -> i32 {
    scratch_types_base(out_ptr) + index * TYPE_ENTRY_SIZE
}

fn scratch_type_entry_type_id_ptr(out_ptr: i32, index: i32) -> i32 {
    scratch_type_entry_ptr(out_ptr, index) + TYPE_ENTRY_TYPE_ID_OFFSET
}

fn scratch_types_count(out_ptr: i32) -> i32 {
    load_i32(scratch_types_count_ptr(out_ptr))
}

fn scratch_types_set_count(out_ptr: i32, count: i32) {
    store_i32(scratch_types_count_ptr(out_ptr), count);
}

const AST_MAX_FUNCTIONS: i32 = 256;

const AST_FUNCTION_ENTRY_SIZE: i32 = 32;

const AST_NAMES_CAPACITY: i32 = 65536;

fn ast_call_data_capacity() -> i32 {
    65536 - ast_constants_section_words()
}

fn ast_output_reserve(input_len: i32) -> i32 {
    let after_output: i32 = input_len + SCRATCH_INSTR_CAPACITY;
    let scratch_end: i32 = SCRATCH_FN_BASE_OFFSET + 16384;
    if after_output > scratch_end { after_output } else { scratch_end }
}

fn ast_program_base(out_ptr: i32, input_len: i32) -> i32 {
    out_ptr + ast_output_reserve(input_len)
}

fn ast_functions_count_ptr(ast_base: i32) -> i32 {
    ast_base
}

fn ast_function_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_base + WORD_SIZE + index * AST_FUNCTION_ENTRY_SIZE
}

fn ast_names_len_ptr(ast_base: i32) -> i32 {
    ast_base + WORD_SIZE + AST_MAX_FUNCTIONS * AST_FUNCTION_ENTRY_SIZE
}

fn ast_names_base(ast_base: i32) -> i32 {
    ast_names_len_ptr(ast_base) + WORD_SIZE
}

fn ast_call_data_len_ptr(ast_base: i32) -> i32 {
    ast_names_base(ast_base) + AST_NAMES_CAPACITY
}

fn ast_call_data_base(ast_base: i32) -> i32 {
    ast_call_data_len_ptr(ast_base) + WORD_SIZE
}

fn ast_reset(ast_base: i32) {
    store_i32(ast_functions_count_ptr(ast_base), 0);
    store_i32(ast_names_len_ptr(ast_base), 0);
    store_i32(ast_call_data_len_ptr(ast_base), 0);
    ast_constants_reset(ast_base);
    ast_array_types_reset(ast_base);
    ast_type_definitions_reset(ast_base);
    ast_expr_reset(ast_base);
}

fn ast_store_name(ast_base: i32, source_base: i32, start: i32, len: i32) -> i32 {
    let name_len_ptr: i32 = ast_names_len_ptr(ast_base);
    let mut used: i32 = load_i32(name_len_ptr);
    if used + len > AST_NAMES_CAPACITY {
        return -1;
    };
    let name_ptr: i32 = ast_names_base(ast_base) + used;
    let mut idx: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(source_base + start + idx);
        store_u8(name_ptr + idx, byte);
        idx = idx + 1;
    };
    used = used + len;
    store_i32(name_len_ptr, used);
    name_ptr
}

fn ast_call_data_alloc(ast_base: i32, word_count: i32) -> i32 {
    if word_count <= 0 {
        return -1;
    };
    let used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let used: i32 = load_i32(used_ptr);
    if used + word_count > ast_call_data_capacity() {
        return -1;
    };
    let entry_ptr: i32 = ast_call_data_base(ast_base) + used * WORD_SIZE;
    store_i32(used_ptr, used + word_count);
    entry_ptr
}

fn call_metadata_name_ptr(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr)
}

fn call_metadata_name_len(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 4)
}

fn call_metadata_arg_count(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 8)
}

fn call_metadata_callee_index_ptr(metadata_ptr: i32) -> i32 {
    metadata_ptr + 12
}

fn call_metadata_args_base(metadata_ptr: i32) -> i32 {
    metadata_ptr + 16
}

fn ast_write_function_entry(
    ast_base: i32,
    index: i32,
    name_ptr: i32,
    name_len: i32,
    param_count: i32,
    body_kind: i32,
    body_data0: i32,
    locals_count: i32,
    param_types_ptr: i32,
    return_type_id: i32,
) {
    let entry_ptr: i32 = ast_function_entry_ptr(ast_base, index);
    store_i32(entry_ptr, name_ptr);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, param_count);
    store_i32(entry_ptr + 12, body_kind);
    store_i32(entry_ptr + 16, body_data0);
    store_i32(entry_ptr + 20, locals_count);
    store_i32(entry_ptr + 24, param_types_ptr);
    store_i32(entry_ptr + 28, return_type_id);
}

const AST_CONSTANTS_CAPACITY: i32 = 1024;

const AST_CONSTANT_ENTRY_SIZE: i32 = 16;

fn ast_constants_section_size() -> i32 {
    WORD_SIZE + AST_CONSTANTS_CAPACITY * AST_CONSTANT_ENTRY_SIZE
}

fn ast_constants_section_words() -> i32 {
    ast_constants_section_size() / WORD_SIZE
}

fn ast_constants_count_ptr(ast_base: i32) -> i32 {
    ast_call_data_base(ast_base) + ast_call_data_capacity() * WORD_SIZE
}

fn ast_constant_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + WORD_SIZE + index * AST_CONSTANT_ENTRY_SIZE
}

fn ast_constants_count(ast_base: i32) -> i32 {
    load_i32(ast_constants_count_ptr(ast_base))
}

fn ast_constants_reset(ast_base: i32) {
    store_i32(ast_constants_count_ptr(ast_base), 0);
}

const AST_ARRAY_TYPES_CAPACITY: i32 = 256;

const AST_ARRAY_TYPE_ENTRY_SIZE: i32 = 12;

const AST_ARRAY_TYPE_ELEMENT_OFFSET: i32 = 0;

const AST_ARRAY_TYPE_LENGTH_OFFSET: i32 = 4;

const AST_ARRAY_TYPE_CACHE_OFFSET: i32 = 8;

fn ast_array_types_section_size() -> i32 {
    WORD_SIZE + AST_ARRAY_TYPES_CAPACITY * AST_ARRAY_TYPE_ENTRY_SIZE
}

fn ast_array_types_count_ptr(ast_base: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + ast_constants_section_size()
}

fn ast_array_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + WORD_SIZE + index * AST_ARRAY_TYPE_ENTRY_SIZE
}

fn ast_array_type_element_type(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_ELEMENT_OFFSET)
}

fn ast_array_type_length(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_LENGTH_OFFSET)
}

fn ast_array_type_payload_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_type_entry_ptr(ast_base, index)
}

fn ast_array_types_count(ast_base: i32) -> i32 {
    load_i32(ast_array_types_count_ptr(ast_base))
}

fn ast_array_types_reset(ast_base: i32) {
    store_i32(ast_array_types_count_ptr(ast_base), 0);
}

fn array_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET)
}

fn array_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET, type_id);
}

const AST_TYPE_DEFINITIONS_CAPACITY: i32 = 256;

const AST_TYPE_DEFINITION_ENTRY_SIZE: i32 = 12;

const AST_TYPE_DEFINITION_NAME_START_OFFSET: i32 = 0;

const AST_TYPE_DEFINITION_NAME_LEN_OFFSET: i32 = 4;

const AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET: i32 = 8;

fn ast_type_definitions_section_size() -> i32 {
    WORD_SIZE + AST_TYPE_DEFINITIONS_CAPACITY * AST_TYPE_DEFINITION_ENTRY_SIZE
}

fn ast_type_definitions_count_ptr(ast_base: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + ast_array_types_section_size()
}

fn ast_type_definition_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_type_definitions_count_ptr(ast_base) + WORD_SIZE + index * AST_TYPE_DEFINITION_ENTRY_SIZE
}

fn ast_type_definitions_count(ast_base: i32) -> i32 {
    load_i32(ast_type_definitions_count_ptr(ast_base))
}

fn ast_type_definitions_reset(ast_base: i32) {
    store_i32(ast_type_definitions_count_ptr(ast_base), 0);
}

fn ast_type_definition_name_start(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_NAME_START_OFFSET)
}

fn ast_type_definition_name_len(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_NAME_LEN_OFFSET)
}

fn ast_type_definition_target_type(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_type_definition_entry_ptr(ast_base, index) + AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET)
}

fn ast_type_definition_append(
    ast_base: i32,
    name_start: i32,
    name_len: i32,
    target_type_id: i32,
) -> i32 {
    let count_ptr: i32 = ast_type_definitions_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_TYPE_DEFINITIONS_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_type_definition_entry_ptr(ast_base, count);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_START_OFFSET, name_start);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_LEN_OFFSET, name_len);
    store_i32(entry_ptr + AST_TYPE_DEFINITION_TARGET_TYPE_OFFSET, target_type_id);
    store_i32(count_ptr, count + 1);
    count
}

fn find_type_definition_entry_index(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let count: i32 = ast_type_definitions_count(ast_base);
    if count <= 0 {
        return -1;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_type_definition_entry_ptr(ast_base, idx);
        let def_start: i32 = load_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_START_OFFSET);
        let def_len: i32 = load_i32(entry_ptr + AST_TYPE_DEFINITION_NAME_LEN_OFFSET);
        if identifiers_match_source(base, def_start, def_len, ident_start, ident_len) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn find_type_definition_target_type(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let index: i32 = find_type_definition_entry_index(base, ast_base, ident_start, ident_len);
    if index < 0 {
        return -1;
    };
    ast_type_definition_target_type(ast_base, index)
}

fn array_type_id(index: i32) -> i32 {
    type_id_array_base() + index
}

fn array_type_index(type_id: i32) -> i32 {
    type_id - type_id_array_base()
}

fn array_type_element_type(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    ast_array_type_element_type(ast_base, index)
}

fn array_type_length(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    ast_array_type_length(ast_base, index)
}

fn ast_register_array_type(ast_base: i32, element_type_id: i32, length: i32) -> i32 {
    if length < 0 {
        return -1;
    };
    let count_ptr: i32 = ast_array_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, idx);
        let existing_element: i32 = load_i32(entry_ptr);
        let existing_length: i32 = load_i32(entry_ptr + 4);
        if existing_element == element_type_id && existing_length == length {
            return array_type_id(idx);
        };
        idx = idx + 1;
    };
    if count >= AST_ARRAY_TYPES_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, count);
    store_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET, element_type_id);
    store_i32(entry_ptr + AST_ARRAY_TYPE_LENGTH_OFFSET, length);
    store_i32(entry_ptr + AST_ARRAY_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    array_type_id(count)
}

fn ensure_array_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    };
    let cached: i32 = array_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    };
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_array_type_payload_ptr(ast_base, index),
    );
    array_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if index + 1 > current_count {
        scratch_types_set_count(out_ptr, index + 1);
    };
    0
}

fn resolve_array_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    };
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    };
    if index >= ast_array_types_count(ast_base) {
        return -1;
    };
    let element_type_id: i32 = ast_array_type_element_type(ast_base, index);
    if resolve_type_id(out_ptr, ast_base, element_type_id) < 0 {
        return -1;
    };
    let length: i32 = ast_array_type_length(ast_base, index);
    if length < 0 {
        return -1;
    };
    if ensure_array_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        return -1;
    };
    type_id
}

fn resolve_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if type_id < 0 {
        return -1;
    };
    if type_id_is_array(type_id) {
        return resolve_array_type_id(out_ptr, ast_base, type_id);
    };
    if type_id_is_builtin(type_id) {
        return type_id;
    };
    -1
}

fn ast_extra_base(ast_base: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + ast_array_types_section_size()
}

const AST_EXPR_ENTRY_SIZE: i32 = 16;

const AST_EXPR_CAPACITY: i32 = 32768;

fn ast_expr_count_ptr(ast_base: i32) -> i32 {
    ast_extra_base(ast_base)
}

fn ast_expr_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_extra_base(ast_base) + WORD_SIZE + index * AST_EXPR_ENTRY_SIZE
}

fn ast_expr_types_base(ast_base: i32) -> i32 {
    ast_extra_base(ast_base) + 524292
}

fn ast_expr_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_expr_types_base(ast_base) + index * WORD_SIZE
}

fn ast_expr_set_type(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_expr_type_entry_ptr(ast_base, index), type_id);
}

fn ast_expr_type(ast_base: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    };
    if index >= ast_expr_count(ast_base) {
        return -1;
    };
    load_i32(ast_expr_type_entry_ptr(ast_base, index))
}

fn ast_temp_base(ast_base: i32) -> i32 {
    ast_expr_types_base(ast_base) + 131072
}

fn ast_expr_reset(ast_base: i32) {
    store_i32(ast_expr_count_ptr(ast_base), 0);
}

fn ast_expr_count(ast_base: i32) -> i32 {
    load_i32(ast_expr_count_ptr(ast_base))
}

fn ast_expr_alloc(ast_base: i32, kind: i32, data0: i32, data1: i32, data2: i32) -> i32 {
    let count_ptr: i32 = ast_expr_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_EXPR_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, count);
    store_i32(entry_ptr, kind);
    store_i32(entry_ptr + 4, data0);
    store_i32(entry_ptr + 8, data1);
    store_i32(entry_ptr + 12, data2);
    store_i32(count_ptr, count + 1);
    ast_expr_set_type(ast_base, count, -1);
    count
}

fn ast_expr_alloc_literal(ast_base: i32, value: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 0, value, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_call(ast_base: i32, metadata_ptr: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 1, metadata_ptr, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_add(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 2, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_sub(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 3, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_mul(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 4, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_div(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 5, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_or(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 25, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_and(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 26, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_load_u8(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 29, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_load_u16(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 30, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_load_i32(ast_base: i32, ptr_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 31, ptr_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_u8(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 32, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_u16(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 33, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_store_i32(ast_base: i32, ptr_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 34, ptr_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_array_repeat(ast_base: i32, element_index: i32, length: i32) -> i32 {
    if length < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 35, element_index, length, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_list(ast_base: i32, values_ptr: i32, count: i32) -> i32 {
    if count <= 0 {
        return -1;
    };
    if values_ptr < 0 {
        return -1;
    };
    let index: i32 = ast_expr_alloc(ast_base, 37, values_ptr, count, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_get(ast_base: i32, array_index: i32, index_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 36, array_index, index_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_array_len(ast_base: i32, array_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 38, array_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_cast(ast_base: i32, value_index: i32, target_type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 39, value_index, target_type_id, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, target_type_id);
    index
}

fn ast_expr_alloc_shl(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 27, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_shr_s(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 28, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_eq(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 14, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ne(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 15, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_lt(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 16, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_gt(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 17, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_le(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 18, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ge(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 19, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_or(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 20, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_and(ast_base: i32, left_index: i32, right_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 21, left_index, right_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_not(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 22, value_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_param(ast_base: i32, param_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 6, param_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_if(
    ast_base: i32,
    condition_index: i32,
    then_index: i32,
    else_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 7, condition_index, then_index, else_index);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_local(ast_base: i32, local_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 8, local_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_let(
    ast_base: i32,
    local_index: i32,
    init_index: i32,
    body_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 9, local_index, init_index, body_index);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_set_local(ast_base: i32, local_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 10, local_index, value_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn ast_expr_alloc_sequence(ast_base: i32, first_index: i32, then_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 11, first_index, then_index, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_loop(ast_base: i32, body_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 12, body_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_break(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 13, -1, value_index, 0);
    if index < 0 {
        return -1;
    };
    let value_type: i32 = if value_index >= 0 {
        ast_expr_type(ast_base, value_index)
    } else {
        -1
    };
    ast_expr_set_type(ast_base, index, value_type);
    index
}

fn ast_expr_alloc_continue(ast_base: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 24, -1, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_return(ast_base: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 23, value_index, 0, 0);
    if index < 0 {
        return -1;
    };
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn expression_node_from_parts(ast_base: i32, kind: i32, data0: i32, data1: i32) -> i32 {
    if kind == 0 {
        return ast_expr_alloc_literal(ast_base, data0, data1);
    };
    if kind == 1 {
        return ast_expr_alloc_call(ast_base, data0);
    };
    if kind == 6 {
        return ast_expr_alloc_param(ast_base, data0, data1);
    };
    if kind == 8 {
        return ast_expr_alloc_local(ast_base, data0, data1);
    };
    data0
}

fn parse_basic_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    ident_start_ptr: i32,
    ident_len_ptr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    nested_temp_base: i32,
) -> i32 {
    if cursor >= len {
        return -1;
    };
    let first_byte: i32 = load_u8(base + cursor);
    if first_byte == '{' {
        let block_status_ptr: i32 = nested_temp_base + 4096;
        let block_cursor: i32 = parse_block_expression_body(
            base,
            len,
            cursor + 1,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            literal_ptr,
            ident_start_ptr,
            ident_len_ptr,
            nested_temp_base,
            0,
            loop_depth_ptr,
            out_kind_ptr,
            out_data0_ptr,
            out_data1_ptr,
            block_status_ptr,
        );
        if block_cursor < 0 {
            return -1;
        };
        return block_cursor;
    };
    if first_byte == 'i' {
        let mut if_cursor: i32 = expect_keyword_if(base, len, cursor);
        if if_cursor >= 0 {
            let cond_kind_ptr: i32 = nested_temp_base;
            let cond_data0_ptr: i32 = nested_temp_base + 4;
            let cond_data1_ptr: i32 = nested_temp_base + 8;
            let then_kind_ptr: i32 = nested_temp_base + 12;
            let then_data0_ptr: i32 = nested_temp_base + 16;
            let then_data1_ptr: i32 = nested_temp_base + 20;
            let then_status_ptr: i32 = nested_temp_base + 24;
            let else_kind_ptr: i32 = nested_temp_base + 28;
            let else_data0_ptr: i32 = nested_temp_base + 32;
            let else_data1_ptr: i32 = nested_temp_base + 36;
            let else_status_ptr: i32 = nested_temp_base + 40;
            let cond_nested_base: i32 = nested_temp_base + 160;
            let then_nested_base: i32 = nested_temp_base + 320;
            let else_nested_base: i32 = nested_temp_base + 480;
            if_cursor = skip_whitespace(base, len, if_cursor);
            if_cursor = parse_expression(
                base,
                len,
                if_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                cond_nested_base,
                loop_depth_ptr,
                cond_kind_ptr,
                cond_data0_ptr,
                cond_data1_ptr,
            );
            if if_cursor < 0 {
                return -1;
            };
            if_cursor = skip_whitespace(base, len, if_cursor);
            if_cursor = expect_char(base, len, if_cursor, '{');
            if if_cursor < 0 {
                return -1;
            };
            if_cursor = parse_block_expression_body(
                base,
                len,
                if_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                ident_start_ptr,
                ident_len_ptr,
                then_nested_base,
                1,
                loop_depth_ptr,
                then_kind_ptr,
                then_data0_ptr,
                then_data1_ptr,
                then_status_ptr,
            );
            if if_cursor < 0 {
                return -1;
            };
            store_i32(else_kind_ptr, 0);
            store_i32(else_data0_ptr, 0);
            store_i32(else_data1_ptr, 0);
            store_i32(else_status_ptr, 1);
            store_i32(literal_ptr, if_cursor);
            if_cursor = expect_keyword_else(base, len, if_cursor);
            if if_cursor >= 0 {
                if_cursor = skip_whitespace(base, len, if_cursor);
                if if_cursor >= len {
                    return -1;
                };
                let after_else_byte: i32 = load_u8(base + if_cursor);
                if after_else_byte == '{' {
                    if_cursor = expect_char(base, len, if_cursor, '{');
                    if if_cursor < 0 {
                        return -1;
                    };
                    if_cursor = parse_block_expression_body(
                        base,
                        len,
                        if_cursor,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        locals_table_ptr,
                        locals_stack_count_ptr,
                        locals_next_index_ptr,
                        literal_ptr,
                        ident_start_ptr,
                        ident_len_ptr,
                        else_nested_base,
                        1,
                        loop_depth_ptr,
                        else_kind_ptr,
                        else_data0_ptr,
                        else_data1_ptr,
                        else_status_ptr,
                    );
                    if if_cursor < 0 {
                        return -1;
                    };
                } else {
                    let else_if_cursor: i32 = if_cursor;
                    let maybe_else_if: i32 = expect_keyword_if(base, len, else_if_cursor);
                    if maybe_else_if < 0 {
                        return -1;
                    };
                    if_cursor = parse_expression(
                        base,
                        len,
                        else_if_cursor,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        locals_table_ptr,
                        locals_stack_count_ptr,
                        locals_next_index_ptr,
                        else_nested_base,
                        loop_depth_ptr,
                        else_kind_ptr,
                        else_data0_ptr,
                        else_data1_ptr,
                    );
                    if if_cursor < 0 {
                        return -1;
                    };
                    store_i32(else_status_ptr, -1);
                    if_cursor = skip_whitespace(base, len, if_cursor);
                };
            } else {
                if_cursor = load_i32(literal_ptr);
            };
            let cond_kind: i32 = load_i32(cond_kind_ptr);
            let cond_data0: i32 = load_i32(cond_data0_ptr);
            let cond_data1: i32 = load_i32(cond_data1_ptr);
            let cond_index: i32 =
                expression_node_from_parts(ast_base, cond_kind, cond_data0, cond_data1);
            if cond_index < 0 {
                return -1;
            };
            let then_kind: i32 = load_i32(then_kind_ptr);
            let then_data0: i32 = load_i32(then_data0_ptr);
            let then_data1: i32 = load_i32(then_data1_ptr);
            let then_index: i32 =
                expression_node_from_parts(ast_base, then_kind, then_data0, then_data1);
            if then_index < 0 {
                return -1;
            };
            let else_kind: i32 = load_i32(else_kind_ptr);
            let else_data0: i32 = load_i32(else_data0_ptr);
            let else_data1: i32 = load_i32(else_data1_ptr);
            let else_index: i32 =
                expression_node_from_parts(ast_base, else_kind, else_data0, else_data1);
            if else_index < 0 {
                return -1;
            };
            if load_i32(else_status_ptr) < 0 {
                let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
                let else_has_value: i32 = if else_diverges { 0 } else { 1 };
                store_i32(else_status_ptr, else_has_value);
            };
            let then_has_value: i32 = load_i32(then_status_ptr);
            let else_has_value: i32 = load_i32(else_status_ptr);
            let if_index: i32 = ast_expr_alloc_if(ast_base, cond_index, then_index, else_index);
            if if_index < 0 {
                return -1;
            };
            store_i32(out_kind_ptr, 2);
            store_i32(out_data0_ptr, if_index);
            let both_have_values: i32 = if then_has_value != 0 && else_has_value != 0 {
                0
            } else {
                -1
            };
            store_i32(out_data1_ptr, both_have_values);
            return skip_whitespace(base, len, if_cursor);
        };
    };
    if first_byte == '[' {
        let element_kind_ptr: i32 = nested_temp_base;
        let element_data0_ptr: i32 = nested_temp_base + 4;
        let element_data1_ptr: i32 = nested_temp_base + 8;
        let values_list_ptr: i32 = nested_temp_base + 16;
        let element_temp_base: i32 =
            nested_temp_base + 16 + MAX_ARRAY_LITERAL_ELEMENTS * WORD_SIZE + 64;
        let mut array_cursor: i32 = cursor + 1;
        array_cursor = skip_whitespace(base, len, array_cursor);
        array_cursor = parse_expression(
            base,
            len,
            array_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            element_temp_base,
            loop_depth_ptr,
            element_kind_ptr,
            element_data0_ptr,
            element_data1_ptr,
        );
        if array_cursor < 0 {
            return -1;
        };
        let element_kind: i32 = load_i32(element_kind_ptr);
        let element_data0: i32 = load_i32(element_data0_ptr);
        let element_data1: i32 = load_i32(element_data1_ptr);
        let element_index: i32 =
            expression_node_from_parts(ast_base, element_kind, element_data0, element_data1);
        if element_index < 0 {
            return -1;
        };
        array_cursor = skip_whitespace(base, len, array_cursor);
        if array_cursor >= len {
            return -1;
        };
        let mut delimiter: i32 = load_u8(base + array_cursor);
        if delimiter == ';' {
            array_cursor = expect_char(base, len, array_cursor, ';');
            if array_cursor < 0 {
                return -1;
            };
            array_cursor = skip_whitespace(base, len, array_cursor);
            array_cursor = parse_i32_literal(base, len, array_cursor, literal_ptr);
            if array_cursor < 0 {
                return -1;
            };
            let length: i32 = load_i32(literal_ptr);
            if length < 0 {
                return -1;
            };
            array_cursor = skip_whitespace(base, len, array_cursor);
            array_cursor = expect_char(base, len, array_cursor, ']');
            if array_cursor < 0 {
                return -1;
            };
            let expr_index: i32 = ast_expr_alloc_array_repeat(ast_base, element_index, length);
            if expr_index < 0 {
                return -1;
            };
            store_i32(out_kind_ptr, 35);
            store_i32(out_data0_ptr, expr_index);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, array_cursor);
        };
        store_i32(values_list_ptr, element_index);
        let mut element_count: i32 = 1;
        loop {
            if delimiter == ',' {
                array_cursor = skip_whitespace(base, len, array_cursor + 1);
                if array_cursor >= len {
                    return -1;
                };
                let after_comma: i32 = load_u8(base + array_cursor);
                if after_comma == ']' {
                    array_cursor = array_cursor + 1;
                    break;
                };
                array_cursor = parse_expression(
                    base,
                    len,
                    array_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    element_temp_base,
                    loop_depth_ptr,
                    element_kind_ptr,
                    element_data0_ptr,
                    element_data1_ptr,
                );
                if array_cursor < 0 {
                    return -1;
                };
                let next_kind: i32 = load_i32(element_kind_ptr);
                let next_data0: i32 = load_i32(element_data0_ptr);
                let next_data1: i32 = load_i32(element_data1_ptr);
                let next_index: i32 = expression_node_from_parts(
                    ast_base,
                    next_kind,
                    next_data0,
                    next_data1,
                );
                if next_index < 0 {
                    return -1;
                };
                if element_count >= MAX_ARRAY_LITERAL_ELEMENTS {
                    return -1;
                };
                store_i32(values_list_ptr + element_count * WORD_SIZE, next_index);
                element_count = element_count + 1;
                array_cursor = skip_whitespace(base, len, array_cursor);
                if array_cursor >= len {
                    return -1;
                };
                delimiter = load_u8(base + array_cursor);
                continue;
            };
            if delimiter == ']' {
                array_cursor = array_cursor + 1;
                break;
            };
            return -1;
        };
        let metadata_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if metadata_ptr < 0 {
            return -1;
        };
        let mut copy_idx: i32 = 0;
        loop {
            if copy_idx >= element_count {
                break;
            };
            let value_index: i32 = load_i32(values_list_ptr + copy_idx * WORD_SIZE);
            store_i32(metadata_ptr + copy_idx * WORD_SIZE, value_index);
            copy_idx = copy_idx + 1;
        };
        let expr_index: i32 = ast_expr_alloc_array_list(ast_base, metadata_ptr, element_count);
        if expr_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, 37);
        store_i32(out_data0_ptr, expr_index);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, array_cursor);
    };
    if first_byte == '(' {
        let mut paren_cursor: i32 = cursor + 1;
        paren_cursor = skip_whitespace(base, len, paren_cursor);
        paren_cursor = parse_expression(
            base,
            len,
            paren_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            out_kind_ptr,
            out_data0_ptr,
            out_data1_ptr,
        );
        if paren_cursor < 0 {
            return -1;
        };
        paren_cursor = skip_whitespace(base, len, paren_cursor);
        paren_cursor = expect_char(base, len, paren_cursor, ')');
        if paren_cursor < 0 {
            return -1;
        };
        return skip_whitespace(base, len, paren_cursor);
    };
    if first_byte == '"' {
        let values_list_ptr: i32 = nested_temp_base;
        let mut string_cursor: i32 = cursor + 1;
        let mut element_count: i32 = 0;
        loop {
            if string_cursor >= len {
                return -1;
            };
            let byte: i32 = load_u8(base + string_cursor);
            if byte == '"' {
                string_cursor = string_cursor + 1;
                break;
            };
            let mut value: i32 = byte;
            string_cursor = string_cursor + 1;
            if value == '\\' {
                if string_cursor >= len {
                    return -1;
                };
                let escape: i32 = load_u8(base + string_cursor);
                value = if escape == 'n' {
                    '\n'
                } else if escape == 'r' {
                    '\r'
                } else if escape == 't' {
                    '\t'
                } else if escape == '0' {
                    '\0'
                } else if escape == '\\' {
                    '\\'
                } else if escape == '\'' {
                    '\''
                } else if escape == 34 {
                    34
                } else {
                    return -1;
                };
                string_cursor = string_cursor + 1;
            } else if value == '\n' || value == '\r' {
                return -1;
            };
            if element_count >= MAX_ARRAY_LITERAL_ELEMENTS {
                return -1;
            };
            let literal_index: i32 =
                ast_expr_alloc_literal(ast_base, value, BUILTIN_TYPE_ID_U8);
            if literal_index < 0 {
                return -1;
            };
            store_i32(values_list_ptr + element_count * WORD_SIZE, literal_index);
            element_count = element_count + 1;
        };
        let expr_index: i32 = if element_count == 0 {
            let zero_index: i32 = ast_expr_alloc_literal(ast_base, 0, BUILTIN_TYPE_ID_U8);
            if zero_index < 0 {
                return -1;
            };
            ast_expr_alloc_array_repeat(ast_base, zero_index, 0)
        } else {
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
            if metadata_ptr < 0 {
                return -1;
            };
            let mut copy_idx: i32 = 0;
            loop {
                if copy_idx >= element_count {
                    break;
                };
                let value_index: i32 =
                    load_i32(values_list_ptr + copy_idx * WORD_SIZE);
                store_i32(metadata_ptr + copy_idx * WORD_SIZE, value_index);
                copy_idx = copy_idx + 1;
            };
            ast_expr_alloc_array_list(ast_base, metadata_ptr, element_count)
        };
        if expr_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, if element_count == 0 { 35 } else { 37 });
        store_i32(out_data0_ptr, expr_index);
        store_i32(out_data1_ptr, 0);
        return skip_whitespace(base, len, string_cursor);
    };
    if first_byte == '\'' {
        let next_cursor: i32 = parse_char_literal(base, len, cursor, literal_ptr);
        if next_cursor < 0 {
            return -1;
        };
        let value: i32 = load_i32(literal_ptr);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, value);
        store_i32(out_data1_ptr, BUILTIN_TYPE_ID_I32);
        return skip_whitespace(base, len, next_cursor);
    };
    if first_byte == '-' || is_digit(first_byte) {
        let next_cursor: i32 = parse_i32_literal(base, len, cursor, literal_ptr);
        if next_cursor < 0 {
            return -1;
        };
        let value: i32 = load_i32(literal_ptr);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, value);
        store_i32(out_data1_ptr, BUILTIN_TYPE_ID_I32);
        return skip_whitespace(base, len, next_cursor);
    };
    if first_byte == 't' {
        let next_cursor: i32 = expect_keyword_true(base, len, cursor);
        if next_cursor >= 0 {
            store_i32(out_kind_ptr, 0);
            store_i32(out_data0_ptr, 1);
            store_i32(out_data1_ptr, BUILTIN_TYPE_ID_BOOL);
            return skip_whitespace(base, len, next_cursor);
        };
    };
    if first_byte == 'f' {
        let next_cursor: i32 = expect_keyword_false(base, len, cursor);
        if next_cursor >= 0 {
            store_i32(out_kind_ptr, 0);
            store_i32(out_data0_ptr, 0);
            store_i32(out_data1_ptr, BUILTIN_TYPE_ID_BOOL);
            return skip_whitespace(base, len, next_cursor);
        };
    };
    if !is_identifier_start(first_byte) {
        return -1;
    };
    let mut next_cursor: i32 = parse_identifier(base, len, cursor, ident_start_ptr, ident_len_ptr);
    if next_cursor < 0 {
        return -1;
    };
    let ident_start: i32 = load_i32(ident_start_ptr);
    let ident_len: i32 = load_i32(ident_len_ptr);
    next_cursor = skip_whitespace(base, len, next_cursor);
    if next_cursor < len {
        let next_byte: i32 = load_u8(base + next_cursor);
        if next_byte == '(' {
            let mut call_cursor: i32 = next_cursor + 1;
            call_cursor = skip_whitespace(base, len, call_cursor);
            let args_limit: i32 = MAX_PARAMS;
            let arg_kind_ptr: i32 = nested_temp_base;
            let arg_data0_ptr: i32 = nested_temp_base + 4;
            let arg_data1_ptr: i32 = nested_temp_base + 8;
            let args_list_ptr: i32 = nested_temp_base + 16;
            let arg_nested_base: i32 = nested_temp_base + 160;
            let mut arg_count: i32 = 0;
            if call_cursor < len {
                let maybe_close: i32 = load_u8(base + call_cursor);
                if maybe_close == ')' {
                    call_cursor = call_cursor + 1;
                } else {
                    loop {
                        if arg_count >= args_limit {
                            return -1;
                        };
                        call_cursor = parse_expression(
                            base,
                            len,
                            call_cursor,
                            ast_base,
                            params_table_ptr,
                            params_count,
                            locals_table_ptr,
                            locals_stack_count_ptr,
                            locals_next_index_ptr,
                            arg_nested_base,
                            loop_depth_ptr,
                            arg_kind_ptr,
                            arg_data0_ptr,
                            arg_data1_ptr,
                        );
                        if call_cursor < 0 {
                            return -1;
                        };
                        let arg_kind: i32 = load_i32(arg_kind_ptr);
                        let arg_data0: i32 = load_i32(arg_data0_ptr);
                        let arg_data1: i32 = load_i32(arg_data1_ptr);
                        let arg_index: i32 =
                            expression_node_from_parts(ast_base, arg_kind, arg_data0, arg_data1);
                        if arg_index < 0 {
                            return -1;
                        };
                        store_i32(args_list_ptr + arg_count * 4, arg_index);
                        arg_count = arg_count + 1;
                        call_cursor = skip_whitespace(base, len, call_cursor);
                        if call_cursor >= len {
                            return -1;
                        };
                        let delimiter: i32 = load_u8(base + call_cursor);
                        if delimiter == ',' {
                            call_cursor = skip_whitespace(base, len, call_cursor + 1);
                            if call_cursor >= len {
                                return -1;
                            };
                            let after_comma: i32 = load_u8(base + call_cursor);
                            if after_comma == ')' {
                                call_cursor = call_cursor + 1;
                                break;
                            };
                            continue;
                        };
                        if delimiter == ')' {
                            call_cursor = call_cursor + 1;
                            break;
                        };
                        return -1;
                    };
                };
            } else {
                return -1;
            };
            let intrinsic_kind: i32 = identify_intrinsic(base, len, ident_start, ident_len);
            if intrinsic_kind != INTRINSIC_KIND_NONE {
                if intrinsic_kind == INTRINSIC_KIND_LOAD_U8
                    || intrinsic_kind == INTRINSIC_KIND_LOAD_U16
                    || intrinsic_kind == INTRINSIC_KIND_LOAD_I32
                {
                    if arg_count != 1 {
                        return -1;
                    };
                    let arg_index: i32 = load_i32(args_list_ptr);
                    let expr_index: i32 = if intrinsic_kind == INTRINSIC_KIND_LOAD_U8 {
                        ast_expr_alloc_load_u8(ast_base, arg_index)
                    } else if intrinsic_kind == INTRINSIC_KIND_LOAD_U16 {
                        ast_expr_alloc_load_u16(ast_base, arg_index)
                    } else {
                        ast_expr_alloc_load_i32(ast_base, arg_index)
                    };
                    if expr_index < 0 {
                        return -1;
                    };
                    store_i32(out_kind_ptr, 29);
                    store_i32(out_data0_ptr, expr_index);
                    store_i32(out_data1_ptr, 0);
                    return skip_whitespace(base, len, call_cursor);
                };
                if intrinsic_kind == INTRINSIC_KIND_STORE_U8
                    || intrinsic_kind == INTRINSIC_KIND_STORE_U16
                    || intrinsic_kind == INTRINSIC_KIND_STORE_I32
                {
                    if arg_count != 2 {
                        return -1;
                    };
                    let ptr_index: i32 = load_i32(args_list_ptr);
                    let value_index: i32 = load_i32(args_list_ptr + 4);
                    let expr_index: i32 = if intrinsic_kind == INTRINSIC_KIND_STORE_U8 {
                        ast_expr_alloc_store_u8(ast_base, ptr_index, value_index)
                    } else if intrinsic_kind == INTRINSIC_KIND_STORE_U16 {
                        ast_expr_alloc_store_u16(ast_base, ptr_index, value_index)
                    } else {
                        ast_expr_alloc_store_i32(ast_base, ptr_index, value_index)
                    };
                    if expr_index < 0 {
                        return -1;
                    };
                    store_i32(out_kind_ptr, 32);
                    store_i32(out_data0_ptr, expr_index);
                    store_i32(out_data1_ptr, 0);
                    return skip_whitespace(base, len, call_cursor);
                };
                if intrinsic_kind == INTRINSIC_KIND_LEN {
                    if arg_count != 1 {
                        return -1;
                    };
                    let array_index: i32 = load_i32(args_list_ptr);
                    let expr_index: i32 = ast_expr_alloc_array_len(ast_base, array_index);
                    if expr_index < 0 {
                        return -1;
                    };
                    store_i32(out_kind_ptr, 38);
                    store_i32(out_data0_ptr, expr_index);
                    store_i32(out_data1_ptr, 0);
                    return skip_whitespace(base, len, call_cursor);
                };
                return -1;
            };
            let name_ptr: i32 = ast_store_name(ast_base, base, ident_start, ident_len);
            if name_ptr < 0 {
                return -1;
            };
            let metadata_words: i32 = 4 + arg_count;
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, metadata_words);
            if metadata_ptr < 0 {
                return -1;
            };
            store_i32(metadata_ptr, name_ptr);
            store_i32(metadata_ptr + 4, ident_len);
            store_i32(metadata_ptr + 8, arg_count);
            store_i32(metadata_ptr + 12, -1);
            let mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= arg_count {
                    break;
                };
                let arg_value: i32 = load_i32(args_list_ptr + arg_idx * 4);
                store_i32(metadata_ptr + 16 + arg_idx * 4, arg_value);
                arg_idx = arg_idx + 1;
            };
            store_i32(out_kind_ptr, 1);
            store_i32(out_data0_ptr, metadata_ptr);
            store_i32(out_data1_ptr, 0);
            return skip_whitespace(base, len, call_cursor);
        };
    };
    let param_index: i32 =
        find_parameter_index(base, params_table_ptr, params_count, ident_start, ident_len);
    if param_index >= 0 {
        let param_types_table_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
        let param_type_id: i32 = load_i32(param_types_table_ptr + param_index * 4);
        store_i32(out_kind_ptr, 6);
        store_i32(out_data0_ptr, param_index);
        store_i32(out_data1_ptr, param_type_id);
        return skip_whitespace(base, len, next_cursor);
    };
    let locals_stack: i32 = load_i32(locals_stack_count_ptr);
    let local_entry_index: i32 = find_local_entry_index(
        base,
        locals_table_ptr,
        locals_stack,
        ident_start,
        ident_len,
    );
    if local_entry_index < 0 {
        let constant_entry_index: i32 =
            find_constant_entry_index(base, ast_base, ident_start, ident_len);
        if constant_entry_index < 0 {
            return -1;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, constant_entry_index);
        let const_value: i32 = load_i32(const_entry_ptr + 8);
        let const_type: i32 = load_i32(const_entry_ptr + 12);
        store_i32(out_kind_ptr, 0);
        store_i32(out_data0_ptr, const_value);
        store_i32(out_data1_ptr, const_type);
        return skip_whitespace(base, len, next_cursor);
    };
    let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, local_entry_index);
    let local_index: i32 = locals_entry_local_index(entry_ptr);
    let local_type_id: i32 = locals_entry_type_id(entry_ptr);
    store_i32(out_kind_ptr, 8);
    store_i32(out_data0_ptr, local_index);
    store_i32(out_data1_ptr, local_type_id);
    skip_whitespace(base, len, next_cursor)
}

fn parse_unary_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    ident_start_ptr: i32,
    ident_len_ptr: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    nested_temp_base: i32,
) -> i32 {
    let mut current_cursor: i32 = cursor;
    let mut not_count: i32 = 0;
    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '!' {
            break;
        };
        not_count = not_count + 1;
        current_cursor = skip_whitespace(base, len, current_cursor + 1);
    };

    let mut resolved_cursor: i32 = parse_basic_expression(
        base,
        len,
        current_cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        literal_ptr,
        ident_start_ptr,
        ident_len_ptr,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
        nested_temp_base,
    );
    if resolved_cursor < 0 {
        return -1;
    };

    let index_kind_ptr: i32 = nested_temp_base;
    let index_data0_ptr: i32 = nested_temp_base + 4;
    let index_data1_ptr: i32 = nested_temp_base + 8;
    let index_temp_base: i32 = nested_temp_base + 32;

    loop {
        if resolved_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + resolved_cursor);
        if next_byte != '[' {
            break;
        };
        let mut index_cursor: i32 = skip_whitespace(base, len, resolved_cursor + 1);
        index_cursor = parse_expression(
            base,
            len,
            index_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            index_temp_base,
            loop_depth_ptr,
            index_kind_ptr,
            index_data0_ptr,
            index_data1_ptr,
        );
        if index_cursor < 0 {
            return -1;
        };
        index_cursor = skip_whitespace(base, len, index_cursor);
        index_cursor = expect_char(base, len, index_cursor, ']');
        if index_cursor < 0 {
            return -1;
        };

        let array_kind: i32 = load_i32(out_kind_ptr);
        let array_data0: i32 = load_i32(out_data0_ptr);
        let array_data1: i32 = load_i32(out_data1_ptr);
        let array_expr_index: i32 =
            expression_node_from_parts(ast_base, array_kind, array_data0, array_data1);
        if array_expr_index < 0 {
            return -1;
        };

        let idx_kind: i32 = load_i32(index_kind_ptr);
        let idx_data0: i32 = load_i32(index_data0_ptr);
        let idx_data1: i32 = load_i32(index_data1_ptr);
        let idx_expr_index: i32 =
            expression_node_from_parts(ast_base, idx_kind, idx_data0, idx_data1);
        if idx_expr_index < 0 {
            return -1;
        };

        let get_index: i32 = ast_expr_alloc_array_get(ast_base, array_expr_index, idx_expr_index);
        if get_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, get_index);
        store_i32(out_data1_ptr, 0);

        resolved_cursor = skip_whitespace(base, len, index_cursor);
    };

    if (not_count & 1) != 0 {
        let value_kind: i32 = load_i32(out_kind_ptr);
        let value_data0: i32 = load_i32(out_data0_ptr);
        let value_data1: i32 = load_i32(out_data1_ptr);
        let value_index: i32 =
            expression_node_from_parts(ast_base, value_kind, value_data0, value_data1);
        if value_index < 0 {
            return -1;
        };
        let not_index: i32 = ast_expr_alloc_logical_not(ast_base, value_index);
        if not_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, not_index);
        store_i32(out_data1_ptr, 0);
    };

    loop {
        resolved_cursor = skip_whitespace(base, len, resolved_cursor);
        let as_cursor: i32 = expect_keyword_as(base, len, resolved_cursor);
        if as_cursor < 0 {
            break;
        };
        let mut type_cursor: i32 = skip_whitespace(base, len, as_cursor);
        type_cursor = parse_type(base, len, type_cursor, ast_base, literal_ptr);
        if type_cursor < 0 {
            return -1;
        };
        let target_type_id: i32 = load_i32(literal_ptr);
        let value_kind: i32 = load_i32(out_kind_ptr);
        let value_data0: i32 = load_i32(out_data0_ptr);
        let value_data1: i32 = load_i32(out_data1_ptr);
        let value_index: i32 =
            expression_node_from_parts(ast_base, value_kind, value_data0, value_data1);
        if value_index < 0 {
            return -1;
        };
        let cast_index: i32 = ast_expr_alloc_cast(ast_base, value_index, target_type_id);
        if cast_index < 0 {
            return -1;
        };
        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, cast_index);
        store_i32(out_data1_ptr, 0);
        resolved_cursor = type_cursor;
    };

    skip_whitespace(base, len, resolved_cursor)
}

fn parse_multiplicative_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let literal_ptr: i32 = temp_base;
    let ident_start_ptr: i32 = temp_base + 4;
    let ident_len_ptr: i32 = temp_base + 8;
    let next_kind_ptr: i32 = temp_base + 12;
    let next_data0_ptr: i32 = temp_base + 16;
    let next_data1_ptr: i32 = temp_base + 20;
    let nested_temp_base: i32 = temp_base + 32;

    let mut current_cursor: i32 = parse_unary_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        literal_ptr,
        ident_start_ptr,
        ident_len_ptr,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
        nested_temp_base,
    );
    if current_cursor < 0 {
        return -1;
    };

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '*' && next_byte != '/' {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_unary_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            literal_ptr,
            ident_start_ptr,
            ident_len_ptr,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
            nested_temp_base,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 = expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 = expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == '*' {
            ast_expr_alloc_mul(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_div(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_additive_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let mut current_cursor: i32 = parse_multiplicative_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;
    let nested_temp_base: i32 = temp_base + 32;

    loop {
        if current_cursor >= len {
            break;
        };
        let next_byte: i32 = load_u8(base + current_cursor);
        if next_byte != '+' && next_byte != '-' {
            break;
        };
        let operator: i32 = next_byte;
        current_cursor = current_cursor + 1;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_multiplicative_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 = expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 = expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if operator == '+' {
            ast_expr_alloc_add(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_sub(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_shift_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_additive_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        let second: i32 = load_u8(base + current_cursor + 1);
        let mut op_kind: i32 = -1;
        if first == '<' && second == '<' {
            op_kind = 0;
        } else if first == '>' && second == '>' {
            op_kind = 1;
        } else {
            break;
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_additive_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if op_kind == 0 {
            ast_expr_alloc_shl(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_shr_s(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_relational_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_shift_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        let mut relation_op: i32 = -1;
        let mut consume: i32 = 1;
        if operator_byte == '<' {
            if current_cursor + 1 < len {
                let next: i32 = load_u8(base + current_cursor + 1);
                if next == '=' {
                    relation_op = 2;
                    consume = 2;
                } else if next == '<' {
                    return -1;
                } else {
                    relation_op = 0;
                };
            } else {
                relation_op = 0;
            };
        } else if operator_byte == '>' {
            if current_cursor + 1 < len {
                let next: i32 = load_u8(base + current_cursor + 1);
                if next == '=' {
                    relation_op = 3;
                    consume = 2;
                } else if next == '>' {
                    return -1;
                } else {
                    relation_op = 1;
                };
            } else {
                relation_op = 1;
            };
        };

        if relation_op < 0 {
            break;
        };

        current_cursor = current_cursor + consume;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_additive_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 = expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 = expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if relation_op == 0 {
            ast_expr_alloc_lt(ast_base, left_index, right_index)
        } else if relation_op == 1 {
            ast_expr_alloc_gt(ast_base, left_index, right_index)
        } else if relation_op == 2 {
            ast_expr_alloc_le(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_ge(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_equality_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_relational_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        let next_byte: i32 = load_u8(base + current_cursor + 1);
        let mut equality_op: i32 = -1;
        if operator_byte == '=' {
            if next_byte != '=' {
                break;
            };
            equality_op = 0;
        } else if operator_byte == '!' {
            if next_byte != '=' {
                break;
            };
            equality_op = 1;
        } else {
            break;
        };

        current_cursor = current_cursor + 2;
        current_cursor = skip_whitespace(base, len, current_cursor);
        current_cursor = parse_relational_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 = expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 = expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = if equality_op == 0 {
            ast_expr_alloc_eq(ast_base, left_index, right_index)
        } else {
            ast_expr_alloc_ne(ast_base, left_index, right_index)
        };
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_bitwise_and_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_equality_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        if operator_byte != '&' {
            break;
        };
        if current_cursor + 1 < len {
            let next: i32 = load_u8(base + current_cursor + 1);
            if next == '&' {
                break;
            };
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 1);
        current_cursor = parse_equality_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_bitwise_and(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_bitwise_or_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_bitwise_and_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor >= len {
            break;
        };
        let operator_byte: i32 = load_u8(base + current_cursor);
        if operator_byte != '|' {
            break;
        };
        if current_cursor + 1 < len {
            let next: i32 = load_u8(base + current_cursor + 1);
            if next == '|' {
                break;
            };
        };

        current_cursor = skip_whitespace(base, len, current_cursor + 1);
        current_cursor = parse_bitwise_and_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_bitwise_or(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_logical_and_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_bitwise_or_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        if first != '&' {
            break;
        };
        let second: i32 = load_u8(base + current_cursor + 1);
        if second != '&' {
            return -1;
        };
        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_bitwise_or_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_logical_and(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_logical_or_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    let nested_temp_base: i32 = temp_base + 32;
    let mut current_cursor: i32 = parse_logical_and_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        nested_temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    );
    if current_cursor < 0 {
        return -1;
    };

    let next_kind_ptr: i32 = temp_base;
    let next_data0_ptr: i32 = temp_base + 4;
    let next_data1_ptr: i32 = temp_base + 8;

    loop {
        if current_cursor + 1 >= len {
            break;
        };
        let first: i32 = load_u8(base + current_cursor);
        if first != '|' {
            break;
        };
        let second: i32 = load_u8(base + current_cursor + 1);
        if second != '|' {
            return -1;
        };
        current_cursor = skip_whitespace(base, len, current_cursor + 2);
        current_cursor = parse_logical_and_expression(
            base,
            len,
            current_cursor,
            ast_base,
            params_table_ptr,
            params_count,
            locals_table_ptr,
            locals_stack_count_ptr,
            locals_next_index_ptr,
            nested_temp_base,
            loop_depth_ptr,
            next_kind_ptr,
            next_data0_ptr,
            next_data1_ptr,
        );
        if current_cursor < 0 {
            return -1;
        };

        let current_kind: i32 = load_i32(out_kind_ptr);
        let current_data0: i32 = load_i32(out_data0_ptr);
        let current_data1: i32 = load_i32(out_data1_ptr);
        let left_index: i32 =
            expression_node_from_parts(ast_base, current_kind, current_data0, current_data1);
        if left_index < 0 {
            return -1;
        };

        let right_kind: i32 = load_i32(next_kind_ptr);
        let right_data0: i32 = load_i32(next_data0_ptr);
        let right_data1: i32 = load_i32(next_data1_ptr);
        let right_index: i32 =
            expression_node_from_parts(ast_base, right_kind, right_data0, right_data1);
        if right_index < 0 {
            return -1;
        };

        let new_index: i32 = ast_expr_alloc_logical_or(ast_base, left_index, right_index);
        if new_index < 0 {
            return -1;
        };

        store_i32(out_kind_ptr, 2);
        store_i32(out_data0_ptr, new_index);
        store_i32(out_data1_ptr, 0);
    };

    current_cursor
}

fn parse_expression(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    temp_base: i32,
    loop_depth_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
) -> i32 {
    parse_logical_or_expression(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        params_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        temp_base,
        loop_depth_ptr,
        out_kind_ptr,
        out_data0_ptr,
        out_data1_ptr,
    )
}

fn parse_function(base: i32, len: i32, offset: i32, ast_base: i32, func_index: i32) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, offset);
    cursor = expect_keyword_fn(base, len, cursor);
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let name_start_ptr: i32 = temp_base;
    let name_len_ptr: i32 = temp_base + 4;
    let params_count_ptr: i32 = temp_base + 8;
    let params_table_ptr: i32 = temp_base + 12;
    let params_table_end: i32 = params_table_ptr + MAX_PARAMS * 8;
    let param_types_table_ptr: i32 = params_table_end;
    let param_name_start_ptr: i32 = param_types_table_ptr + MAX_PARAMS * 4;
    let param_name_len_ptr: i32 = param_name_start_ptr + 4;
    let param_type_temp_ptr: i32 = param_name_len_ptr + 4;
    let expr_kind_ptr: i32 = param_type_temp_ptr + 4;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_kind_ptr + 8;
    let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
    let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
    let locals_next_index_ptr: i32 = locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
    let expr_temp_base: i32 = locals_next_index_ptr + 4;
    cursor = parse_identifier(base, len, cursor, name_start_ptr, name_len_ptr);
    if cursor < 0 {
        return -1;
    };
    let name_start: i32 = load_i32(name_start_ptr);
    let name_len: i32 = load_i32(name_len_ptr);

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_start: i32 = load_i32(entry_ptr);
        let const_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, const_start, const_len, name_start, name_len) {
            return -1;
        };
        const_idx = const_idx + 1;
    };

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, '(');
    if cursor < 0 {
        return -1;
    };
    cursor = skip_whitespace(base, len, cursor);
    store_i32(params_count_ptr, 0);
    let mut param_count: i32 = 0;
    loop {
        if cursor >= len {
            return -1;
        };
        let next_byte: i32 = load_u8(base + cursor);
        if next_byte == ')' {
            cursor = cursor + 1;
            break;
        };
        if param_count >= MAX_PARAMS {
            return -1;
        };
        cursor = parse_identifier(base, len, cursor, param_name_start_ptr, param_name_len_ptr);
        if cursor < 0 {
            return -1;
        };
        let param_start: i32 = load_i32(param_name_start_ptr);
        let param_len: i32 = load_i32(param_name_len_ptr);
        let mut existing_idx: i32 = 0;
        loop {
            if existing_idx >= param_count {
                break;
            };
            let existing_ptr: i32 = params_table_ptr + existing_idx * 8;
            let existing_start: i32 = load_i32(existing_ptr);
            let existing_len: i32 = load_i32(existing_ptr + 4);
            if identifiers_match_source(base, existing_start, existing_len, param_start, param_len) {
                return -1;
            };
            existing_idx = existing_idx + 1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ':');
        if cursor < 0 {
            return -1;
        };
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_type(base, len, cursor, ast_base, param_type_temp_ptr);
        if cursor < 0 {
            return -1;
        };
        let param_type_id: i32 = load_i32(param_type_temp_ptr);
        store_i32(params_table_ptr + param_count * 8, param_start);
        store_i32(params_table_ptr + param_count * 8 + 4, param_len);
        store_i32(param_types_table_ptr + param_count * 4, param_type_id);
        param_count = param_count + 1;
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            return -1;
        };
        let delimiter: i32 = load_u8(base + cursor);
        if delimiter == ',' {
            cursor = skip_whitespace(base, len, cursor + 1);
            if cursor >= len {
                return -1;
            };
            let maybe_close: i32 = load_u8(base + cursor);
            if maybe_close == ')' {
                cursor = cursor + 1;
                break;
            };
            continue;
        };
        if delimiter == ')' {
            cursor = cursor + 1;
            break;
        };
        return -1;
    };
    store_i32(params_count_ptr, param_count);
    store_i32(locals_stack_count_ptr, 0);
    store_i32(locals_next_index_ptr, 0);
    cursor = skip_whitespace(base, len, cursor);

    let mut block_allow_empty: i32 = 0;
    let mut has_return_type: bool = false;
    let mut return_type_id: i32 = -1;
    if cursor < len {
        let maybe_arrow: i32 = load_u8(base + cursor);
        if maybe_arrow == '-' {
            has_return_type = true;
            cursor = expect_char(base, len, cursor, '-');
            if cursor < 0 {
                return -1;
            };
            cursor = expect_char(base, len, cursor, '>');
            if cursor < 0 {
                return -1;
            };
            cursor = skip_whitespace(base, len, cursor);
            cursor = parse_type(base, len, cursor, ast_base, param_type_temp_ptr);
            if cursor < 0 {
                return -1;
            };
            return_type_id = load_i32(param_type_temp_ptr);
        };
    };
    if !has_return_type {
        block_allow_empty = 1;
        return_type_id = BUILTIN_TYPE_ID_I32;
    };

    cursor = skip_whitespace(base, len, cursor);
    cursor = expect_char(base, len, cursor, '{');
    if cursor < 0 {
        return -1;
    };

    let block_literal_ptr: i32 = expr_temp_base;
    let block_ident_start_ptr: i32 = expr_temp_base + 4;
    let block_ident_len_ptr: i32 = expr_temp_base + 8;
    let block_value_status_ptr: i32 = expr_temp_base + 12;
    let loop_depth_ptr: i32 = expr_temp_base + 16;
    let block_temp_base: i32 = expr_temp_base + 48;

    store_i32(loop_depth_ptr, 0);
    cursor = parse_block_expression_body(
        base,
        len,
        cursor,
        ast_base,
        params_table_ptr,
        param_count,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        block_literal_ptr,
        block_ident_start_ptr,
        block_ident_len_ptr,
        block_temp_base,
        block_allow_empty,
        loop_depth_ptr,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
        block_value_status_ptr,
    );
    if cursor < 0 {
        return -1;
    };

    let name_ptr: i32 = ast_store_name(ast_base, base, name_start, name_len);
    if name_ptr < 0 {
        return -1;
    };
    let body_kind: i32 = load_i32(expr_kind_ptr);
    let body_data0: i32 = load_i32(expr_data0_ptr);
    if body_kind < 0 {
        return -1;
    };
    let locals_total: i32 = load_i32(locals_next_index_ptr);
    let mut param_types_ptr: i32 = -1;
    if param_count > 0 {
        param_types_ptr = ast_call_data_alloc(ast_base, param_count);
        if param_types_ptr < 0 {
            return -1;
        };
        let mut copy_idx: i32 = 0;
        loop {
            if copy_idx >= param_count {
                break;
            };
            let type_id: i32 = load_i32(param_types_table_ptr + copy_idx * 4);
            store_i32(param_types_ptr + copy_idx * 4, type_id);
            copy_idx = copy_idx + 1;
        };
    };
    ast_write_function_entry(
        ast_base,
        func_index,
        name_ptr,
        name_len,
        param_count,
        body_kind,
        body_data0,
        locals_total,
        param_types_ptr,
        return_type_id,
    );
    cursor
}

fn parse_type_declaration(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    func_count: i32,
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, cursor);
    let mut type_cursor: i32 = expect_keyword_type(base, len, idx);
    if type_cursor < 0 {
        return -2;
    };
    if type_cursor >= len {
        return -1;
    };
    let after_keyword: i32 = load_u8(base + type_cursor);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, type_cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let ident_start_ptr: i32 = temp_base;
    let ident_len_ptr: i32 = ident_start_ptr + 4;
    let type_ptr: i32 = ident_len_ptr + 4;

    idx = parse_identifier(base, len, idx, ident_start_ptr, ident_len_ptr);
    if idx < 0 {
        return -1;
    };
    let name_start: i32 = load_i32(ident_start_ptr);
    let name_len: i32 = load_i32(ident_len_ptr);

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };
    if find_constant_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };
    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let func_name_ptr: i32 = load_i32(entry_ptr);
        let func_name_len: i32 = load_i32(entry_ptr + 4);
        if func_name_len == name_len {
            let mut match_idx: i32 = 0;
            let mut matches: bool = true;
            loop {
                if match_idx >= name_len {
                    break;
                };
                let func_byte: i32 = load_u8(func_name_ptr + match_idx);
                let type_byte: i32 = load_u8(base + name_start + match_idx);
                if func_byte != type_byte {
                    matches = false;
                    break;
                };
                match_idx = match_idx + 1;
            };
            if matches {
                return -1;
            };
        };
        func_idx = func_idx + 1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, '=');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_type(base, len, idx, ast_base, type_ptr);
    if idx < 0 {
        return -1;
    };
    let target_type_id: i32 = load_i32(type_ptr);
    if target_type_id < 0 {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ';');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);

    if ast_type_definition_append(ast_base, name_start, name_len, target_type_id) < 0 {
        return -1;
    };

    idx
}

fn parse_constant_declaration(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    func_count: i32,
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, cursor);
    let mut const_cursor: i32 = expect_keyword_const(base, len, idx);
    if const_cursor < 0 {
        return -2;
    };
    if const_cursor >= len {
        return -1;
    };
    let after_keyword: i32 = load_u8(base + const_cursor);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, const_cursor);

    let temp_base: i32 = ast_temp_base(ast_base);
    let params_table_ptr: i32 = temp_base;
    let ident_start_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
    let ident_len_ptr: i32 = ident_start_ptr + 4;
    let type_ptr: i32 = ident_len_ptr + 4;
    let expr_kind_ptr: i32 = type_ptr + 4;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_kind_ptr + 8;
    let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
    let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
    let locals_next_index_ptr: i32 = locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
    let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
    let expr_temp_base: i32 = loop_depth_ptr + 4;

    store_i32(locals_stack_count_ptr, 0);
    store_i32(locals_next_index_ptr, 0);
    store_i32(loop_depth_ptr, 0);

    idx = parse_identifier(base, len, idx, ident_start_ptr, ident_len_ptr);
    if idx < 0 {
        return -1;
    };
    let name_start: i32 = load_i32(ident_start_ptr);
    let name_len: i32 = load_i32(ident_len_ptr);

    if find_type_definition_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    if find_constant_entry_index(base, ast_base, name_start, name_len) >= 0 {
        return -1;
    };

    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let func_name_ptr: i32 = load_i32(entry_ptr);
        let func_name_len: i32 = load_i32(entry_ptr + 4);
        if func_name_len == name_len {
            let mut match_idx: i32 = 0;
            let mut matches: bool = true;
            loop {
                if match_idx >= name_len {
                    break;
                };
                let func_byte: i32 = load_u8(func_name_ptr + match_idx);
                let const_byte: i32 = load_u8(base + name_start + match_idx);
                if func_byte != const_byte {
                    matches = false;
                    break;
                };
                match_idx = match_idx + 1;
            };
            if matches {
                return -1;
            };
        };
        func_idx = func_idx + 1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ':');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_type(base, len, idx, ast_base, type_ptr);
    if idx < 0 {
        return -1;
    };
    let type_id: i32 = load_i32(type_ptr);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, '=');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = parse_expression(
        base,
        len,
        idx,
        ast_base,
        params_table_ptr,
        0,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        expr_temp_base,
        loop_depth_ptr,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
    );
    if idx < 0 {
        return -1;
    };
    let value_kind: i32 = load_i32(expr_kind_ptr);
    if value_kind != 0 {
        return -1;
    };
    let literal_value: i32 = load_i32(expr_data0_ptr);
    let literal_type: i32 = load_i32(expr_data1_ptr);
    if literal_type != type_id {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, ';');
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);

    let count_ptr: i32 = ast_constants_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_CONSTANTS_CAPACITY {
        return -1;
    };
    let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, count);
    store_i32(entry_ptr, name_start);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, literal_value);
    store_i32(entry_ptr + 12, type_id);
    store_i32(count_ptr, count + 1);

    idx
}

fn parse_program(base: i32, len: i32, ast_base: i32) -> i32 {
    let mut cursor: i32 = skip_whitespace(base, len, 0);
    let mut count: i32 = 0;
    loop {
        if cursor >= len {
            break;
        };
        let type_cursor: i32 = parse_type_declaration(base, len, cursor, ast_base, count);
        if type_cursor >= 0 {
            cursor = skip_whitespace(base, len, type_cursor);
            continue;
        };
        if type_cursor == -1 {
            return -1;
        };
        let const_cursor: i32 = parse_constant_declaration(base, len, cursor, ast_base, count);
        if const_cursor >= 0 {
            cursor = skip_whitespace(base, len, const_cursor);
            continue;
        };
        if const_cursor == -1 {
            return -1;
        };
        if count >= AST_MAX_FUNCTIONS {
            return -1;
        };
        cursor = parse_function(base, len, cursor, ast_base, count);
        if cursor < 0 {
            return -1;
        };
        count = count + 1;
        cursor = skip_whitespace(base, len, cursor);
    };
    store_i32(ast_functions_count_ptr(ast_base), count);
    count
}

fn identifiers_match(ptr_a: i32, len_a: i32, ptr_b: i32, len_b: i32) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(ptr_a + idx);
        let b_byte: i32 = load_u8(ptr_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn resolve_call_metadata(out_ptr: i32, ast_base: i32, metadata_ptr: i32, func_count: i32) -> i32 {
    if metadata_ptr < 0 {
        return -1;
    };
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        };
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
        if resolve_expression(out_ptr, ast_base, arg_expr_index, func_count) < 0 {
            return -1;
        };
        arg_idx = arg_idx + 1;
    };

    let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
    let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
    let mut target_idx: i32 = 0;
    let mut found_idx: i32 = -1;
    loop {
        if target_idx >= func_count {
            break;
        };
        let target_entry_ptr: i32 = ast_function_entry_ptr(ast_base, target_idx);
        let target_name_ptr: i32 = load_i32(target_entry_ptr);
        let target_name_len: i32 = load_i32(target_entry_ptr + 4);
        if call_name_len == target_name_len {
            if identifiers_match(call_name_ptr, call_name_len, target_name_ptr, target_name_len) {
                let expected_params: i32 = load_i32(target_entry_ptr + 8);
                if expected_params != arg_count {
                    return -1;
                };
                let param_types_ptr: i32 = load_i32(target_entry_ptr + 24);
                if arg_count > 0 {
                    if param_types_ptr < 0 {
                        return -1;
                    };
                };
                let mut verify_idx: i32 = 0;
                loop {
                    if verify_idx >= arg_count {
                        break;
                    };
                    let expected_type: i32 = if param_types_ptr >= 0 {
                        load_i32(param_types_ptr + verify_idx * 4)
                    } else {
                        -1
                    };
                    if expected_type < 0 {
                        return -1;
                    };
                    if resolve_type_id(out_ptr, ast_base, expected_type) < 0 {
                        return -1;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + verify_idx * 4);
                    let arg_type: i32 = ast_expr_type(ast_base, arg_expr_index);
                    if expected_type != arg_type {
                        return -1;
                    };
                    verify_idx = verify_idx + 1;
                };
                found_idx = target_idx;
                break;
            };
        };
        target_idx = target_idx + 1;
    };
    if found_idx < 0 {
        return -1;
    };
    store_i32(call_metadata_callee_index_ptr(metadata_ptr), found_idx);
    0
}

fn validate_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    if func_count <= 0 {
        return -1;
    };
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_type_id: i32 = load_i32(const_entry_ptr + 12);
        if resolve_type_id(out_ptr, ast_base, const_type_id) < 0 {
            return -1;
        };
        const_idx = const_idx + 1;
    };
    let mut main_count: i32 = 0;
    let main_name_ptr: i32 = ast_temp_base(ast_base);
    store_u8(main_name_ptr + 0, 'm');
    store_u8(main_name_ptr + 1, 'a');
    store_u8(main_name_ptr + 2, 'i');
    store_u8(main_name_ptr + 3, 'n');
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        store_u8(main_name_ptr + 0, 'm');
        store_u8(main_name_ptr + 1, 'a');
        store_u8(main_name_ptr + 2, 'i');
        store_u8(main_name_ptr + 3, 'n');
        if name_len == 4 {
            if identifiers_match(name_ptr, name_len, main_name_ptr, 4) {
                main_count = main_count + 1;
                if param_count != 0 {
                    return -1;
                };
            };
        };
        let mut other_idx: i32 = idx + 1;
        loop {
            if other_idx >= func_count {
                break;
            };
            let other_entry_ptr: i32 = ast_function_entry_ptr(ast_base, other_idx);
            let other_name_ptr: i32 = load_i32(other_entry_ptr);
            let other_name_len: i32 = load_i32(other_entry_ptr + 4);
            if name_len == other_name_len {
                if identifiers_match(name_ptr, name_len, other_name_ptr, other_name_len) {
                    return -1;
                };
            };
            other_idx = other_idx + 1;
        };

        if param_count > 0 {
            let param_types_ptr: i32 = load_i32(entry_ptr + 24);
            if param_types_ptr < 0 {
                return -1;
            };
            let mut param_idx: i32 = 0;
            loop {
                if param_idx >= param_count {
                    break;
                };
                let param_type_id: i32 = load_i32(param_types_ptr + param_idx * 4);
                if resolve_type_id(out_ptr, ast_base, param_type_id) < 0 {
                    return -1;
                };
                param_idx = param_idx + 1;
            };
        };
        let fn_return_type: i32 = load_i32(entry_ptr + 28);
        if fn_return_type >= 0 {
            if resolve_type_id(out_ptr, ast_base, fn_return_type) < 0 {
                return -1;
            };
        };

        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if resolve_call_metadata(out_ptr, ast_base, metadata_ptr, func_count) < 0 {
                return -1;
            };
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if resolve_expression(out_ptr, ast_base, expr_index, func_count) < 0 {
                return -1;
            };
            if fn_return_type >= 0 {
                let expr_type: i32 = ast_expr_type(ast_base, expr_index);
                let expect_array: bool = type_id_is_array(fn_return_type);
                let expr_is_array: bool = expr_type >= 0 && type_id_is_array(expr_type);
                if expect_array || expr_is_array {
                    if expr_type >= 0 {
                        if expr_type != fn_return_type {
                            return -1;
                        };
                    } else if !expression_guaranteed_diverges(ast_base, expr_index) {
                        return -1;
                    };
                };
            };
        };
        idx = idx + 1;
    };
    if main_count != 1 {
        return -1;
    };
    0
}

const RESOLVE_CONTROL_STACK_CAPACITY: i32 = 128;

const RESOLVE_LOOP_STACK_CAPACITY: i32 = 64;

fn resolve_expression_internal(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    loop_stack_base: i32,
    loop_stack_count_ptr: i32,
) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        if resolve_call_metadata(out_ptr, ast_base, metadata_ptr, func_count) < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, callee_index);
        let return_type_id: i32 = load_i32(callee_entry_ptr + 28);
        if return_type_id >= 0 {
            if resolve_type_id(out_ptr, ast_base, return_type_id) < 0 {
                return -1;
            };
        };
        ast_expr_set_type(ast_base, expr_index, return_type_id);
        return 0;
    };
    if kind == 6 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            if resolve_type_id(out_ptr, ast_base, expr_type) < 0 {
                return -1;
            };
        };
        return 0;
    };
    if kind == 8 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            if resolve_type_id(out_ptr, ast_base, expr_type) < 0 {
                return -1;
            };
        };
        return 0;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            element_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let element_type: i32 = ast_expr_type(ast_base, element_index);
        if element_type < 0 {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, element_type) < 0 {
            return -1;
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, element_type, length);
        if array_type_id < 0 {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, array_type_id) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, array_type_id);
        return 0;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut element_type: i32 = -1;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                element_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
            ) < 0 {
                return -1;
            };
            let current_type: i32 = ast_expr_type(ast_base, element_index);
            if current_type < 0 {
                return -1;
            };
            if element_type < 0 {
                element_type = current_type;
            } else if current_type != element_type {
                return -1;
            };
            idx = idx + 1;
        };
        if element_type < 0 {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, element_type) < 0 {
            return -1;
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, element_type, element_count);
        if array_type_id < 0 {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, array_type_id) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, array_type_id);
        return 0;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            index_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, array_type) < 0 {
            return -1;
        };
        let index_type: i32 = ast_expr_type(ast_base, index_index);
        if index_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        let element_type: i32 = array_type_element_type(ast_base, array_type);
        if element_type < 0 {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, element_type) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, element_type);
        return 0;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, array_type) < 0 {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, array_type);
        if length < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
        return 0;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        return 0;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if type_id_is_array(value_type) {
            return -1;
        };
        return 0;
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        if !type_id_is_integer(target_type) {
            return -1;
        };
        if resolve_type_id(out_ptr, ast_base, target_type) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if !type_id_is_integer(value_type) {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, target_type);
        return 0;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            left_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            right_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let left_type: i32 = ast_expr_type(ast_base, left_index);
        let right_type: i32 = ast_expr_type(ast_base, right_index);
        if kind == 20 || kind == 21 {
            if !type_id_is_bool(left_type) {
                return -1;
            };
            if !type_id_is_bool(right_type) {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if kind == 14
            || kind == 15
            || kind == 16
            || kind == 17
            || kind == 18
            || kind == 19
        {
            if !type_id_is_integer(left_type) {
                return -1;
            };
            if !type_id_is_integer(right_type) {
                return -1;
            };
            if left_type != right_type {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if !type_id_is_integer(left_type) {
            return -1;
        };
        if !type_id_is_integer(right_type) {
            return -1;
        };
        if left_type != right_type {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, left_type);
        return 0;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if !type_id_is_bool(value_type) {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
        return 0;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
        return 0;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            condition_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        let control_count: i32 = load_i32(control_stack_count_ptr);
        if control_count >= RESOLVE_CONTROL_STACK_CAPACITY {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            else_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        store_i32(control_stack_count_ptr, control_count);
        let condition_type: i32 = ast_expr_type(ast_base, condition_index);
        if !type_id_is_bool(condition_type) {
            if !type_id_is_integer(condition_type) {
                return -1;
            };
        };
        let then_type: i32 = ast_expr_type(ast_base, then_index);
        let else_type: i32 = ast_expr_type(ast_base, else_index);
        if then_type != else_type {
            let then_diverges: bool = expression_guaranteed_diverges(ast_base, then_index);
            let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
            if then_diverges && !else_diverges {
                ast_expr_set_type(ast_base, expr_index, else_type);
                return 0;
            };
            if else_diverges && !then_diverges {
                ast_expr_set_type(ast_base, expr_index, then_type);
                return 0;
            };
            if then_diverges && else_diverges {
                return 0;
            };
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, then_type);
        return 0;
    };
    if kind == 9 {
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            init_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
        return 0;
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            first_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, then_index));
        return 0;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
        if control_count + 2 > control_capacity {
            return -1;
        };
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        let loop_capacity: i32 = RESOLVE_LOOP_STACK_CAPACITY;
        if loop_count >= loop_capacity {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        store_i32(control_stack_base + (control_count + 1) * 4, 1);
        store_i32(control_stack_count_ptr, control_count + 2);
        store_i32(loop_stack_base + loop_count * 4, control_count);
        store_i32(loop_stack_count_ptr, loop_count + 1);
        let body_result: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
        );
        store_i32(loop_stack_count_ptr, loop_count);
        store_i32(control_stack_count_ptr, control_count);
        if body_result < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 13 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - target_index;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            if resolve_expression_internal(out_ptr, ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
            ) < 0 {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
            return 0;
        };
        ast_expr_set_type(ast_base, expr_index, -1);
        return 0;
    };
    if kind == 24 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let continue_target: i32 = target_index + 1;
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - continue_target;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        return 0;
    };
    -1
}

fn resolve_expression(out_ptr: i32, ast_base: i32, expr_index: i32, func_count: i32) -> i32 {
    let temp_base: i32 = ast_temp_base(ast_base);
    let control_count_ptr: i32 = temp_base;
    let loop_count_ptr: i32 = temp_base + 4;
    let control_stack_base: i32 = temp_base + 8;
    let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
    let loop_stack_base: i32 = control_stack_base + control_capacity * 4;
    let saved_control_count: i32 = load_i32(control_count_ptr);
    let saved_loop_count: i32 = load_i32(loop_count_ptr);
    store_i32(control_count_ptr, 0);
    store_i32(loop_count_ptr, 0);
    let result: i32 = resolve_expression_internal(
        out_ptr,
        ast_base,
        expr_index,
        func_count,
        control_stack_base,
        control_count_ptr,
        loop_stack_base,
        loop_count_ptr,
    );
    store_i32(control_count_ptr, saved_control_count);
    store_i32(loop_count_ptr, saved_loop_count);
    result
}

const LOCAL_COUNTS_BASE: i32 = 1024;

fn local_counts_pack(i32_count: i32, i64_count: i32, ref_count: i32) -> i32 {
    i32_count
        + i64_count * LOCAL_COUNTS_BASE
        + ref_count * LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE
}

fn local_counts_ref(packed: i32) -> i32 {
    packed / (LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE)
}

fn local_counts_i64(packed: i32) -> i32 {
    packed / LOCAL_COUNTS_BASE - local_counts_ref(packed) * LOCAL_COUNTS_BASE
}

fn local_counts_i32(packed: i32) -> i32 {
    packed
        - local_counts_i64(packed) * LOCAL_COUNTS_BASE
        - local_counts_ref(packed) * LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE
}

fn local_counts_add(a: i32, b: i32) -> i32 {
    if a < 0 {
        return -1;
    };
    if b < 0 {
        return -1;
    };
    let sum_i32: i32 = local_counts_i32(a) + local_counts_i32(b);
    let sum_i64: i32 = local_counts_i64(a) + local_counts_i64(b);
    let sum_ref: i32 = local_counts_ref(a) + local_counts_ref(b);
    local_counts_pack(sum_i32, sum_i64, sum_ref)
}

fn local_counts_total(packed: i32) -> i32 {
    if packed < 0 {
        return -1;
    };
    local_counts_i32(packed) + local_counts_i64(packed) + local_counts_ref(packed)
}

fn collect_local_counts_from_expression(
    ast_base: i32,
    expr_index: i32,
    param_count: i32,
    locals_end: i32,
    local_types_ptr: i32,
) -> i32 {
    if expr_index < 0 {
        return 0;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 || kind == 6 || kind == 8 || kind == 24 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        loop {
            if idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + idx * 4);
            let arg_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                arg_expr_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if arg_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, arg_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        return total;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            element_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                element_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if element_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, element_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        return total;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let array_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if array_counts < 0 {
            return -1;
        };
        let index_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            index_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if index_counts < 0 {
            return -1;
        };
        return local_counts_add(array_counts, index_counts);
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            left_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if left_counts < 0 {
            return -1;
        };
        let right_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            right_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if right_counts < 0 {
            return -1;
        };
        return local_counts_add(left_counts, right_counts);
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let mut total: i32 = collect_local_counts_from_expression(
            ast_base,
            condition_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if total < 0 {
            return -1;
        };
        let then_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            then_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if then_counts < 0 {
            return -1;
        };
        total = local_counts_add(total, then_counts);
        if total < 0 {
            return -1;
        };
        let else_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            else_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if else_counts < 0 {
            return -1;
        };
        return local_counts_add(total, else_counts);
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let init_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            init_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if init_counts < 0 {
            return -1;
        };
        let body_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            body_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if body_counts < 0 {
            return -1;
        };
        if local_index < param_count {
            return -1;
        };
        if local_index >= locals_end {
            return -1;
        };
        let mut total: i32 = local_counts_add(init_counts, body_counts);
        if total < 0 {
            return -1;
        };
        let init_type_id: i32 = ast_expr_type(ast_base, init_index);
        let local_slot: i32 = local_index - param_count;
        if local_slot < 0 {
            return -1;
        };
        let total_locals: i32 = locals_end - param_count;
        if local_slot >= total_locals {
            return -1;
        };
        if local_types_ptr >= 0 {
            store_i32(local_types_ptr + local_slot * WORD_SIZE, init_type_id);
        };
        let declaration_counts: i32 = if type_id_is_array(init_type_id) {
            local_counts_pack(0, 0, 1)
        } else {
            let wasm_type: i32 = type_id_to_wasm_value_type(init_type_id);
            if wasm_type < 0 {
                return -1;
            };
            if wasm_type == WASM_VALUE_TYPE_I64 {
                local_counts_pack(0, 1, 0)
            } else {
                local_counts_pack(1, 0, 0)
            }
        };
        local_counts_add(total, declaration_counts)
    } else if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let first_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            first_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if first_counts < 0 {
            return -1;
        };
        let then_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            then_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if then_counts < 0 {
            return -1;
        };
        return local_counts_add(first_counts, then_counts);
    } else if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            body_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            return collect_local_counts_from_expression(
                ast_base,
                value_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
        };
        return 0;
    } else if kind == 22 || kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            ptr_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let ptr_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            ptr_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if ptr_counts < 0 {
            return -1;
        };
        let value_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if value_counts < 0 {
            return -1;
        };
        return local_counts_add(ptr_counts, value_counts);
    } else if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
            local_types_ptr,
        );
    } else {
        0
    }
}

fn collect_function_local_counts(
    ast_base: i32,
    body_kind: i32,
    body_data0: i32,
    param_count: i32,
    locals_count: i32,
    local_types_ptr: i32,
) -> i32 {
    if locals_count <= 0 {
        return 0;
    };
    let locals_end: i32 = param_count + locals_count;
    if local_types_ptr >= 0 {
        let mut init_idx: i32 = 0;
        loop {
            if init_idx >= locals_count {
                break;
            };
            store_i32(local_types_ptr + init_idx * WORD_SIZE, -1);
            init_idx = init_idx + 1;
        };
    };
    if body_kind == 0 {
        if locals_count != 0 {
            return -1;
        };
        return 0;
    };
    if body_kind == 1 {
        let metadata_ptr: i32 = body_data0;
        if metadata_ptr < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        loop {
            if idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + idx * 4);
            let arg_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                arg_expr_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if arg_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, arg_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        if local_counts_total(total) != locals_count {
            return -1;
        };
        return total;
    };
    let counts: i32 = collect_local_counts_from_expression(
        ast_base,
        body_data0,
        param_count,
        locals_end,
        local_types_ptr,
    );
    if counts < 0 {
        return -1;
    };
    if local_counts_total(counts) != locals_count {
        return -1;
    };
    counts
}

fn expression_code_size(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        return 1 + leb_i32_len(value);
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut arg_idx: i32 = 0;
        loop {
            if arg_idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
            if arg_size < 0 {
                return -1;
            };
            total = total + arg_size;
            arg_idx = arg_idx + 1;
        };
        return total + 1 + leb_u32_len(callee_index);
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        return 1 + leb_u32_len(param_index);
    };
    if kind == 8 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            return -1;
        };
        return 1 + leb_u32_len(local_index);
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        let element_size: i32 = expression_code_size(ast_base, element_index);
        if element_size < 0 {
            return -1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_index(expr_type);
        if type_index < 0 {
            return -1;
        };
        return element_size + 1 + leb_i32_len(length) + 2 + leb_u32_len(type_index);
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_size: i32 = expression_code_size(ast_base, element_index);
            if element_size < 0 {
                return -1;
            };
            total = total + element_size;
            idx = idx + 1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_index(expr_type);
        if type_index < 0 {
            return -1;
        };
        return total + 2 + leb_u32_len(type_index) + leb_u32_len(element_count);
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let array_size: i32 = expression_code_size(ast_base, array_index);
        if array_size < 0 {
            return -1;
        };
        let index_size: i32 = expression_code_size(ast_base, index_index);
        if index_size < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_index(array_type);
        if type_index < 0 {
            return -1;
        };
        return array_size + index_size + 2 + leb_u32_len(type_index);
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, array_type);
        if length < 0 {
            return -1;
        };
        return 1 + leb_i32_len(length);
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let ptr_size: i32 = expression_code_size(ast_base, ptr_index);
        if ptr_size < 0 {
            return -1;
        };
        let align: i32 = if kind == 29 {
            0
        } else if kind == 30 {
            1
        } else {
            2
        };
        return ptr_size + 1 + leb_u32_len(align) + leb_u32_len(0);
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let ptr_size: i32 = expression_code_size(ast_base, ptr_index);
        if ptr_size < 0 {
            return -1;
        };
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let align: i32 = if kind == 32 {
            0
        } else if kind == 33 {
            1
        } else {
            2
        };
        return ptr_size
            + value_size
            + 1
            + leb_u32_len(align)
            + leb_u32_len(0)
            + 1
            + leb_i32_len(0);
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        let extra: i32 = cast_expression_extra_code_size(value_type, target_type);
        if extra < 0 {
            return -1;
        };
        return value_size + extra;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_size: i32 = expression_code_size(ast_base, left_index);
        if left_size < 0 {
            return -1;
        };
        let right_size: i32 = expression_code_size(ast_base, right_index);
        if right_size < 0 {
            return -1;
        };
        return left_size + right_size + 1;
    };
    if kind == 20 || kind == 21 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_size: i32 = expression_code_size(ast_base, left_index);
        if left_size < 0 {
            return -1;
        };
        let right_size: i32 = expression_code_size(ast_base, right_index);
        if right_size < 0 {
            return -1;
        };
        return left_size + right_size + 6;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let condition_size: i32 = expression_code_size(ast_base, condition_index);
        if condition_size < 0 {
            return -1;
        };
        let then_size: i32 = expression_code_size(ast_base, then_index);
        if then_size < 0 {
            return -1;
        };
        let else_size: i32 = expression_code_size(ast_base, else_index);
        if else_size < 0 {
            return -1;
        };
        return condition_size + then_size + else_size + 4;
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let init_size: i32 = expression_code_size(ast_base, init_index);
        if init_size < 0 {
            return -1;
        };
        let body_size: i32 = expression_code_size(ast_base, body_index);
        if body_size < 0 {
            return -1;
        };
        return init_size + body_size + 1 + leb_u32_len(local_index);
    };
    if kind == 10 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1 + leb_u32_len(local_index);
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let first_size: i32 = expression_code_size(ast_base, first_index);
        if first_size < 0 {
            return -1;
        };
        let then_size: i32 = expression_code_size(ast_base, then_index);
        if then_size < 0 {
            return -1;
        };
        return first_size + then_size + 1;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let body_size: i32 = expression_code_size(ast_base, body_index);
        if body_size < 0 {
            return -1;
        };
        return body_size + 10;
    };
    if kind == 13 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            let value_size: i32 = expression_code_size(ast_base, value_index);
            if value_size < 0 {
                return -1;
            };
            return value_size + 1 + leb_u32_len(branch_depth);
        };
        let const_size: i32 = 1 + leb_i32_len(0);
        return const_size + 1 + leb_u32_len(branch_depth);
    };
    if kind == 24 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        return 1 + leb_u32_len(branch_depth);
    };
    -1
}

fn emit_expression(base: i32, offset: i32, ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = offset;
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, value);
        return out;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut out: i32 = offset;
        let mut arg_idx: i32 = 0;
        loop {
            if arg_idx >= arg_count {
                break;
            };
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            out = emit_expression(base, out, ast_base, arg_expr_index);
            if out < 0 {
                return -1;
            };
            arg_idx = arg_idx + 1;
        };
        out = write_byte(base, out, 16);
        out = write_u32_leb(base, out, callee_index);
        return out;
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 32);
        out = write_u32_leb(base, out, param_index);
        return out;
    };
    if kind == 8 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 32);
        out = write_u32_leb(base, out, local_index);
        return out;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        let mut out: i32 = emit_expression(base, offset, ast_base, element_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, length);
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_index(expr_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 6);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut out: i32 = offset;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            out = emit_expression(base, out, ast_base, element_index);
            if out < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_index(expr_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 8);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, element_count);
        return out;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, array_index);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, index_index);
        if out < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_index(array_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 11);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, array_type);
        if length < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, length);
        return out;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, ptr_index);
        if out < 0 {
            return -1;
        };
        let opcode: i32 = if kind == 29 {
            45
        } else if kind == 30 {
            47
        } else {
            40
        };
        let align: i32 = if kind == 29 {
            0
        } else if kind == 30 {
            1
        } else {
            2
        };
        out = write_byte(base, out, opcode);
        out = write_u32_leb(base, out, align);
        out = write_u32_leb(base, out, 0);
        return out;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, ptr_index);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, value_index);
        if out < 0 {
            return -1;
        };
        let opcode: i32 = if kind == 32 {
            58
        } else if kind == 33 {
            59
        } else {
            54
        };
        let align: i32 = if kind == 32 {
            0
        } else if kind == 33 {
            1
        } else {
            2
        };
        out = write_byte(base, out, opcode);
        out = write_u32_leb(base, out, align);
        out = write_u32_leb(base, out, 0);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 0);
        return out;
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index);
        if out < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        out = emit_cast_value(base, out, value_type, target_type);
        return out;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, right_index);
        if out < 0 {
            return -1;
        };
        let op_type: i32 = if kind >= 14 && kind <= 19 {
            ast_expr_type(ast_base, left_index)
        } else {
            ast_expr_type(ast_base, expr_index)
        };
        if op_type < 0 {
            return -1;
        };
        let is_i64: bool = type_id_is_64_bit_integer(op_type);
        let is_signed: bool = type_id_is_signed_integer(op_type);
        let opcode: i32 = if kind == 2 {
            if is_i64 { 124 } else { 106 }
        } else if kind == 3 {
            if is_i64 { 125 } else { 107 }
        } else if kind == 4 {
            if is_i64 { 126 } else { 108 }
        } else if kind == 5 {
            if is_i64 {
                if is_signed { 127 } else { 128 }
            } else if is_signed {
                109
            } else {
                110
            }
        } else if kind == 14 {
            if is_i64 { 81 } else { 70 }
        } else if kind == 15 {
            if is_i64 { 82 } else { 71 }
        } else if kind == 16 {
            if is_i64 {
                if is_signed { 83 } else { 84 }
            } else if is_signed {
                72
            } else {
                73
            }
        } else if kind == 17 {
            if is_i64 {
                if is_signed { 85 } else { 86 }
            } else if is_signed {
                74
            } else {
                75
            }
        } else if kind == 18 {
            if is_i64 {
                if is_signed { 87 } else { 88 }
            } else if is_signed {
                76
            } else {
                77
            }
        } else if kind == 19 {
            if is_i64 {
                if is_signed { 89 } else { 90 }
            } else if is_signed {
                78
            } else {
                79
            }
        } else if kind == 25 {
            if is_i64 { 132 } else { 114 }
        } else if kind == 26 {
            if is_i64 { 131 } else { 113 }
        } else if kind == 27 {
            if is_i64 { 134 } else { 116 }
        } else if is_i64 {
            if is_signed { 135 } else { 136 }
        } else if is_signed {
            117
        } else {
            118
        };
        out = write_byte(base, out, opcode);
        return out;
    };
    if kind == 20 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 1);
        out = write_byte(base, out, 5);
        out = emit_expression(base, out, ast_base, right_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 21 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = emit_expression(base, out, ast_base, right_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 5);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 0);
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 69);
        return out;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 15);
        return out;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, condition_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = emit_expression(base, out, ast_base, then_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 5);
        out = emit_expression(base, out, ast_base, else_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, init_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 33);
        out = write_u32_leb(base, out, local_index);
        out = emit_expression(base, out, ast_base, body_index);
        if out < 0 {
            return -1;
        };
        return out;
    };
    if kind == 10 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 34);
        out = write_u32_leb(base, out, local_index);
        return out;
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, first_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 26);
        out = emit_expression(base, out, ast_base, then_index);
        if out < 0 {
            return -1;
        };
        return out;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = write_byte(base, offset, 2);
        out = write_byte(base, out, 127);
        out = write_byte(base, out, 3);
        out = write_byte(base, out, 64);
        out = emit_expression(base, out, ast_base, body_index);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 26);
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, 0);
        out = write_byte(base, out, 11);
        out = write_byte(base, out, 0);
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 13 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = offset;
        if value_index >= 0 {
            out = emit_expression(base, out, ast_base, value_index);
            if out < 0 {
                return -1;
            };
        } else {
            out = write_byte(base, out, 65);
            out = write_i32_leb(base, out, 0);
        };
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, branch_depth);
        return out;
    };
    if kind == 24 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, branch_depth);
        return out;
    };
    -1
}

fn emit_type_section(
    base: i32,
    offset: i32,
    ast_base: i32,
    func_count: i32,
    array_count: i32,
) -> i32 {
    if array_count < 0 {
        return -1;
    };
    let total_types: i32 = array_count + func_count;
    let mut payload_size: i32 = leb_u32_len(total_types);

    let mut array_idx: i32 = 0;
    loop {
        if array_idx >= array_count {
            break;
        };
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, array_idx);
        let element_type_id: i32 = load_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET);
        let element_size: i32 = type_id_wasm_value_type_len(element_type_id);
        if element_size < 0 {
            return -1;
        };
        let entry_size: i32 = leb_i32_len(WASM_COMPOSITE_TYPE_ARRAY) + element_size + 1;
        payload_size = payload_size + entry_size;
        array_idx = array_idx + 1;
    };

    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let param_types_ptr: i32 = load_i32(entry_ptr + 24);
        if param_count > 0 {
            if param_types_ptr < 0 {
                return -1;
            };
        };
        let mut entry_size: i32 = 1;
        entry_size = entry_size + leb_u32_len(param_count);
        let mut param_idx: i32 = 0;
        loop {
            if param_idx >= param_count {
                break;
            };
            let param_type_id: i32 = load_i32(param_types_ptr + param_idx * 4);
            let param_size: i32 = type_id_wasm_value_type_len(param_type_id);
            if param_size < 0 {
                return -1;
            };
            entry_size = entry_size + param_size;
            param_idx = param_idx + 1;
        };
        let return_type_id: i32 = load_i32(entry_ptr + 28);
        if return_type_id >= 0 {
            let return_size: i32 = type_id_wasm_value_type_len(return_type_id);
            if return_size < 0 {
                return -1;
            };
            entry_size = entry_size + leb_u32_len(1) + return_size;
        } else {
            entry_size = entry_size + leb_u32_len(0);
        };
        payload_size = payload_size + entry_size;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, total_types);

    array_idx = 0;
    loop {
        if array_idx >= array_count {
            break;
        };
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, array_idx);
        let element_type_id: i32 = load_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET);
        out = write_i32_leb(base, out, WASM_COMPOSITE_TYPE_ARRAY);
        let next: i32 = write_type_id_as_wasm_value_type(base, out, element_type_id);
        if next < 0 {
            return -1;
        };
        out = write_byte(base, next, WASM_MUTABILITY_VAR);
        array_idx = array_idx + 1;
    };

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let param_types_ptr: i32 = load_i32(entry_ptr + 24);
        out = write_byte(base, out, 96);
        out = write_u32_leb(base, out, param_count);
        let mut param_idx: i32 = 0;
        loop {
            if param_idx >= param_count {
                break;
            };
            let param_type_id: i32 = load_i32(param_types_ptr + param_idx * 4);
            let next: i32 = write_type_id_as_wasm_value_type(base, out, param_type_id);
            if next < 0 {
                return -1;
            };
            out = next;
            param_idx = param_idx + 1;
        };
        let return_type_id: i32 = load_i32(entry_ptr + 28);
        if return_type_id >= 0 {
            out = write_u32_leb(base, out, 1);
            let next: i32 = write_type_id_as_wasm_value_type(base, out, return_type_id);
            if next < 0 {
                return -1;
            };
            out = next;
        } else {
            out = write_u32_leb(base, out, 0);
        };
        idx = idx + 1;
    };
    out
}

fn emit_function_section(
    base: i32,
    offset: i32,
    func_count: i32,
    array_count: i32,
) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let type_index: i32 = array_count + idx;
        payload_size = payload_size + leb_u32_len(type_index);
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 3);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);
    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let type_index: i32 = array_count + idx;
        out = write_u32_leb(base, out, type_index);
        idx = idx + 1;
    };
    out
}

const COMPILER_MEMORY_PAGES: i32 = 64;

fn emit_memory_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 5);
    let pages: i32 = COMPILER_MEMORY_PAGES;
    let payload_size: i32 = leb_u32_len(1) + 1 + leb_u32_len(pages) + leb_u32_len(pages);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, 1);
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, pages);
    out = write_u32_leb(base, out, pages);
    out
}

fn emit_export_section(base: i32, offset: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count + 1);
    payload_size = payload_size + leb_u32_len(6) + 6 + 1 + leb_u32_len(0);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_len: i32 = load_i32(entry_ptr + 4);
        payload_size = payload_size + leb_u32_len(name_len) + name_len + 1 + leb_u32_len(idx);
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 7);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count + 1);

    out = write_u32_leb(base, out, 6);
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 'e');
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 'o');
    out = write_byte(base, out, 'r');
    out = write_byte(base, out, 'y');
    out = write_byte(base, out, 2);
    out = write_u32_leb(base, out, 0);

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        out = write_u32_leb(base, out, name_len);
        let mut byte_idx: i32 = 0;
        loop {
            if byte_idx >= name_len {
                break;
            };
            let byte: i32 = load_u8(name_ptr + byte_idx);
            out = write_byte(base, out, byte);
            byte_idx = byte_idx + 1;
        };
        out = write_byte(base, out, '\0');
        out = write_u32_leb(base, out, idx);
        idx = idx + 1;
    };
    out
}

fn emit_code_section(base: i32, offset: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let locals_count: i32 = load_i32(entry_ptr + 20);
        let body_data0: i32 = load_i32(entry_ptr + 16);
        let local_types_ptr: i32 = ast_temp_base(ast_base);
        let run_types_ptr: i32 = local_types_ptr + locals_count * WORD_SIZE;
        let run_counts_ptr: i32 = run_types_ptr + locals_count * WORD_SIZE;
        let local_counts: i32 = collect_function_local_counts(
            ast_base,
            body_kind,
            body_data0,
            param_count,
            locals_count,
            local_types_ptr,
        );
        if local_counts < 0 {
            return -1;
        };
        if local_counts_total(local_counts) != locals_count {
            return -1;
        };
        let mut local_groups: i32 = 0;
        let mut type_idx: i32 = 0;
        loop {
            if type_idx >= locals_count {
                break;
            };
            let type_id: i32 = load_i32(local_types_ptr + type_idx * WORD_SIZE);
            if type_id < 0 {
                return -1;
            };
            let mut run_len: i32 = 1;
            loop {
                if type_idx + run_len >= locals_count {
                    break;
                };
                let next_type: i32 =
                    load_i32(local_types_ptr + (type_idx + run_len) * WORD_SIZE);
                if next_type != type_id {
                    break;
                };
                run_len = run_len + 1;
            };
            store_i32(run_types_ptr + local_groups * WORD_SIZE, type_id);
            store_i32(run_counts_ptr + local_groups * WORD_SIZE, run_len);
            local_groups = local_groups + 1;
            type_idx = type_idx + run_len;
        };
        let locals_decl_size: i32 = if locals_count > 0 {
            let mut size: i32 = leb_u32_len(local_groups);
            let mut run_idx: i32 = 0;
            loop {
                if run_idx >= local_groups {
                    break;
                };
                let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                let type_len: i32 = type_id_wasm_value_type_len(type_id);
                if type_len < 0 {
                    return -1;
                };
                size = size + leb_u32_len(run_len) + type_len;
                run_idx = run_idx + 1;
            };
            size
        } else {
            leb_u32_len(0)
        };
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = locals_decl_size + 1 + leb_i32_len(literal_value) + 1;
        } else if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if metadata_ptr < 0 {
                return -1;
            };
            let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
            if callee_index < 0 {
                return -1;
            };
            let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
            let args_base: i32 = call_metadata_args_base(metadata_ptr);
            let mut args_size: i32 = 0;
            let mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= arg_count {
                    break;
                };
                let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                if arg_size < 0 {
                    return -1;
                };
                args_size = args_size + arg_size;
                arg_idx = arg_idx + 1;
            };
            body_size = locals_decl_size + args_size + 1 + leb_u32_len(callee_index) + 1;
        } else {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            let expr_size: i32 = expression_code_size(ast_base, expr_index);
            if expr_size < 0 {
                return -1;
            };
            body_size = locals_decl_size + expr_size + 1;
        };
        payload_size = payload_size + leb_u32_len(body_size) + body_size;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 10);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);

    idx = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let locals_count: i32 = load_i32(entry_ptr + 20);
        let body_data0: i32 = load_i32(entry_ptr + 16);
        let local_types_ptr: i32 = ast_temp_base(ast_base);
        let run_types_ptr: i32 = local_types_ptr + locals_count * WORD_SIZE;
        let run_counts_ptr: i32 = run_types_ptr + locals_count * WORD_SIZE;
        let local_counts: i32 = collect_function_local_counts(
            ast_base,
            body_kind,
            body_data0,
            param_count,
            locals_count,
            local_types_ptr,
        );
        if local_counts < 0 {
            return -1;
        };
        if local_counts_total(local_counts) != locals_count {
            return -1;
        };
        let mut local_groups: i32 = 0;
        let mut type_idx: i32 = 0;
        loop {
            if type_idx >= locals_count {
                break;
            };
            let type_id: i32 = load_i32(local_types_ptr + type_idx * WORD_SIZE);
            if type_id < 0 {
                return -1;
            };
            let mut run_len: i32 = 1;
            loop {
                if type_idx + run_len >= locals_count {
                    break;
                };
                let next_type: i32 =
                    load_i32(local_types_ptr + (type_idx + run_len) * WORD_SIZE);
                if next_type != type_id {
                    break;
                };
                run_len = run_len + 1;
            };
            store_i32(run_types_ptr + local_groups * WORD_SIZE, type_id);
            store_i32(run_counts_ptr + local_groups * WORD_SIZE, run_len);
            local_groups = local_groups + 1;
            type_idx = type_idx + run_len;
        };
        let locals_decl_size: i32 = if locals_count > 0 {
            let mut size: i32 = leb_u32_len(local_groups);
            let mut run_idx: i32 = 0;
            loop {
                if run_idx >= local_groups {
                    break;
                };
                let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                let type_len: i32 = type_id_wasm_value_type_len(type_id);
                if type_len < 0 {
                    return -1;
                };
                size = size + leb_u32_len(run_len) + type_len;
                run_idx = run_idx + 1;
            };
            size
        } else {
            leb_u32_len(0)
        };
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = locals_decl_size + 1 + leb_i32_len(literal_value) + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                loop {
                    if run_idx >= local_groups {
                        break;
                    };
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 = write_type_id_as_wasm_value_type(base, out, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            out = write_byte(base, out, 65);
            out = write_i32_leb(base, out, literal_value);
            out = write_byte(base, out, 11);
        } else if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if metadata_ptr < 0 {
                return -1;
            };
            let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
                if callee_index < 0 {
                    return -1;
                };
                let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
                let args_base: i32 = call_metadata_args_base(metadata_ptr);
                let mut args_size: i32 = 0;
                let mut arg_idx: i32 = 0;
                loop {
                    if arg_idx >= arg_count {
                        break;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                    let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                    if arg_size < 0 {
                        return -1;
                    };
                    args_size = args_size + arg_size;
                    arg_idx = arg_idx + 1;
                };
            body_size = locals_decl_size + args_size + 1 + leb_u32_len(callee_index) + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                loop {
                    if run_idx >= local_groups {
                        break;
                    };
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 = write_type_id_as_wasm_value_type(base, out, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            let mut emit_idx: i32 = 0;
            loop {
                    if emit_idx >= arg_count {
                        break;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + emit_idx * 4);
                    out = emit_expression(base, out, ast_base, arg_expr_index);
                    if out < 0 {
                        return -1;
                    };
                    emit_idx = emit_idx + 1;
                };
            out = write_byte(base, out, 16);
            out = write_u32_leb(base, out, callee_index);
            out = write_byte(base, out, 11);
        } else {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            let expr_size: i32 = expression_code_size(ast_base, expr_index);
            if expr_size < 0 {
                return -1;
            };
            body_size = locals_decl_size + expr_size + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                loop {
                    if run_idx >= local_groups {
                        break;
                    };
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 = write_type_id_as_wasm_value_type(base, out, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            out = emit_expression(base, out, ast_base, expr_index);
            if out < 0 {
                return -1;
            };
            out = write_byte(base, out, 11);
        };
        idx = idx + 1;
    };
    out
}

fn write_type_metadata(out_ptr: i32, ast_base: i32) -> i32 {
    let array_count: i32 = ast_array_types_count(ast_base);
    let mut idx: i32 = 0;
    loop {
        if idx >= array_count {
            break;
        };
        let type_id: i32 = array_type_id(idx);
        if resolve_array_type_id(out_ptr, ast_base, type_id) < 0 {
            return -1;
        };
        idx = idx + 1;
    };
    0
}

fn emit_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut offset: i32 = 0;
    offset = write_magic(out_ptr, offset);
    let array_count: i32 = ast_array_types_count(ast_base);
    offset = emit_type_section(out_ptr, offset, ast_base, func_count, array_count);
    offset = emit_function_section(out_ptr, offset, func_count, array_count);
    offset = emit_memory_section(out_ptr, offset);
    offset = emit_export_section(out_ptr, offset, ast_base, func_count);
    offset = emit_code_section(out_ptr, offset, ast_base, func_count);
    offset
}

fn initialize_layout(out_ptr: i32) {
    store_i32(scratch_instr_offset_ptr(out_ptr), 0);
    store_i32(scratch_expr_type_ptr(out_ptr), -1);
    store_i32(scratch_fn_count_ptr(out_ptr), 0);
    store_i32(scratch_types_count_ptr(out_ptr), 0);
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    if input_len <= 0 {
        return -1;
    };

    initialize_layout(out_ptr);
    let ast_base: i32 = ast_program_base(out_ptr, input_len);
    ast_reset(ast_base);

    let func_count: i32 = parse_program(input_ptr, input_len, ast_base);
    if func_count <= 0 {
        return -1;
    };
    if validate_program(out_ptr, ast_base, func_count) < 0 {
        return -1;
    };

    if write_type_metadata(out_ptr, ast_base) < 0 {
        return -1;
    };

    let produced_len: i32 = emit_program(out_ptr, ast_base, func_count);
    if produced_len <= 0 {
        return -1;
    };
    produced_len
}

fn main() -> i32 {
    0
}
