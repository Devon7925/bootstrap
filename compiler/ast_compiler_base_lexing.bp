fn memory_size_pages() -> i32 {
    inline_wasm([0x3f, 0x00])
}

fn memory_grow_pages(pages: i32) -> i32 {
    inline_wasm([0x20, 0x00, 0x40, 0x00])
}

fn ensure_memory_capacity(required: i32) -> i32 {
    if required <= 0 {
        return 0;
    }
    let mut current_pages: i32 = memory_size_pages();
    if current_pages < 0 {
        return -1;
    }
    let mut current_bytes: i32 = current_pages << 16;
    if current_bytes >= required {
        return 0;
    }
    loop {
        let additional_bytes: i32 = required - current_bytes;
        if additional_bytes <= 0 {
            break;
        }
        let mut additional_pages: i32 = additional_bytes >> 16;
        if (additional_bytes & 65535) != 0 {
            additional_pages = additional_pages + 1;
        }
        if additional_pages <= 0 {
            additional_pages = 1;
        }
        let previous_pages: i32 = memory_grow_pages(additional_pages);
        if previous_pages < 0 {
            return -1;
        }
        current_pages = previous_pages + additional_pages;
        current_bytes = current_pages << 16;
        if current_bytes >= required {
            break;
        }
    };
    0
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    while idx < len {
        let byte: i32 = load_u8(base + idx);
        if byte == '/' {
            if idx + 1 < len {
                let next: i32 = load_u8(base + idx + 1);
                if next == '/' {
                    idx = idx + 2;
                    while idx < len {
                        let comment_byte: i32 = load_u8(base + idx);
                        if comment_byte == '\n' {
                            idx = idx + 1;
                            break;
                        }
                        idx = idx + 1;
                    };
                    continue;
                }
            }
        }
        if !is_whitespace(byte) {
            break;
        }
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    }
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    }
    offset + 1
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 'A' && byte <= 'Z') || (byte >= 'a' && byte <= 'z') || byte == '_'
}

fn is_digit(byte: i32) -> bool {
    byte >= '0' && byte <= '9'
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || is_digit(byte)
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 2, "fn")
}

fn expect_keyword_use(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 3, "use")
}

fn expect_keyword_if(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 2, "if")
}

fn expect_keyword_as(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 2, "as")
}

fn expect_keyword_true(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 4, "true")
}

fn expect_keyword_false(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 5, "false")
}

fn expect_keyword_else(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 4, "else")
}

fn expect_keyword_loop(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 4, "loop")
}

fn expect_keyword_while(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 5, "while")
}

fn expect_keyword_break(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 5, "break")
}

fn expect_keyword_continue(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 8, "continue")
}

fn expect_keyword_return(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 6, "return")
}

const IdentifierParse = struct(6, 3, [
    ("cursor", i32),
    ("start\0", i32),
    ("length", i32),
]);

const EXPRESSION_PART_NAME_CAP: i32 = 5;

const ExpressionParts = struct(
    EXPRESSION_PART_NAME_CAP,
    3,
    [
        ("kind\0", i32),
        ("data0", i32),
        ("data1", i32),
    ],
);

fn parse_identifier(base: i32, len: i32, offset: i32) -> IdentifierParse {
    if offset >= len {
        return IdentifierParse {
            cursor: -1,
            start: 0,
            length: 0,
        };
    }
    let first: i32 = load_u8(base + offset);
    if !is_identifier_start(first) {
        return IdentifierParse {
            cursor: -1,
            start: 0,
            length: 0,
        };
    }
    let mut idx: i32 = offset + 1;
    while idx < len {
        let byte: i32 = load_u8(base + idx);
        if !is_identifier_continue(byte) {
            break;
        }
        idx = idx + 1;
    };
    IdentifierParse {
        cursor: idx,
        start: offset,
        length: idx - offset,
    }
}

const MAX_PARAMS: i32 = 64;

const TYPE_TEMPLATE_KIND_NONE: i32 = 0;
const TYPE_TEMPLATE_KIND_ARRAY_LENGTH: i32 = 1;
const TYPE_TEMPLATE_KIND_TYPE_EXPR: i32 = 2;

const TYPE_TEMPLATE_ENTRY_KIND_OFFSET: i32 = 0;
const TYPE_TEMPLATE_ENTRY_BASE_TYPE_OFFSET: i32 = 4;
const TYPE_TEMPLATE_ENTRY_EXPR_OFFSET: i32 = 8;
const TYPE_TEMPLATE_ENTRY_PARAM_PTR_OFFSET: i32 = 12;
const TYPE_TEMPLATE_ENTRY_PARAM_COUNT_OFFSET: i32 = 16;

const TYPE_TEMPLATE_ENTRY_WORDS: i32 = 5;

const TYPE_TEMPLATE_TRAVERSAL_STACK_CAPACITY: i32 = 256;

const TYPE_TEMPLATE_PAYLOAD_RETURN_HANDLE_INDEX: i32 = 0;
const TYPE_TEMPLATE_PAYLOAD_RETURN_BASE_INDEX: i32 = 1;
const TYPE_TEMPLATE_PAYLOAD_PARAM_BASE_INDEX: i32 = 2;
const TYPE_TEMPLATE_PAYLOAD_PARAM_STRIDE: i32 = 2;

const MAX_ARRAY_LITERAL_ELEMENTS: i32 = 256;

const MAX_TUPLE_ELEMENTS: i32 = 32;

const MAX_STRUCT_LITERAL_FIELDS: i32 = 32;

const FAILURE_DETAIL_CAPACITY: i32 = 256;

const INTRINSIC_KIND_NONE: i32 = -1;

const INTRINSIC_KIND_LEN: i32 = 0;

const INTRINSIC_KIND_INLINE_WASM: i32 = 1;

const CALL_METADATA_INTRINSIC_STRUCT: i32 = -2;
const STRUCT_INTRINSIC_FAILURE_DUPLICATE_FIELD: i32 = 1;
const STRUCT_INTRINSIC_FAILURE_INVALID_PROPS: i32 = 2;
const STRUCT_INTRINSIC_FAILURE_TEMPLATE_TYPE_MISMATCH: i32 = 3;

fn identifier_matches_keyword(
    base: i32,
    source_len: i32,
    start: i32,
    ident_len: i32,
    const KEYWORD_LEN: i32,
    keyword: [u8; KEYWORD_LEN],
) -> bool {
    if KEYWORD_LEN <= 0 {
        return false;
    }
    if start < 0 || start + ident_len > source_len {
        return false;
    }
    if ident_len != KEYWORD_LEN {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < KEYWORD_LEN {
        if load_u8(base + start + idx) != keyword[idx] as i32 {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn type_template_record_param_usage(
    param_index: i32,
    usage_mask_low_ptr: i32,
    usage_mask_high_ptr: i32,
    usage_list_ptr: i32,
    usage_count_ptr: i32,
) -> i32 {
    if param_index < 0 { return -1; }
    if param_index >= MAX_PARAMS { return -1; }
    if param_index < 32 {
        let current_mask: i32 = load_i32(usage_mask_low_ptr);
        let bit: i32 = 1 << param_index;
        if (current_mask & bit) != 0 {
            return 0;
        }
        store_i32(usage_mask_low_ptr, current_mask | bit);
    } else {
        let bit_index: i32 = param_index - 32;
        let current_mask: i32 = load_i32(usage_mask_high_ptr);
        let bit: i32 = 1 << bit_index;
        if (current_mask & bit) != 0 {
            return 0;
        }
        store_i32(usage_mask_high_ptr, current_mask | bit);
    }
    let usage_count: i32 = load_i32(usage_count_ptr);
    if usage_count < 0 { return -1; }
    if usage_count >= MAX_PARAMS { return -1; }
    store_i32(usage_list_ptr + usage_count * WORD_SIZE, param_index);
    store_i32(usage_count_ptr, usage_count + 1);
    0
}

fn type_template_collect_const_params(
    ast_base: i32,
    expr_index: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    usage_mask_low_ptr: i32,
    usage_mask_high_ptr: i32,
    usage_list_ptr: i32,
    usage_count_ptr: i32,
) -> i32 {
    if expr_index < 0 { return -1; }
    if expr_index >= ast_expr_count(ast_base) { return -1; }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 { return 0; }
    if kind == 6 {
        if params_count <= 0 { return -1; }
        if const_mask_table_ptr <= 0 { return -1; }
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 { return -1; }
        if param_index >= params_count { return -1; }
        let mask_word_index: i32 = param_index >> 5;
        let mask_word_ptr: i32 = const_mask_table_ptr + mask_word_index * WORD_SIZE;
        let mask_word_value: i32 = load_i32(mask_word_ptr);
        let mask_bit_index: i32 = param_index & 31;
        let mask_bit: i32 = 1 << mask_bit_index;
        if (mask_word_value & mask_bit) == 0 { return -1; }
        return type_template_record_param_usage(
            param_index,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 22 || kind == 39 {
        let child_index: i32 = load_i32(entry_ptr + 4);
        return type_template_collect_const_params(
            ast_base,
            child_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        return type_template_collect_const_params(
            ast_base,
            tuple_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        if type_template_collect_const_params(
            ast_base,
            element_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let length_expr_index: i32 =
            ast_expr_array_repeat_length_expr(ast_base, expr_index);
        if length_expr_index >= 0 {
            return type_template_collect_const_params(
                ast_base,
                length_expr_index,
                params_count,
                const_mask_table_ptr,
                usage_mask_low_ptr,
                usage_mask_high_ptr,
                usage_list_ptr,
                usage_count_ptr,
            );
        }
        return 0;
    }
    if kind == 37 || kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let count: i32 = load_i32(entry_ptr + 8);
        if count < 0 {
            return -1;
        }
        if count == 0 {
            return 0;
        }
        if values_ptr <= 0 {
            return -1;
        }
        let mut elem_idx: i32 = 0;
        while elem_idx < count {
            let value_index: i32 = load_i32(values_ptr + elem_idx * WORD_SIZE);
            if type_template_collect_const_params(
                ast_base,
                value_index,
                params_count,
                const_mask_table_ptr,
                usage_mask_low_ptr,
                usage_mask_high_ptr,
                usage_list_ptr,
                usage_count_ptr,
            ) < 0 {
                return -1;
            }
            elem_idx = elem_idx + 1;
        };
        return 0;
    }
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 46
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 36
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if type_template_collect_const_params(
            ast_base,
            left_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        if type_template_collect_const_params(
            ast_base,
            right_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        return 0;
    }
    -1
}

fn type_template_capture_expression_template(
    ast_base: i32,
    expr_kind_ptr: i32,
    expr_data0_ptr: i32,
    expr_data1_ptr: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    base_type_id: i32,
    scratch_base: i32,
    entry_kind: i32,
) -> i32 {
    if params_count <= 0 { return -1; }
    if const_mask_table_ptr <= 0 { return -1; }
    let expr_kind: i32 = load_i32(expr_kind_ptr);
    let expr_data0: i32 = load_i32(expr_data0_ptr);
    let expr_data1: i32 = load_i32(expr_data1_ptr);
    let mut expr_index: i32 = -1;
    if expr_kind == 2 {
        expr_index = expr_data0;
    } else {
        expr_index = expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
        if expr_index < 0 { return -1; }
        store_expression_parts(expr_kind_ptr, expr_data0_ptr, expr_data1_ptr, ExpressionParts { kind: 2, data0: expr_index, data1: 0 });
    }
    let usage_mask_low_ptr: i32 = scratch_base;
    let usage_mask_high_ptr: i32 = usage_mask_low_ptr + 4;
    let usage_count_ptr: i32 = usage_mask_high_ptr + 4;
    let usage_list_ptr: i32 = usage_count_ptr + 4;
    store_i32(usage_mask_low_ptr, 0);
    store_i32(usage_mask_high_ptr, 0);
    store_i32(usage_count_ptr, 0);
    if type_template_collect_const_params(
        ast_base,
        expr_index,
        params_count,
        const_mask_table_ptr,
        usage_mask_low_ptr,
        usage_mask_high_ptr,
        usage_list_ptr,
        usage_count_ptr,
    ) < 0 {
        return -1;
    }
    let usage_count: i32 = load_i32(usage_count_ptr);
    if usage_count <= 0 { return -1; }
    let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let saved_call_data_used: i32 = load_i32(call_data_used_ptr);
    let mut params_ptr: i32 = 0;
    if usage_count > 0 {
        params_ptr = ast_call_data_alloc(ast_base, usage_count);
        if params_ptr < 0 {
            store_i32(call_data_used_ptr, saved_call_data_used);
            return -1;
        }
        let mut copy_idx: i32 = 0;
        loop {
            if copy_idx >= usage_count { break; }
            let value: i32 = load_i32(usage_list_ptr + copy_idx * WORD_SIZE);
            store_i32(params_ptr + copy_idx * WORD_SIZE, value);
            copy_idx = copy_idx + 1;
        };
    }
    let entry_ptr: i32 = ast_call_data_alloc(ast_base, TYPE_TEMPLATE_ENTRY_WORDS);
    if entry_ptr < 0 {
        store_i32(call_data_used_ptr, saved_call_data_used);
        return -1;
    }
    store_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_KIND_OFFSET, entry_kind);
    store_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_BASE_TYPE_OFFSET, base_type_id);
    store_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_EXPR_OFFSET, expr_index);
    store_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_PARAM_PTR_OFFSET, params_ptr);
    store_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_PARAM_COUNT_OFFSET, usage_count);
    entry_ptr
}

fn type_template_entry_kind(entry_ptr: i32) -> i32 {
    if entry_ptr <= 0 {
        return TYPE_TEMPLATE_KIND_NONE;
    }
    load_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_KIND_OFFSET)
}

fn type_template_entry_base_type(entry_ptr: i32) -> i32 {
    if entry_ptr <= 0 {
        return -1;
    }
    load_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_BASE_TYPE_OFFSET)
}

fn type_template_entry_expr_index(entry_ptr: i32) -> i32 {
    if entry_ptr <= 0 {
        return -1;
    }
    load_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_EXPR_OFFSET)
}

fn type_template_entry_params_ptr(entry_ptr: i32) -> i32 {
    if entry_ptr <= 0 {
        return 0;
    }
    load_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_PARAM_PTR_OFFSET)
}

fn type_template_entry_param_count(entry_ptr: i32) -> i32 {
    if entry_ptr <= 0 {
        return 0;
    }
    load_i32(entry_ptr + TYPE_TEMPLATE_ENTRY_PARAM_COUNT_OFFSET)
}

fn type_template_entry_param_index(entry_ptr: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    let params_ptr: i32 = type_template_entry_params_ptr(entry_ptr);
    if params_ptr <= 0 {
        return -1;
    }
    if index >= type_template_entry_param_count(entry_ptr) {
        return -1;
    }
    load_i32(params_ptr + index * WORD_SIZE)
}

fn type_template_resolve_type(
    ast_base: i32,
    template_handle: i32,
    param_values_ptr: i32,
    param_count: i32,
    scratch_base: i32,
    scratch_top_ptr: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
) -> i32 {
    if template_handle <= 0 {
        return -1;
    }
    if scratch_base <= 0 {
        return -1;
    }
    if scratch_top_ptr <= 0 {
        return -1;
    }
    if out_value_ptr <= 0 {
        return -1;
    }
    if out_type_ptr <= 0 {
        return -1;
    }
    if param_count < 0 {
        return -1;
    }
    if param_count > 0 {
        if param_values_ptr <= 0 {
            return -1;
        }
    }
    let expr_index: i32 = type_template_entry_expr_index(template_handle);
    if expr_index < 0 {
        return -1;
    }
    let saved_top: i32 = load_i32(scratch_top_ptr);
    store_i32(scratch_top_ptr, 0);
    let status: i32 = interpret_constant_expression(
        ast_base,
        expr_index,
        scratch_base,
        scratch_top_ptr,
        out_value_ptr,
        out_type_ptr,
        param_values_ptr,
        param_count,
        param_count,
    );
    store_i32(scratch_top_ptr, saved_top);
    if status < 0 {
        return -1;
    }
    if status != CONST_EVAL_STATUS_OK {
        return -1;
    }
    let result_type: i32 = load_i32(out_type_ptr);
    let result_value: i32 = load_i32(out_value_ptr);
    let template_kind: i32 = type_template_entry_kind(template_handle);
    if template_kind == TYPE_TEMPLATE_KIND_ARRAY_LENGTH {
        if !constant_eval_integer_type_supported(result_type) {
            return -1;
        }
        let length: i32 = normalize_integer_value(result_value, result_type);
        if length < 0 {
            return -1;
        }
        let element_type_id: i32 = type_template_entry_base_type(template_handle);
        if element_type_id < 0 {
            return -1;
        }
        ast_register_array_type(ast_base, element_type_id, length)
    } else if template_kind == TYPE_TEMPLATE_KIND_TYPE_EXPR {
        if result_type != BUILTIN_TYPE_ID_TYPE {
            return -1;
        }
        if result_value < 0 {
            return -1;
        }
        result_value
    } else {
        -1
    }
}

fn type_template_capture_array_length(
    ast_base: i32,
    expr_kind_ptr: i32,
    expr_data0_ptr: i32,
    expr_data1_ptr: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    element_type_id: i32,
    scratch_base: i32,
) -> i32 {
    type_template_capture_expression_template(
        ast_base,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
        params_count,
        const_mask_table_ptr,
        element_type_id,
        scratch_base,
        TYPE_TEMPLATE_KIND_ARRAY_LENGTH,
    )
}

fn expect_keyword_literal(
    base: i32,
    len: i32,
    offset: i32,
    const KEYWORD_LEN: i32,
    keyword: [u8; KEYWORD_LEN],
) -> i32 {
    if KEYWORD_LEN <= 0 {
        return -1;
    }
    if offset < 0 || offset + KEYWORD_LEN > len {
        return -1;
    }
    let mut idx: i32 = 0;
    while idx < KEYWORD_LEN {
        if load_u8(base + offset + idx) != keyword[idx] as i32 {
            return -1;
        }
        idx = idx + 1;
    };
    let next: i32 = offset + KEYWORD_LEN;
    if next < len {
        let after: i32 = load_u8(base + next);
        if is_identifier_continue(after) {
            return -1;
        }
    }
    next
}

fn identify_intrinsic(base: i32, len: i32, start: i32, ident_len: i32) -> i32 {
    if identifier_matches_keyword(base, len, start, ident_len, 3, "len") {
        return INTRINSIC_KIND_LEN;
    }
    if identifier_matches_keyword(base, len, start, ident_len, 11, "inline_wasm") {
        return INTRINSIC_KIND_INLINE_WASM;
    }
    INTRINSIC_KIND_NONE
}

fn identifiers_match_source(
    base: i32,
    start_a: i32,
    len_a: i32,
    start_b: i32,
    len_b: i32,
) -> bool {
    if len_a != len_b {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < len_a {
        let a_byte: i32 = load_u8(base + start_a + idx);
        let b_byte: i32 = load_u8(base + start_b + idx);
        if a_byte != b_byte {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn find_parameter_index(
    base: i32,
    params_table_ptr: i32,
    params_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    let mut idx: i32 = 0;
    while idx < params_count {
        let entry_ptr: i32 = params_table_ptr + idx * 8;
        let param_start: i32 = load_i32(entry_ptr);
        let param_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, param_start, param_len, ident_start, ident_len) {
            return idx;
        }
        idx = idx + 1;
    };
    -1
}

fn expect_keyword_const(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 5, "const")
}

fn expect_keyword_let(base: i32, len: i32, offset: i32) -> i32 {
    expect_keyword_literal(base, len, offset, 3, "let")
}

const MAX_LOCALS: i32 = 512;

const LOCALS_ENTRY_SIZE: i32 = 20;

const PARSER_TEMP_SCRATCH_OFFSET: i32 =
    MAX_PARAMS * 8 +
    MAX_PARAMS * WORD_SIZE * 3 +
    ((MAX_PARAMS + 31) >> 5) * WORD_SIZE +
    WORD_SIZE +
    8 +
    12 +
    WORD_SIZE +
    MAX_LOCALS * LOCALS_ENTRY_SIZE +
    WORD_SIZE;

fn locals_entry_ptr(locals_table_ptr: i32, index: i32) -> i32 {
    locals_table_ptr + index * LOCALS_ENTRY_SIZE
}

fn parser_temp_scratch_base(ast_base: i32, params_table_ptr: i32) -> i32 {
    if params_table_ptr > 0 {
        params_table_ptr + PARSER_TEMP_SCRATCH_OFFSET
    } else {
        ast_temp_base(ast_base)
    }
}

fn find_local_entry_index(
    base: i32,
    locals_table_ptr: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= 0 {
        return -1;
    }
    let mut idx: i32 = locals_stack_count - 1;
    while idx >= 0 {
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        }
        idx = idx - 1;
    };
    -1
}

fn find_local_entry_index_in_scope(
    base: i32,
    locals_table_ptr: i32,
    scope_start: i32,
    locals_stack_count: i32,
    ident_start: i32,
    ident_len: i32,
) -> i32 {
    if locals_stack_count <= scope_start {
        return -1;
    }
    let mut idx: i32 = locals_stack_count - 1;
    while idx >= scope_start {
        let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, idx);
        let local_start: i32 = load_i32(entry_ptr);
        let local_len: i32 = load_i32(entry_ptr + 4);
        if identifiers_match_source(base, local_start, local_len, ident_start, ident_len) {
            return idx;
        }
        idx = idx - 1;
    };
    -1
}

fn locals_entry_local_index(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 8)
}

fn locals_entry_type_id(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + 12)
}

fn locals_entry_is_mut(entry_ptr: i32) -> bool {
    load_i32(entry_ptr + 16) != 0
}

fn constant_entry_name_matches(
    base: i32,
    ident_start: i32,
    ident_len: i32,
    entry_ptr: i32,
    current_module_index: i32,
) -> bool {
    let const_len: i32 = ast_constant_entry_name_len(entry_ptr);
    if const_len != ident_len {
        return false;
    }
    let entry_module_index: i32 = ast_constant_entry_module_index(entry_ptr);
    let const_start: i32 = ast_constant_entry_name_start(entry_ptr);
    if entry_module_index < 0 || entry_module_index == current_module_index {
        return identifiers_match_source(base, const_start, const_len, ident_start, ident_len);
    }
    let module_base: i32 = module_entry_content(entry_module_index);
    if module_base <= 0 {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < const_len {
        let const_byte: i32 = load_u8(module_base + const_start + idx);
        let ident_byte: i32 = load_u8(base + ident_start + idx);
        if const_byte != ident_byte {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn find_constant_entry_index(
    base: i32,
    ast_base: i32,
    ident_start: i32,
    ident_len: i32,
    allow_imports: bool,
) -> i32 {
    let count: i32 = ast_constants_count(ast_base);
    if count <= 0 {
        return -1;
    }
    let current_module_index: i32 = module_find_index_by_content_ptr(base);
    let mut idx: i32 = 0;
    let mut imported_match: i32 = -1;
    while idx < count {
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, idx);
        let entry_module_index: i32 = ast_constant_entry_module_index(entry_ptr);
        let same_module: bool = if entry_module_index < 0 {
            current_module_index < 0
        } else {
            entry_module_index == current_module_index
        };
        if same_module {
            if constant_entry_name_matches(
                base,
                ident_start,
                ident_len,
                entry_ptr,
                current_module_index,
            ) {
                return idx;
            }
        } else if allow_imports {
            if constant_entry_name_matches(
                base,
                ident_start,
                ident_len,
                entry_ptr,
                current_module_index,
            ) {
                if imported_match < 0 {
                    imported_match = idx;
                }
            }
        }
        idx = idx + 1;
    };
    if allow_imports {
        return imported_match;
    }
    -1
}

fn expression_guaranteed_diverges(ast_base: i32, expr_index: i32) -> bool {
    if expr_index < 0 {
        return false;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return false;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 13 {
        return true;
    }
    if kind == 24 {
        return true;
    }
    if kind == 23 {
        return true;
    }
    if kind == 11 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        return expression_guaranteed_diverges(ast_base, then_index);
    }
    if kind == 9 {
        let body_index: i32 = load_i32(entry_ptr + 12);
        return expression_guaranteed_diverges(ast_base, body_index);
    }
    if kind == 7 {
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if !expression_guaranteed_diverges(ast_base, then_index) {
            return false;
        }
        if !expression_guaranteed_diverges(ast_base, else_index) {
            return false;
        }
        return true;
    }
    false
}

const LOOP_FLAG_NONE: i32 = 0;
const LOOP_FLAG_DISALLOW_BREAK_VALUES: i32 = 1;

const BLOCK_STATEMENT_ENTRY_SIZE: i32 = 12;

const BLOCK_STATEMENTS_CAPACITY: i32 = 1024;

const ASSIGNMENT_SELECTOR_ENTRY_SIZE: i32 = 12;

const ASSIGNMENT_SELECTOR_CAPACITY: i32 = 16;

const ASSIGNMENT_SELECTOR_TYPE_ARRAY: i32 = 1;

const ASSIGNMENT_SELECTOR_TYPE_TUPLE: i32 = 2;

fn parse_block_expression_body(
    base: i32,
    len: i32,
    cursor: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    locals_table_ptr: i32,
    locals_stack_count_ptr: i32,
    locals_next_index_ptr: i32,
    literal_ptr: i32,
    temp_base: i32,
    allow_empty_final_expr: i32,
    loop_depth_ptr: i32,
    type_template_sink_ptr: i32,
    out_kind_ptr: i32,
    out_data0_ptr: i32,
    out_data1_ptr: i32,
    out_value_status_ptr: i32,
) -> i32 {
    let saved_stack_count: i32 = load_i32(locals_stack_count_ptr);
    let saved_next_index: i32 = load_i32(locals_next_index_ptr);
    let mut idx: i32 = skip_whitespace(base, len, cursor);

    let statement_count_ptr: i32 = temp_base;
    store_i32(statement_count_ptr, 0);
    let statements_base: i32 = statement_count_ptr + 4;
    let statements_capacity: i32 = BLOCK_STATEMENTS_CAPACITY;
    let statement_entry_size: i32 = BLOCK_STATEMENT_ENTRY_SIZE;
    let statements_end: i32 = statements_base + statements_capacity * statement_entry_size;
    let stmt_expr_kind_ptr: i32 = statements_end;
    let stmt_expr_data0_ptr: i32 = stmt_expr_kind_ptr + 4;
    let stmt_expr_data1_ptr: i32 = stmt_expr_kind_ptr + 8;
    let stmt_expr_value_status_ptr: i32 = stmt_expr_kind_ptr + 12;
    let stmt_local_type_ptr: i32 = stmt_expr_value_status_ptr + 4;
    let stmt_nested_temp_base: i32 = stmt_expr_kind_ptr + 64;

    let allow_empty_value: bool = allow_empty_final_expr != 0;
    let mut have_value_expr: bool = false;
    let mut final_kind: i32 = -1;
    let mut final_data0: i32 = 0;
    let mut final_data1: i32 = 0;
    store_i32(out_value_status_ptr, 0);

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        }
        let next_byte: i32 = load_u8(base + idx);
        if next_byte == '}' {
            if !have_value_expr {
                if allow_empty_value {
                    have_value_expr = true;
                    final_kind = 0;
                    final_data0 = 0;
                    final_data1 = 0;
                } else {
                    let stmt_count: i32 = load_i32(statement_count_ptr);
                    let mut diverges: bool = false;
                    if stmt_count > 0 {
                        let last_ptr: i32 =
                            statements_base + (stmt_count - 1) * statement_entry_size;
                        let last_kind: i32 = load_i32(last_ptr);
                        if last_kind == 1 {
                            let last_expr_index: i32 = load_i32(last_ptr + 4);
                            if expression_guaranteed_diverges(ast_base, last_expr_index) {
                                diverges = true;
                            }
                        }
                    }
                    if diverges {
                        have_value_expr = true;
                        final_kind = 0;
                        final_data0 = 0;
                        final_data1 = 0;
                    } else {
                        let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                        if detail_out_ptr > 0 {
                            if load_u8(detail_out_ptr) == 0 {
                                write_failure_detail_with_location(
                                    detail_out_ptr,
                                    scratch_module_index(detail_out_ptr),
                                    base,
                                    len,
                                    idx,
                                    30,
                                    "block must end with expression",
                                );
                            }
                        }
                        store_i32(locals_stack_count_ptr, saved_stack_count);
                        store_i32(locals_next_index_ptr, saved_next_index);
                        return -1;
                    }
                }
            }
            idx = idx + 1;
            idx = skip_whitespace(base, len, idx);
            break;
        }
        if have_value_expr {
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        }

        let mut handled_statement: bool = false;
        let mut let_cursor: i32 = expect_keyword_let(base, len, idx);
        if let_cursor >= 0 {
            if let_cursor >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let after_keyword: i32 = load_u8(base + let_cursor);
            if !is_whitespace(after_keyword) {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            idx = skip_whitespace(base, len, let_cursor);
            let mut is_mut: bool = false;
            if idx + 3 <= len {
                let m: i32 = load_u8(base + idx);
                if m == 'm' {
                    let u: i32 = load_u8(base + idx + 1);
                    let t: i32 = load_u8(base + idx + 2);
                    if u == 'u' && t == 't' {
                        let after_mut: i32 = idx + 3;
                        if after_mut >= len {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        }
                        let after_mut_byte: i32 = load_u8(base + after_mut);
                        if is_whitespace(after_mut_byte) {
                            is_mut = true;
                            idx = skip_whitespace(base, len, after_mut);
                        }
                    }
                }
            }

            let ident: IdentifierParse = parse_identifier(base, len, idx);
            let next_idx: i32 = ident.cursor;
            if next_idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let name_start: i32 = ident.start;
            let name_len: i32 = ident.length;
            idx = next_idx;

            let current_stack: i32 = load_i32(locals_stack_count_ptr);
            let existing: i32 = find_local_entry_index_in_scope(
                base,
                locals_table_ptr,
                saved_stack_count,
                current_stack,
                name_start,
                name_len,
            );
            if existing >= 0 {
                let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                if detail_out_ptr > 0 {
                    if load_u8(detail_out_ptr) == 0 {
                        let message: [u8; 27] = "duplicate local declaration";
                        write_failure_detail_with_location(
                            detail_out_ptr,
                            scratch_module_index(detail_out_ptr),
                            base,
                            len,
                            name_start,
                            27,
                            message,
                        );
                    }
                }
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }

            idx = skip_whitespace(base, len, idx);
            let mut has_type_annotation: bool = false;
            if idx < len {
                let next_char: i32 = load_u8(base + idx);
                if next_char == ':' {
                    has_type_annotation = true;
                    idx = skip_whitespace(base, len, idx + 1);
                    idx = parse_type(
                        base,
                        len,
                        idx,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        const_mask_table_ptr,
                        type_template_sink_ptr,
                        stmt_local_type_ptr,
                    );
                    if idx < 0 {
                        store_i32(locals_stack_count_ptr, saved_stack_count);
                        store_i32(locals_next_index_ptr, saved_next_index);
                        return -1;
                    }
                }
            }
            if !has_type_annotation {
                store_i32(stmt_local_type_ptr, -1);
            }
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, '=');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            idx = skip_whitespace(base, len, idx);
            let init_start: i32 = idx;
            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                type_template_sink_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let init_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let init_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let init_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let init_index: i32 =
                expression_node_from_parts(ast_base, init_kind, init_data0, init_data1);
            if init_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            if load_i32(stmt_local_type_ptr) < 0 {
                let inferred_type: i32 = ast_expr_type(ast_base, init_index);
                store_i32(stmt_local_type_ptr, inferred_type);
            }
            let local_type_id: i32 = load_i32(stmt_local_type_ptr);
            if local_type_id == BUILTIN_TYPE_ID_BOOL {
                let init_type: i32 = ast_expr_type(ast_base, init_index);
                if init_type >= 0 && init_type != BUILTIN_TYPE_ID_BOOL {
                    let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                    if detail_out_ptr > 0 {
                        if load_u8(detail_out_ptr) == 0 {
                            let mut location_offset: i32 =
                                ast_expr_location(ast_base, init_index);
                            if location_offset <= 0 {
                                if init_start >= 0 {
                                    location_offset = init_start;
                                } else {
                                    location_offset = name_start;
                                }
                            }
                            let message: [u8; 41] =
                                "boolean local initializer must be boolean";
                            write_failure_detail_with_location(
                                detail_out_ptr,
                                scratch_module_index(detail_out_ptr),
                                base,
                                len,
                                location_offset,
                                41,
                                message,
                            );
                        }
                    }
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
            }
            idx = skip_whitespace(base, len, idx);
            idx = expect_char(base, len, idx, ';');
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }

            let stack_count: i32 = load_i32(locals_stack_count_ptr);
            if stack_count >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let next_local_offset: i32 = load_i32(locals_next_index_ptr);
            if next_local_offset >= MAX_LOCALS {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let local_index: i32 = params_count + next_local_offset;
            let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, stack_count);
            store_i32(entry_ptr, name_start);
            store_i32(entry_ptr + 4, name_len);
            store_i32(entry_ptr + 8, local_index);
            store_i32(entry_ptr + 12, local_type_id);
            store_i32(entry_ptr + 16, if is_mut { 1 } else { 0 });
            store_i32(locals_stack_count_ptr, stack_count + 1);
            store_i32(locals_next_index_ptr, next_local_offset + 1);

            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 0);
            store_i32(stmt_ptr + 4, local_index);
            store_i32(stmt_ptr + 8, init_index);
            store_i32(statement_count_ptr, stmt_count + 1);
            handled_statement = true;
        }

        if handled_statement {
            continue;
        }

        let mut expression_parsed: bool = false;

        let mut break_cursor: i32 = expect_keyword_break(base, len, idx);
        if break_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                if detail_out_ptr > 0 {
                    if load_u8(detail_out_ptr) == 0 {
                        write_failure_detail_with_location(
                            detail_out_ptr,
                            scratch_module_index(detail_out_ptr),
                            base,
                            len,
                            idx,
                            36,
                            "break statements must be inside loop",
                        );
                    }
                }
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let mut after_break: i32 = skip_whitespace(base, len, break_cursor);
            if after_break >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let mut value_index: i32 = -1;
            let after_byte: i32 = load_u8(base + after_break);
            if after_byte != ';' {
                after_break = parse_expression(
                    base,
                    len,
                    after_break,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    const_mask_table_ptr,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    type_template_sink_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                value_index = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                after_break = skip_whitespace(base, len, after_break);
                after_break = expect_char(base, len, after_break, ';');
                if after_break < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
            } else {
                after_break = skip_whitespace(base, len, after_break + 1);
            }
            let break_expr_index: i32 = ast_expr_alloc_break(ast_base, idx, value_index);
            if break_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, break_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = after_break;
            continue;
        }

        let mut continue_cursor: i32 = expect_keyword_continue(base, len, idx);
        if continue_cursor >= 0 {
            let current_loop_depth: i32 = load_i32(loop_depth_ptr);
            if current_loop_depth <= 0 {
                let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                if detail_out_ptr > 0 {
                    if load_u8(detail_out_ptr) == 0 {
                        write_failure_detail_with_location(
                            detail_out_ptr,
                            scratch_module_index(detail_out_ptr),
                            base,
                            len,
                            idx,
                            40,
                            "continue statements must be inside loops",
                        );
                    }
                }
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            if continue_cursor < len {
                let after_byte: i32 = load_u8(base + continue_cursor);
                if after_byte != ';' && !is_whitespace(after_byte) {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
            }
            let mut after_continue: i32 = skip_whitespace(base, len, continue_cursor);
            after_continue = expect_char(base, len, after_continue, ';');
            if after_continue < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let continue_expr_index: i32 = ast_expr_alloc_continue(ast_base, idx);
            if continue_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, continue_expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = skip_whitespace(base, len, after_continue);
            continue;
        }

        let mut return_cursor: i32 = expect_keyword_return(base, len, idx);
        if return_cursor >= 0 {
            let mut after_return: i32 = skip_whitespace(base, len, return_cursor);
            if after_return >= len {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let mut value_index: i32 = -1;
            let next_after_return: i32 = load_u8(base + after_return);
            if next_after_return == ';' {
                value_index = ast_expr_alloc_tuple(ast_base, 0, 0);
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                after_return = skip_whitespace(base, len, after_return + 1);
            } else {
                after_return = parse_expression(
                    base,
                    len,
                    after_return,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    const_mask_table_ptr,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    type_template_sink_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if after_return < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                value_index = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                after_return = skip_whitespace(base, len, after_return);
                after_return = expect_char(base, len, after_return, ';');
                if after_return < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                after_return = skip_whitespace(base, len, after_return);
            }
            let return_expr_index: i32 = ast_expr_alloc_return(ast_base, value_index, idx);
            if return_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            have_value_expr = true;
            final_kind = 23;
            final_data0 = return_expr_index;
            final_data1 = 0;
            store_i32(out_value_status_ptr, 1);
            idx = after_return;
            continue;
        }

        let mut loop_cursor: i32 = expect_keyword_loop(base, len, idx);
        if loop_cursor >= 0 {
            let mut after_loop: i32 = skip_whitespace(base, len, loop_cursor);
            after_loop = expect_char(base, len, after_loop, '{');
            if after_loop < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let saved_loop_depth: i32 = load_i32(loop_depth_ptr);
            store_i32(loop_depth_ptr, saved_loop_depth + 1);
            after_loop = parse_block_expression_body(
                base,
                len,
                after_loop,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                stmt_nested_temp_base,
                1,
                loop_depth_ptr,
                type_template_sink_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
                stmt_expr_value_status_ptr,
            );
            if after_loop < 0 {
                store_i32(loop_depth_ptr, saved_loop_depth);
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            store_i32(loop_depth_ptr, saved_loop_depth);
            let body_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let body_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let body_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let body_index: i32 = expression_node_from_parts(
                ast_base,
                body_kind,
                body_data0,
                body_data1,
            );
            if body_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let loop_expr_index: i32 =
                ast_expr_alloc_loop(ast_base, body_index, LOOP_FLAG_NONE);
            if loop_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            store_i32(stmt_expr_kind_ptr, 12);
            store_i32(stmt_expr_data0_ptr, loop_expr_index);
            store_i32(stmt_expr_data1_ptr, 0);
            idx = after_loop;
            expression_parsed = true;
        }

        let mut while_cursor: i32 = expect_keyword_while(base, len, idx);
        if while_cursor >= 0 {
            let mut condition_cursor: i32 = skip_whitespace(base, len, while_cursor);
            let cond_kind_ptr: i32 = stmt_nested_temp_base;
            let cond_data0_ptr: i32 = stmt_nested_temp_base + 4;
            let cond_data1_ptr: i32 = stmt_nested_temp_base + 8;
            let cond_temp_base: i32 = stmt_nested_temp_base + 32;
            condition_cursor = parse_expression(
                base,
                len,
                condition_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                cond_temp_base,
                loop_depth_ptr,
                type_template_sink_ptr,
                cond_kind_ptr,
                cond_data0_ptr,
                cond_data1_ptr,
            );
            if condition_cursor < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let cond_kind: i32 = load_i32(cond_kind_ptr);
            let cond_data0: i32 = load_i32(cond_data0_ptr);
            let cond_data1: i32 = load_i32(cond_data1_ptr);
            let cond_index: i32 =
                expression_node_from_parts(ast_base, cond_kind, cond_data0, cond_data1);
            if cond_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            condition_cursor = skip_whitespace(base, len, condition_cursor);
            condition_cursor = expect_char(base, len, condition_cursor, '{');
            if condition_cursor < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let saved_loop_depth: i32 = load_i32(loop_depth_ptr);
            store_i32(loop_depth_ptr, saved_loop_depth + 1);
            condition_cursor = parse_block_expression_body(
                base,
                len,
                condition_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                literal_ptr,
                stmt_nested_temp_base,
                1,
                loop_depth_ptr,
                type_template_sink_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
                stmt_expr_value_status_ptr,
            );
            if condition_cursor < 0 {
                store_i32(loop_depth_ptr, saved_loop_depth);
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            store_i32(loop_depth_ptr, saved_loop_depth);
            let body_kind: i32 = load_i32(stmt_expr_kind_ptr);
            let body_data0: i32 = load_i32(stmt_expr_data0_ptr);
            let body_data1: i32 = load_i32(stmt_expr_data1_ptr);
            let body_index: i32 =
                expression_node_from_parts(ast_base, body_kind, body_data0, body_data1);
            if body_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let break_expr_index: i32 = ast_expr_alloc_break(ast_base, -1, -1);
            if break_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let if_expr_index: i32 =
                ast_expr_alloc_if(ast_base, cond_index, body_index, break_expr_index);
            if if_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let loop_expr_index: i32 = ast_expr_alloc_loop(
                ast_base,
                if_expr_index,
                LOOP_FLAG_DISALLOW_BREAK_VALUES,
            );
            if loop_expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            store_i32(stmt_expr_kind_ptr, 12);
            store_i32(stmt_expr_data0_ptr, loop_expr_index);
            store_i32(stmt_expr_data1_ptr, 0);
            idx = condition_cursor;
            expression_parsed = true;
        }

        let statement_start: i32 = idx;
        let mut assignment_identified: bool = false;
        let mut assignment_local_index: i32 = -1;
        let mut assignment_cursor: i32 = idx;
        let mut assignment_location: i32 = -1;
        let mut assignment_kind: i32 = 0;
        let mut assignment_array_expr_index: i32 = -1;
        let mut assignment_array_index_expr_index: i32 = -1;
        let mut assignment_array_index_location: i32 = -1;
        let mut assignment_tuple_expr_index: i32 = -1;
        let mut assignment_tuple_field_index: i32 = -1;
        let mut assignment_tuple_field_location: i32 = -1;
        if !expression_parsed {
            if is_identifier_start(next_byte) {
                let assignment_ident: IdentifierParse = parse_identifier(base, len, idx);
                assignment_cursor = assignment_ident.cursor;
                if assignment_cursor >= 0 {
                    let name_start: i32 = assignment_ident.start;
                    let name_len: i32 = assignment_ident.length;
                    assignment_location = name_start;
                    let mut after_ident: i32 = skip_whitespace(base, len, assignment_cursor);
                    if after_ident < len {
                        let selectors_base: i32 = stmt_nested_temp_base + 128;
                        let selector_entry_size: i32 = ASSIGNMENT_SELECTOR_ENTRY_SIZE;
                        let mut selector_count: i32 = 0;
                        let mut scan_cursor: i32 = after_ident;
                        let mut eq_cursor: i32 = -1;
                        loop {
                            scan_cursor = skip_whitespace(base, len, scan_cursor);
                            if scan_cursor >= len {
                                break;
                            }
                            let scan_byte: i32 = load_u8(base + scan_cursor);
                            if scan_byte == '=' {
                                let mut maybe_second: i32 = -1;
                                if scan_cursor + 1 < len {
                                    maybe_second = load_u8(base + scan_cursor + 1);
                                }
                                if maybe_second != '=' {
                                    eq_cursor = scan_cursor;
                                }
                                break;
                            }
                            if scan_byte == '[' {
                                if selector_count >= ASSIGNMENT_SELECTOR_CAPACITY {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                }
                                let entry_ptr: i32 =
                                    selectors_base + selector_count * selector_entry_size;
                                let mut bracket_depth: i32 = 1;
                                let mut inner_cursor: i32 = scan_cursor + 1;
                                let expr_start: i32 = skip_whitespace(base, len, inner_cursor);
                                let mut closing_idx: i32 = -1;
                                while inner_cursor < len {
                                    let inner_byte: i32 = load_u8(base + inner_cursor);
                                    if inner_byte == '[' {
                                        bracket_depth = bracket_depth + 1;
                                    } else if inner_byte == ']' {
                                        bracket_depth = bracket_depth - 1;
                                        if bracket_depth <= 0 {
                                            closing_idx = inner_cursor;
                                            break;
                                        }
                                    }
                                    inner_cursor = inner_cursor + 1;
                                };
                                if closing_idx < 0 {
                                    break;
                                }
                                store_i32(entry_ptr, ASSIGNMENT_SELECTOR_TYPE_ARRAY);
                                store_i32(entry_ptr + 4, expr_start);
                                store_i32(entry_ptr + 8, closing_idx);
                                selector_count = selector_count + 1;
                                scan_cursor = closing_idx + 1;
                                continue;
                            }
                            if scan_byte == '.' {
                                if selector_count >= ASSIGNMENT_SELECTOR_CAPACITY {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                }
                                let entry_ptr: i32 =
                                    selectors_base + selector_count * selector_entry_size;
                                let field_start: i32 = skip_whitespace(base, len, scan_cursor + 1);
                                let mut field_cursor: i32 = field_start;
                                let mut field_digits: i32 = 0;
                                while field_cursor < len {
                                    let field_byte: i32 = load_u8(base + field_cursor);
                                    if field_byte < '0' || field_byte > '9' {
                                        break;
                                    }
                                    field_cursor = field_cursor + 1;
                                    field_digits = field_digits + 1;
                                };
                                if field_digits <= 0 {
                                    break;
                                }
                                let mut field_index: i32 = 0;
                                let mut digit_idx: i32 = 0;
                                while digit_idx < field_digits {
                                    let digit_byte: i32 = load_u8(base + field_start + digit_idx);
                                    field_index = field_index * 10 + (digit_byte - '0');
                                    digit_idx = digit_idx + 1;
                                };
                                store_i32(entry_ptr, ASSIGNMENT_SELECTOR_TYPE_TUPLE);
                                store_i32(entry_ptr + 4, field_index);
                                store_i32(entry_ptr + 8, field_start);
                                selector_count = selector_count + 1;
                                scan_cursor = field_cursor;
                                continue;
                            }
                            break;
                        };
                        if eq_cursor >= 0 {
                            let current_stack: i32 = load_i32(locals_stack_count_ptr);
                            let entry_index: i32 = find_local_entry_index(
                                base,
                                locals_table_ptr,
                                current_stack,
                                name_start,
                                name_len,
                            );
                            if entry_index < 0 {
                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                store_i32(locals_next_index_ptr, saved_next_index);
                                return -1;
                            }
                            let entry_ptr: i32 = locals_entry_ptr(locals_table_ptr, entry_index);
                            if !locals_entry_is_mut(entry_ptr) {
                                let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                                if detail_out_ptr > 0 {
                                    if load_u8(detail_out_ptr) == 0 {
                                        write_failure_detail_with_location(
                                            detail_out_ptr,
                                            scratch_module_index(detail_out_ptr),
                                            base,
                                            len,
                                            name_start,
                                            32,
                                            "cannot assign to immutable local",
                                        );
                                    }
                                }
                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                store_i32(locals_next_index_ptr, saved_next_index);
                                return -1;
                            }
                            assignment_local_index = locals_entry_local_index(entry_ptr);
                            let local_type_id: i32 = locals_entry_type_id(entry_ptr);
                            if selector_count <= 0 {
                                assignment_kind = 0;
                                assignment_identified = true;
                                assignment_cursor = skip_whitespace(base, len, eq_cursor + 1);
                            } else {
                                let mut current_expr_index: i32 = ast_expr_alloc_local(
                                    ast_base,
                                    assignment_local_index,
                                    local_type_id,
                                );
                                if current_expr_index < 0 {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                }
                                let mut selector_idx: i32 = 0;
                                while selector_idx < selector_count {
                                    let selector_ptr: i32 =
                                        selectors_base + selector_idx * selector_entry_size;
                                    let selector_type: i32 = load_i32(selector_ptr);
                                    if selector_type == ASSIGNMENT_SELECTOR_TYPE_ARRAY {
                                        let expr_start: i32 = load_i32(selector_ptr + 4);
                                        let index_kind_ptr: i32 = stmt_nested_temp_base;
                                        let index_data0_ptr: i32 = stmt_nested_temp_base + 4;
                                        let index_data1_ptr: i32 = stmt_nested_temp_base + 8;
                                        let index_temp_base: i32 = stmt_nested_temp_base + 32;
                                        let mut index_cursor: i32 = parse_expression(
                                            base,
                                            len,
                                            expr_start,
                                            ast_base,
                                            params_table_ptr,
                                            params_count,
                                            const_mask_table_ptr,
                                            locals_table_ptr,
                                            locals_stack_count_ptr,
                                            locals_next_index_ptr,
                                            index_temp_base,
                                            loop_depth_ptr,
                                            type_template_sink_ptr,
                                            index_kind_ptr,
                                            index_data0_ptr,
                                            index_data1_ptr,
                                        );
                                        if index_cursor < 0 {
                                            store_i32(locals_stack_count_ptr, saved_stack_count);
                                            store_i32(locals_next_index_ptr, saved_next_index);
                                            return -1;
                                        }
                                        index_cursor = skip_whitespace(base, len, index_cursor);
                                        index_cursor = expect_char(base, len, index_cursor, ']');
                                        if index_cursor < 0 {
                                            store_i32(locals_stack_count_ptr, saved_stack_count);
                                            store_i32(locals_next_index_ptr, saved_next_index);
                                            return -1;
                                        }
                                        let index_parts: ExpressionParts = load_expression_parts(
                                            index_kind_ptr,
                                            index_data0_ptr,
                                            index_data1_ptr,
                                        );
                                        let index_expr_index: i32 =
                                            expression_index_from_parts(ast_base, index_parts);
                                        if index_expr_index < 0 {
                                            store_i32(locals_stack_count_ptr, saved_stack_count);
                                            store_i32(locals_next_index_ptr, saved_next_index);
                                            return -1;
                                        }
                                        if selector_idx == selector_count - 1 {
                                            assignment_array_expr_index = current_expr_index;
                                            assignment_array_index_expr_index = index_expr_index;
                                            assignment_array_index_location = expr_start;
                                            assignment_kind = 1;
                                        } else {
                                            let new_expr_index: i32 = ast_expr_alloc_array_get(
                                                ast_base,
                                                current_expr_index,
                                                index_expr_index,
                                                expr_start,
                                            );
                                            if new_expr_index < 0 {
                                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                                store_i32(locals_next_index_ptr, saved_next_index);
                                                return -1;
                                            }
                                            current_expr_index = new_expr_index;
                                        }
                                    } else if selector_type
                                        == ASSIGNMENT_SELECTOR_TYPE_TUPLE
                                    {
                                        let field_index: i32 = load_i32(selector_ptr + 4);
                                        let field_location: i32 = load_i32(selector_ptr + 8);
                                        if selector_idx == selector_count - 1 {
                                            assignment_tuple_expr_index = current_expr_index;
                                            assignment_tuple_field_index = field_index;
                                            assignment_tuple_field_location = field_location;
                                            assignment_kind = 2;
                                        } else {
                                            let new_expr_index: i32 = ast_expr_alloc_tuple_get(
                                                ast_base,
                                                current_expr_index,
                                                field_index,
                                                field_location,
                                            );
                                            if new_expr_index < 0 {
                                                store_i32(locals_stack_count_ptr, saved_stack_count);
                                                store_i32(locals_next_index_ptr, saved_next_index);
                                                return -1;
                                            }
                                            current_expr_index = new_expr_index;
                                        }
                                    } else {
                                        store_i32(locals_stack_count_ptr, saved_stack_count);
                                        store_i32(locals_next_index_ptr, saved_next_index);
                                        return -1;
                                    }
                                    selector_idx = selector_idx + 1;
                                };
                                if assignment_kind == 0 {
                                    store_i32(locals_stack_count_ptr, saved_stack_count);
                                    store_i32(locals_next_index_ptr, saved_next_index);
                                    return -1;
                                }
                                assignment_identified = true;
                                assignment_cursor = skip_whitespace(base, len, eq_cursor + 1);
                            }
                        }
                    }
                }
            }
        }

        if !expression_parsed {
            idx = statement_start;
            if assignment_identified {
                idx = parse_expression(
                    base,
                    len,
                    assignment_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    const_mask_table_ptr,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    stmt_nested_temp_base,
                    loop_depth_ptr,
                    type_template_sink_ptr,
                    stmt_expr_kind_ptr,
                    stmt_expr_data0_ptr,
                    stmt_expr_data1_ptr,
                );
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                let value_kind: i32 = load_i32(stmt_expr_kind_ptr);
                let value_data0: i32 = load_i32(stmt_expr_data0_ptr);
                let value_data1: i32 = load_i32(stmt_expr_data1_ptr);
                let value_index: i32 = expression_node_from_parts(
                    ast_base,
                    value_kind,
                    value_data0,
                    value_data1,
                );
                if value_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                idx = skip_whitespace(base, len, idx);
                idx = expect_char(base, len, idx, ';');
                if idx < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                let mut assign_expr_index: i32 = -1;
                if assignment_kind == 0 {
                    assign_expr_index =
                        ast_expr_alloc_set_local(ast_base, assignment_local_index, value_index);
                } else if assignment_kind == 1 {
                    assign_expr_index = ast_expr_alloc_array_set(
                        ast_base,
                        assignment_array_expr_index,
                        assignment_array_index_expr_index,
                        value_index,
                        assignment_array_index_location,
                    );
                } else if assignment_kind == 2 {
                    assign_expr_index = ast_expr_alloc_tuple_set(
                        ast_base,
                        assignment_tuple_expr_index,
                        assignment_tuple_field_index,
                        value_index,
                        assignment_tuple_field_location,
                    );
                }
                if assign_expr_index < 0 {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                if assignment_kind == 0 {
                    ast_expr_entry_set_extra(ast_base, assign_expr_index, assignment_location);
                }
                let stmt_count: i32 = load_i32(statement_count_ptr);
                if stmt_count >= statements_capacity {
                    store_i32(locals_stack_count_ptr, saved_stack_count);
                    store_i32(locals_next_index_ptr, saved_next_index);
                    return -1;
                }
                let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                store_i32(stmt_ptr, 1);
                store_i32(stmt_ptr + 4, assign_expr_index);
                store_i32(stmt_ptr + 8, 0);
                store_i32(statement_count_ptr, stmt_count + 1);
                continue;
            }

            idx = parse_expression(
                base,
                len,
                idx,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                stmt_nested_temp_base,
                loop_depth_ptr,
                type_template_sink_ptr,
                stmt_expr_kind_ptr,
                stmt_expr_data0_ptr,
                stmt_expr_data1_ptr,
            );
            if idx < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
        }
        let expr_kind: i32 = load_i32(stmt_expr_kind_ptr);
        let expr_data0: i32 = load_i32(stmt_expr_data0_ptr);
        let expr_data1: i32 = load_i32(stmt_expr_data1_ptr);
        let mut next_cursor: i32 = skip_whitespace(base, len, idx);
        let mut treat_as_statement: bool = false;
        if next_cursor < len {
            let delimiter: i32 = load_u8(base + next_cursor);
            if delimiter == ';' {
                let after_semicolon: i32 = skip_whitespace(base, len, next_cursor + 1);
                if after_semicolon < len {
                    let after_byte: i32 = load_u8(base + after_semicolon);
                    if after_byte == '}' && !have_value_expr {
                        next_cursor = after_semicolon;
                    } else {
                        treat_as_statement = true;
                        next_cursor = after_semicolon;
                    }
                } else {
                    treat_as_statement = true;
                    next_cursor = after_semicolon;
                }
            }
        }
        if !treat_as_statement {
            if expr_kind == 12 {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte != '}' {
                        treat_as_statement = true;
                    }
                }
            }
        }
        if !treat_as_statement {
            if expr_kind == 2 {
                let metadata: i32 = load_i32(stmt_expr_data1_ptr);
                if metadata < 0 {
                    treat_as_statement = true;
                } else if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte != '}' {
                        treat_as_statement = true;
                    }
                }
            }
        }
        if treat_as_statement {
            let expr_index: i32 = expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
            if expr_index < 0 {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_count: i32 = load_i32(statement_count_ptr);
            if stmt_count >= statements_capacity {
                store_i32(locals_stack_count_ptr, saved_stack_count);
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
            store_i32(stmt_ptr, 1);
            store_i32(stmt_ptr + 4, expr_index);
            store_i32(stmt_ptr + 8, 0);
            store_i32(statement_count_ptr, stmt_count + 1);
            idx = next_cursor;
            continue;
        }

        let expr_metadata: i32 = load_i32(stmt_expr_data1_ptr);
        let mut metadata_requires_value: bool = false;
        if expr_kind == 7 {
            metadata_requires_value = true;
        }
        if metadata_requires_value && expr_metadata < 0 {
            if allow_empty_value {
                if next_cursor < len {
                    let after_byte: i32 = load_u8(base + next_cursor);
                    if after_byte == '}' {
                        let expr_index: i32 =
                            expression_node_from_parts(ast_base, expr_kind, expr_data0, expr_data1);
                        if expr_index < 0 {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        }
                        let stmt_count: i32 = load_i32(statement_count_ptr);
                        if stmt_count >= statements_capacity {
                            store_i32(locals_stack_count_ptr, saved_stack_count);
                            store_i32(locals_next_index_ptr, saved_next_index);
                            return -1;
                        }
                        let stmt_ptr: i32 = statements_base + stmt_count * statement_entry_size;
                        store_i32(stmt_ptr, 1);
                        store_i32(stmt_ptr + 4, expr_index);
                        store_i32(stmt_ptr + 8, 0);
                        store_i32(statement_count_ptr, stmt_count + 1);
                        idx = next_cursor;
                        continue;
                    }
                }
            }
            store_i32(locals_stack_count_ptr, saved_stack_count);
            store_i32(locals_next_index_ptr, saved_next_index);
            return -1;
        }
        have_value_expr = true;
        final_kind = expr_kind;
        final_data0 = expr_data0;
        final_data1 = expr_data1;
        store_i32(out_value_status_ptr, 1);
        idx = next_cursor;
    };

    store_i32(locals_stack_count_ptr, saved_stack_count);

    let mut final_index: i32 =
        expression_node_from_parts(ast_base, final_kind, final_data0, final_data1);
    if final_index < 0 {
        store_i32(locals_next_index_ptr, saved_next_index);
        return -1;
    }
    let stmt_count: i32 = load_i32(statement_count_ptr);
    if stmt_count > 0 {
        let mut stmt_idx: i32 = stmt_count - 1;
        while stmt_idx >= 0 {
            let stmt_ptr: i32 = statements_base + stmt_idx * statement_entry_size;
            let stmt_kind: i32 = load_i32(stmt_ptr);
            if stmt_kind == 0 {
                let local_index: i32 = load_i32(stmt_ptr + 4);
                let init_index: i32 = load_i32(stmt_ptr + 8);
                final_index = ast_expr_alloc_let(ast_base, local_index, init_index, final_index);
            } else {
                let first_index: i32 = load_i32(stmt_ptr + 4);
                final_index = ast_expr_alloc_sequence(ast_base, first_index, final_index);
            }
            if final_index < 0 {
                store_i32(locals_next_index_ptr, saved_next_index);
                return -1;
            }
            stmt_idx = stmt_idx - 1;
        };
    }

    store_expression_parts(out_kind_ptr, out_data0_ptr, out_data1_ptr, ExpressionParts { kind: 2, data0: final_index, data1: 0 });
    idx
}

const BUILTIN_TYPE_ID_I32: i32 = 0;

const BUILTIN_TYPE_ID_BOOL: i32 = 1;

const BUILTIN_TYPE_ID_I8: i32 = 2;

const BUILTIN_TYPE_ID_I16: i32 = 3;

const BUILTIN_TYPE_ID_I64: i32 = 4;

const BUILTIN_TYPE_ID_U8: i32 = 5;

const BUILTIN_TYPE_ID_U16: i32 = 6;

const BUILTIN_TYPE_ID_U32: i32 = 7;

const BUILTIN_TYPE_ID_U64: i32 = 8;

const BUILTIN_TYPE_ID_TYPE: i32 = 9;

const BUILTIN_INTEGER_VARIANT_COUNT: i32 = 4;

const SCRATCH_TYPES_CAPACITY: i32 = 2048;

const BUILTIN_TYPE_ID_MAX: i32 = BUILTIN_TYPE_ID_TYPE;

const ARRAY_TYPE_CAPACITY: i32 = 256;

const TUPLE_TYPE_CAPACITY: i32 = 256;

const STRUCT_TYPE_CAPACITY: i32 = 256;

const TYPE_ID_KIND_SHIFT: i32 = 24;

const TYPE_ID_KIND_USER_COMPOSITE: i32 = 1;

const fn type_id_kind_base(kind: i32) -> i32 {
    kind << TYPE_ID_KIND_SHIFT
}

const TYPE_ID_ARRAY_BASE: i32 = type_id_kind_base(TYPE_ID_KIND_USER_COMPOSITE);

const TYPE_ID_TUPLE_BASE: i32 = TYPE_ID_ARRAY_BASE + ARRAY_TYPE_CAPACITY;

const TYPE_ID_ARRAY_LIMIT: i32 = TYPE_ID_TUPLE_BASE;

const TYPE_ID_TUPLE_LIMIT: i32 = TYPE_ID_TUPLE_BASE + TUPLE_TYPE_CAPACITY;

const TYPE_ID_STRUCT_BASE: i32 = TYPE_ID_TUPLE_LIMIT;

const TYPE_ID_STRUCT_LIMIT: i32 = TYPE_ID_STRUCT_BASE + STRUCT_TYPE_CAPACITY;

fn type_id_is_builtin(type_id: i32) -> bool {
    type_id >= 0 && type_id <= BUILTIN_TYPE_ID_MAX
}

fn type_id_is_array(type_id: i32) -> bool {
    type_id >= TYPE_ID_ARRAY_BASE && type_id < TYPE_ID_ARRAY_LIMIT
}

fn type_id_is_tuple(type_id: i32) -> bool {
    type_id >= TYPE_ID_TUPLE_BASE && type_id < TYPE_ID_TUPLE_LIMIT
}

fn type_id_is_struct(type_id: i32) -> bool {
    type_id >= TYPE_ID_STRUCT_BASE && type_id < TYPE_ID_STRUCT_LIMIT
}

fn type_id_is_bool(type_id: i32) -> bool {
    type_id == BUILTIN_TYPE_ID_BOOL
}

fn type_id_is_type(type_id: i32) -> bool {
    type_id == BUILTIN_TYPE_ID_TYPE
}

fn integer_type_variant_index(type_id: i32) -> i32 {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    while idx < count {
        if type_id == signed[idx] {
            return idx;
        }
        if type_id == unsigned[idx] {
            return idx;
        }
        idx = idx + 1;
    };
    -1
}

fn type_id_is_integer(type_id: i32) -> bool {
    integer_type_variant_index(type_id) >= 0
}

fn type_id_is_signed_integer(type_id: i32) -> bool {
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    let count: i32 = len(signed);
    let mut idx: i32 = 0;
    while idx < count {
        if type_id == signed[idx] {
            return true;
        }
        idx = idx + 1;
    };
    false
}

fn constant_eval_integer_type_supported(type_id: i32) -> bool {
    if !type_id_is_integer(type_id) {
        return false;
    }
    if type_id_is_64_bit_integer(type_id) {
        return false;
    }
    true
}

fn normalize_integer_value(value: i32, type_id: i32) -> i32 {
    let width: i32 = integer_type_bit_width(type_id);
    if width < 0 {
        return value;
    }
    if width >= 32 {
        return value;
    }
    let mask: i32 = (1 << width) - 1;
    let masked: i32 = value & mask;
    if type_id_is_signed_integer(type_id) {
        let shift: i32 = 32 - width;
        return (masked << shift) >> shift;
    }
    masked
}

fn convert_constant_value(
    ast_base: i32,
    value_ptr: i32,
    current_type: i32,
    target_type: i32,
) -> i32 {
    if target_type < 0 {
        return -1;
    }
    if current_type < 0 {
        return -1;
    }
    if current_type == target_type {
        if type_id_is_integer(target_type) {
            let normalized: i32 = normalize_integer_value(load_i32(value_ptr), target_type);
            store_i32(value_ptr, normalized);
            return target_type;
        }
        if target_type == BUILTIN_TYPE_ID_BOOL {
            let normalized: i32 = if load_i32(value_ptr) != 0 { 1 } else { 0 };
            store_i32(value_ptr, normalized);
            return target_type;
        }
        if type_id_is_array(target_type) {
            let length: i32 = array_type_length(ast_base, target_type);
            if length <= 0 {
                return target_type;
            }
            let data_ptr: i32 = load_i32(value_ptr);
            if data_ptr <= 0 {
                return -1;
            }
            let element_type: i32 = array_type_element_type(ast_base, target_type);
            if element_type < 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < length {
                let slot_ptr: i32 = data_ptr + idx * 2 * WORD_SIZE;
                let element_value_ptr: i32 = slot_ptr;
                let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
                let current_element_type: i32 = load_i32(element_type_ptr);
                let converted_element: i32 = convert_constant_value(
                    ast_base,
                    element_value_ptr,
                    current_element_type,
                    element_type,
                );
                if converted_element < 0 {
                    return -1;
                }
                store_i32(element_type_ptr, converted_element);
                idx = idx + 1;
            };
            return target_type;
        }
        if type_id_is_tuple(target_type) {
            let tuple_idx: i32 = tuple_type_index(target_type);
            if tuple_idx < 0 {
                return -1;
            }
            let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
            if element_count <= 0 {
                return target_type;
            }
            let tuple_data_ptr: i32 = load_i32(value_ptr);
            if tuple_data_ptr <= 0 {
                return -1;
            }
            let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
            if elements_ptr < 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < element_count {
                let slot_ptr: i32 = tuple_data_ptr + idx * 2 * WORD_SIZE;
                let element_value_ptr: i32 = slot_ptr;
                let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
                let current_element_type: i32 = load_i32(element_type_ptr);
                let field_type: i32 = load_i32(elements_ptr + idx * WORD_SIZE);
                let converted_field: i32 = convert_constant_value(
                    ast_base,
                    element_value_ptr,
                    current_element_type,
                    field_type,
                );
                if converted_field < 0 {
                    return -1;
                }
                store_i32(element_type_ptr, converted_field);
                idx = idx + 1;
            };
            return target_type;
        }
        return target_type;
    }
    if current_type == BUILTIN_TYPE_ID_TYPE {
        let recorded_type_id: i32 = load_i32(value_ptr);
        if materialize_type_like_value_into(
            ast_base,
            recorded_type_id,
            target_type,
            value_ptr,
            0,
        ) < 0 {
            return -1;
        }
        return target_type;
    }
    if type_id_is_integer(current_type) && type_id_is_integer(target_type) {
        let normalized: i32 = normalize_integer_value(load_i32(value_ptr), current_type);
        let cast_value: i32 = normalize_integer_value(normalized, target_type);
        store_i32(value_ptr, cast_value);
        return target_type;
    }
    if current_type == BUILTIN_TYPE_ID_BOOL && target_type == BUILTIN_TYPE_ID_BOOL {
        let normalized: i32 = if load_i32(value_ptr) != 0 { 1 } else { 0 };
        store_i32(value_ptr, normalized);
        return target_type;
    }
    if type_id_is_array(current_type) && type_id_is_array(target_type) {
        let value_length: i32 = array_type_length(ast_base, current_type);
        let target_length: i32 = array_type_length(ast_base, target_type);
        if value_length != target_length {
            return -1;
        }
        let data_ptr: i32 = load_i32(value_ptr);
        if value_length > 0 {
            if data_ptr <= 0 {
                return -1;
            }
        }
        let value_element_type: i32 = array_type_element_type(ast_base, current_type);
        let target_element_type: i32 = array_type_element_type(ast_base, target_type);
        if value_element_type < 0 || target_element_type < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < value_length {
            let slot_ptr: i32 = data_ptr + idx * 2 * WORD_SIZE;
            let element_value_ptr: i32 = slot_ptr;
            let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
            let current_element_type: i32 = load_i32(element_type_ptr);
            let converted_element: i32 = convert_constant_value(
                ast_base,
                element_value_ptr,
                current_element_type,
                target_element_type,
            );
            if converted_element < 0 {
                return -1;
            }
            store_i32(element_type_ptr, converted_element);
            idx = idx + 1;
        };
        store_i32(value_ptr, data_ptr);
        return target_type;
    }
    if type_id_is_tuple(current_type) && type_id_is_tuple(target_type) {
        let value_idx: i32 = tuple_type_index(current_type);
        let target_idx: i32 = tuple_type_index(target_type);
        if value_idx < 0 || target_idx < 0 {
            return -1;
        }
        let value_count: i32 = ast_tuple_type_element_count(ast_base, value_idx);
        let target_count: i32 = ast_tuple_type_element_count(ast_base, target_idx);
        if value_count != target_count {
            return -1;
        }
        let tuple_data_ptr: i32 = load_i32(value_ptr);
        if value_count > 0 {
            if tuple_data_ptr <= 0 {
                return -1;
            }
        }
        let value_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, value_idx);
        let target_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, target_idx);
        if value_elements_ptr < 0 || target_elements_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < value_count {
            let slot_ptr: i32 = tuple_data_ptr + idx * 2 * WORD_SIZE;
            let element_value_ptr: i32 = slot_ptr;
            let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
            let current_element_type: i32 = load_i32(element_type_ptr);
            let field_type: i32 = load_i32(target_elements_ptr + idx * WORD_SIZE);
            let converted_field: i32 = convert_constant_value(
                ast_base,
                element_value_ptr,
                current_element_type,
                field_type,
            );
            if converted_field < 0 {
                return -1;
            }
            store_i32(element_type_ptr, converted_field);
            idx = idx + 1;
        };
        store_i32(value_ptr, tuple_data_ptr);
        return target_type;
    }
    -1
}

fn compare_unsigned(a: i32, b: i32) -> i32 {
    let a_sign: i32 = a >> 31;
    let b_sign: i32 = b >> 31;
    if a_sign != b_sign {
        if a_sign == 0 {
            return -1;
        }
        return 1;
    }
    if a < b {
        return -1;
    }
    if a > b {
        return 1;
    }
    0
}

fn logical_shr(value: i32, amount: i32) -> i32 {
    if amount <= 0 {
        return value;
    }
    if amount >= 32 {
        return 0;
    }
    let mut count: i32 = 0;
    let mut current: i32 = value;
    while count < amount {
        let shifted: i32 = current >> 1;
        if current < 0 {
            current = shifted & 2147483647;
        } else {
            current = shifted;
        }
        count = count + 1;
    };
    current
}

fn type_id_is_64_bit_integer(type_id: i32) -> bool {
    let variant_index: i32 = integer_type_variant_index(type_id);
    if variant_index < 0 {
        return false;
    }
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[variant_index] == 64
}








fn builtin_integer_variant_width(index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    }
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[index]
}

fn builtin_signed_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    }
    let signed: [i32; 4] = [
        BUILTIN_TYPE_ID_I8,
        BUILTIN_TYPE_ID_I16,
        BUILTIN_TYPE_ID_I32,
        BUILTIN_TYPE_ID_I64,
    ];
    signed[index]
}

fn builtin_unsigned_integer_type_id_for_variant(index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if index >= BUILTIN_INTEGER_VARIANT_COUNT {
        return -1;
    }
    let unsigned: [i32; 4] = [
        BUILTIN_TYPE_ID_U8,
        BUILTIN_TYPE_ID_U16,
        BUILTIN_TYPE_ID_U32,
        BUILTIN_TYPE_ID_U64,
    ];
    unsigned[index]
}

fn builtin_integer_type_keyword_to_id(base: i32, start: i32, ident_len: i32) -> i32 {
    if ident_len <= 1 {
        return -1;
    }
    let first: i32 = load_u8(base + start);
    if first != 'i' && first != 'u' {
        return -1;
    }
    let mut idx: i32 = 1;
    let mut width: i32 = 0;
    while idx < ident_len {
        let digit: i32 = load_u8(base + start + idx);
        if !is_digit(digit) {
            return -1;
        }
        width = width * 10 + (digit - '0');
        idx = idx + 1;
    };
    let variant_count: i32 = BUILTIN_INTEGER_VARIANT_COUNT;
    let mut variant_index: i32 = 0;
    while variant_index < variant_count {
        let expected_width: i32 = builtin_integer_variant_width(variant_index);
        if expected_width == width {
            if first == 'i' {
                return builtin_signed_integer_type_id_for_variant(variant_index);
            }
            return builtin_unsigned_integer_type_id_for_variant(variant_index);
        }
        variant_index = variant_index + 1;
    };
    -1
}

fn parse_type_expression(
    base: i32,
    len: i32,
    offset: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    type_template_sink_ptr: i32,
    out_type_ptr: i32,
) -> i32 {
    let scratch_base: i32 = parser_temp_scratch_base(ast_base, params_table_ptr);
    let expr_kind_ptr: i32 = scratch_base;
    let expr_data0_ptr: i32 = expr_kind_ptr + 4;
    let expr_data1_ptr: i32 = expr_data0_ptr + 4;
    let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
    let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
    let locals_next_index_ptr: i32 = locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
    let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
    let expr_temp_base: i32 = loop_depth_ptr + 4;
    store_i32(locals_stack_count_ptr, 0);
    store_i32(locals_next_index_ptr, 0);
    store_i32(loop_depth_ptr, 0);
    let expr_cursor: i32 = parse_expression(
        base,
        len,
        offset,
        ast_base,
        params_table_ptr,
        params_count,
        const_mask_table_ptr,
        locals_table_ptr,
        locals_stack_count_ptr,
        locals_next_index_ptr,
        expr_temp_base,
        loop_depth_ptr,
        type_template_sink_ptr,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
    );
    if expr_cursor < 0 {
        return -1;
    }
    let value_ptr: i32 = expr_temp_base;
    let type_ptr: i32 = value_ptr + 4;
    let eval_scratch_base: i32 = type_ptr + 4;
    if evaluate_expression_literal(
        ast_base,
        expr_kind_ptr,
        expr_data0_ptr,
        expr_data1_ptr,
        eval_scratch_base,
        value_ptr,
        type_ptr,
    ) < 0 {
        if type_template_sink_ptr <= 0 {
            return -1;
        }
        let template_handle: i32 = type_template_capture_expression_template(
            ast_base,
            expr_kind_ptr,
            expr_data0_ptr,
            expr_data1_ptr,
            params_count,
            const_mask_table_ptr,
            -1,
            eval_scratch_base,
            TYPE_TEMPLATE_KIND_TYPE_EXPR,
        );
        if template_handle < 0 {
            let expr_kind: i32 = load_i32(expr_kind_ptr);
            let expr_data0: i32 = load_i32(expr_data0_ptr);
            let expr_data1: i32 = load_i32(expr_data1_ptr);
            let mut expr_index: i32 = -1;
            if expr_kind == 2 {
                expr_index = expr_data0;
            } else {
                expr_index = expression_node_from_parts(
                    ast_base,
                    expr_kind,
                    expr_data0,
                    expr_data1,
                );
                if expr_index >= 0 {
                    store_expression_parts(
                        expr_kind_ptr,
                        expr_data0_ptr,
                        expr_data1_ptr,
                        ExpressionParts {
                            kind: 2,
                            data0: expr_index,
                            data1: 0,
                        },
                    );
                }
            }
            if expr_index >= 0 {
                let expr_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
                if load_i32(expr_entry_ptr) == 1 {
                    let location_offset: i32 = load_i32(expr_entry_ptr + 12);
                    let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
                    if detail_out_ptr > 0 {
                        if load_u8(detail_out_ptr) == 0 {
                            write_failure_detail_with_location(
                                detail_out_ptr,
                                scratch_module_index(detail_out_ptr),
                                base,
                                len,
                                location_offset,
                                47,
                                "const parameter template expected type mismatch",
                            );
                        }
                    }
                }
            }
            return -1;
        }
        store_i32(type_template_sink_ptr, template_handle);
        store_i32(type_template_sink_ptr + 4, -1);
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, -1);
        }
        return expr_cursor;
    }
    let expr_type: i32 = load_i32(type_ptr);
    if expr_type != BUILTIN_TYPE_ID_TYPE {
        let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
        if detail_out_ptr > 0 {
            if load_u8(detail_out_ptr) == 0 {
                write_failure_detail_with_location(
                    detail_out_ptr,
                    scratch_module_index(detail_out_ptr),
                    base,
                    len,
                    offset,
                    42,
                    "type annotations require const type values",
                );
            }
        }
        return -1;
    }
    let expr_value: i32 = load_i32(value_ptr);
    if expr_value < 0 {
        return -1;
    }
    if out_type_ptr >= 0 {
        store_i32(out_type_ptr, expr_value);
    }
    expr_cursor
}

fn parse_type(
    base: i32,
    len: i32,
    offset: i32,
    ast_base: i32,
    params_table_ptr: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    type_template_sink_ptr: i32,
    out_type_ptr: i32,
) -> i32 {
    if offset >= len {
        return -1;
    }
    let first: i32 = load_u8(base + offset);
    if first == '[' {
        if out_type_ptr < 0 {
            return -1;
        }
        let mut cursor: i32 = offset + 1;
        cursor = skip_whitespace(base, len, cursor);
        cursor = parse_type(
            base,
            len,
            cursor,
            ast_base,
            params_table_ptr,
            params_count,
            const_mask_table_ptr,
            type_template_sink_ptr,
            out_type_ptr,
        );
        if cursor < 0 {
            return -1;
        }
        let element_type_id: i32 = load_i32(out_type_ptr);
        if element_type_id < 0 {
            if type_template_sink_ptr > 0 {
                store_i32(type_template_sink_ptr, 0);
                store_i32(type_template_sink_ptr + 4, 0);
            }
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, 0);
            }
            return parse_type_expression(
                base,
                len,
                offset,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                type_template_sink_ptr,
                out_type_ptr,
            );
        }
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ';');
        if cursor < 0 {
            return -1;
        }
        cursor = skip_whitespace(base, len, cursor);
        let literal_base: i32 = parser_temp_scratch_base(ast_base, params_table_ptr);
        let literal_ptr: i32 = literal_base;
        let literal_cursor: i32 = parse_i32_literal(base, len, cursor, literal_ptr);
        let mut length: i32 = -1;
        let mut has_length_template: bool = false;
        let mut length_template_handle: i32 = 0;
        if literal_cursor >= 0 {
            length = load_i32(literal_ptr);
            if length < 0 {
                return -1;
            }
            cursor = literal_cursor;
        } else {
            let temp_base: i32 = literal_base;
            let expr_kind_ptr: i32 = temp_base;
            let expr_data0_ptr: i32 = expr_kind_ptr + 4;
            let expr_data1_ptr: i32 = expr_kind_ptr + 8;
            let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
            let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
            let locals_next_index_ptr: i32 =
                locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
            let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
            let expr_temp_base: i32 = loop_depth_ptr + 4;
            store_i32(locals_stack_count_ptr, 0);
            store_i32(locals_next_index_ptr, 0);
            store_i32(loop_depth_ptr, 0);
            cursor = parse_expression(
                base,
                len,
                cursor,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                locals_table_ptr,
                locals_stack_count_ptr,
                locals_next_index_ptr,
                expr_temp_base,
                loop_depth_ptr,
                type_template_sink_ptr,
                expr_kind_ptr,
                expr_data0_ptr,
                expr_data1_ptr,
            );
            if cursor < 0 {
                return -1;
            }
            let length_value_ptr: i32 = expr_temp_base;
            let length_type_ptr: i32 = length_value_ptr + 4;
            let length_scratch_base: i32 = length_type_ptr + 4;
            if evaluate_expression_literal(
                ast_base,
                expr_kind_ptr,
                expr_data0_ptr,
                expr_data1_ptr,
                length_scratch_base,
                length_value_ptr,
                length_type_ptr,
            ) < 0 {
                let template_handle: i32 = type_template_capture_array_length(
                    ast_base,
                    expr_kind_ptr,
                    expr_data0_ptr,
                    expr_data1_ptr,
                    params_count,
                    const_mask_table_ptr,
                    element_type_id,
                    length_scratch_base,
                );
                if template_handle < 0 {
                    return -1;
                }
                if type_template_sink_ptr <= 0 {
                    return -1;
                }
                has_length_template = true;
                length_template_handle = template_handle;
            } else {
                let length_type: i32 = load_i32(length_type_ptr);
                if !constant_eval_integer_type_supported(length_type) {
                    return -1;
                }
                length = normalize_integer_value(load_i32(length_value_ptr), length_type);
                if length < 0 {
                    return -1;
                }
            }
        }
        cursor = skip_whitespace(base, len, cursor);
        cursor = expect_char(base, len, cursor, ']');
        if cursor < 0 {
            return -1;
        }
        if has_length_template {
            if type_template_sink_ptr <= 0 {
                return -1;
            }
            store_i32(type_template_sink_ptr, length_template_handle);
            store_i32(type_template_sink_ptr + 4, element_type_id);
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, -1);
            }
            return cursor;
        }
        let type_id: i32 = ast_register_array_type(ast_base, element_type_id, length);
        if type_id < 0 {
            let detail_out_ptr: i32 = ast_base - ast_output_reserve(len);
            if detail_out_ptr > 0 {
                if load_u8(detail_out_ptr) == 0 {
                    write_failure_detail_with_location(
                        detail_out_ptr,
                        scratch_module_index(detail_out_ptr),
                        base,
                        len,
                        offset,
                        34,
                        "array type table capacity exceeded",
                    );
                }
            }
            return -1;
        }
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        }
        return cursor;
    }
    if first == '(' {
        let mut cursor: i32 = offset + 1;
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            return -1;
        }
        let next_byte: i32 = load_u8(base + cursor);
        if next_byte == ')' {
            let type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
            if type_id < 0 {
                return -1;
            }
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, type_id);
            }
            return cursor + 1;
        }
        if out_type_ptr < 0 {
            return -1;
        }
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let mut element_count: i32 = 0;
        let mut elements_ptr: i32 = -1;
        cursor = parse_type(
            base,
            len,
            cursor,
            ast_base,
            params_table_ptr,
            params_count,
            const_mask_table_ptr,
            type_template_sink_ptr,
            out_type_ptr,
        );
        if cursor < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let first_type_id: i32 = load_i32(out_type_ptr);
        if first_type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            if type_template_sink_ptr > 0 {
                store_i32(type_template_sink_ptr, 0);
                store_i32(type_template_sink_ptr + 4, 0);
            }
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, 0);
            }
            return parse_type_expression(
                base,
                len,
                offset,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                type_template_sink_ptr,
                out_type_ptr,
            );
        }
        cursor = skip_whitespace(base, len, cursor);
        if cursor >= len {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let mut delimiter: i32 = load_u8(base + cursor);
        if delimiter == ')' {
            return cursor + 1;
        }
        if delimiter != ',' {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        elements_ptr = ast_call_data_alloc(ast_base, 1);
        if elements_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        store_i32(elements_ptr, first_type_id);
        element_count = 1;
        let mut tuple_cursor: i32 = skip_whitespace(base, len, cursor + 1);
        loop {
            if tuple_cursor >= len {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            let tuple_byte: i32 = load_u8(base + tuple_cursor);
            if tuple_byte == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            }
            if element_count >= MAX_TUPLE_ELEMENTS {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            let element_ptr: i32 = ast_call_data_alloc(ast_base, 1);
            if element_ptr < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            tuple_cursor = parse_type(
                base,
                len,
                tuple_cursor,
                ast_base,
                params_table_ptr,
                params_count,
                const_mask_table_ptr,
                type_template_sink_ptr,
                element_ptr,
            );
            if tuple_cursor < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            let element_type_id: i32 = load_i32(element_ptr);
            if element_type_id < 0 {
                store_i32(call_data_used_ptr, saved_used);
                if type_template_sink_ptr > 0 {
                    store_i32(type_template_sink_ptr, 0);
                    store_i32(type_template_sink_ptr + 4, 0);
                }
                if out_type_ptr >= 0 {
                    store_i32(out_type_ptr, 0);
                }
                return parse_type_expression(
                    base,
                    len,
                    offset,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    const_mask_table_ptr,
                    type_template_sink_ptr,
                    out_type_ptr,
                );
            }
            element_count = element_count + 1;
            tuple_cursor = skip_whitespace(base, len, tuple_cursor);
            if tuple_cursor >= len {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            delimiter = load_u8(base + tuple_cursor);
            if delimiter == ',' {
                tuple_cursor = skip_whitespace(base, len, tuple_cursor + 1);
                continue;
            }
            if delimiter == ')' {
                tuple_cursor = tuple_cursor + 1;
                break;
            }
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let type_id: i32 = ast_register_tuple_type(ast_base, elements_ptr, element_count);
        if type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        }
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        }
        return tuple_cursor;
    }
    if !is_identifier_start(first) {
        return -1;
    }
    let mut next: i32 = offset + 1;
    while next < len {
        let byte: i32 = load_u8(base + next);
        if !is_identifier_continue(byte) {
            break;
        }
        next = next + 1;
    };
    let ident_len: i32 = next - offset;
    if ident_len <= 0 {
        return -1;
    }
    let type_id: i32 = builtin_integer_type_keyword_to_id(base, offset, ident_len);
    if type_id >= 0 {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, type_id);
        }
        return next;
    }
    if identifier_matches_keyword(base, len, offset, ident_len, 4, "bool") {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        }
        return next;
    }
    if identifier_matches_keyword(base, len, offset, ident_len, 4, "type") {
        if out_type_ptr >= 0 {
            store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
        }
        return next;
    }
    if params_table_ptr > 0 && params_count > 0 {
        let param_index: i32 =
            find_parameter_index(base, params_table_ptr, params_count, offset, ident_len);
        if param_index >= 0 {
            if const_mask_table_ptr <= 0 { return -1; }
            let mask_word_index: i32 = param_index >> 5;
            let mask_word_ptr: i32 = const_mask_table_ptr + mask_word_index * WORD_SIZE;
            let mask_word_value: i32 = load_i32(mask_word_ptr);
            let mask_bit_index: i32 = param_index & 31;
            let mask_bit: i32 = 1 << mask_bit_index;
            if (mask_word_value & mask_bit) == 0 { return -1; }
            let param_types_table_ptr: i32 = params_table_ptr + MAX_PARAMS * 8;
            let param_type_id: i32 =
                load_i32(param_types_table_ptr + param_index * WORD_SIZE);
            if param_type_id == BUILTIN_TYPE_ID_TYPE {
                if type_template_sink_ptr <= 0 { return -1; }
                let scratch_base: i32 = parser_temp_scratch_base(ast_base, params_table_ptr);
                let expr_kind_ptr: i32 = scratch_base;
                let expr_data0_ptr: i32 = expr_kind_ptr + 4;
                let expr_data1_ptr: i32 = expr_kind_ptr + 8;
                store_i32(expr_kind_ptr, 6);
                store_i32(expr_data0_ptr, param_index);
                store_i32(expr_data1_ptr, param_type_id);
                let capture_scratch_base: i32 = expr_kind_ptr + 12;
                let template_handle: i32 = type_template_capture_expression_template(
                    ast_base,
                    expr_kind_ptr,
                    expr_data0_ptr,
                    expr_data1_ptr,
                    params_count,
                    const_mask_table_ptr,
                    -1,
                    capture_scratch_base,
                    TYPE_TEMPLATE_KIND_TYPE_EXPR,
                );
                if template_handle < 0 { return -1; }
                store_i32(type_template_sink_ptr, template_handle);
                store_i32(type_template_sink_ptr + 4, -1);
                if out_type_ptr >= 0 {
                    store_i32(out_type_ptr, -1);
                }
                return next;
            }
        }
    }
    let const_index: i32 =
        find_constant_entry_index(base, ast_base, offset, ident_len, true);
    if const_index >= 0 {
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_index);
        if interpret_constant_entry(ast_base, const_entry_ptr) < 0 {
            return -1;
        }
        let const_type: i32 = ast_constant_entry_type(const_entry_ptr);
        if const_type == BUILTIN_TYPE_ID_TYPE {
            let const_value: i32 = ast_constant_entry_value(const_entry_ptr);
            if const_value < 0 {
                return -1;
            }
            if out_type_ptr >= 0 {
                store_i32(out_type_ptr, const_value);
            }
            return next;
        }
        let mut suffix_cursor: i32 = skip_whitespace(base, len, next);
        if suffix_cursor < len {
            let suffix_byte: i32 = load_u8(base + suffix_cursor);
            if suffix_byte == '[' {
                if !type_id_is_array(const_type) {
                    return parse_type_expression(
                        base,
                        len,
                        offset,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        const_mask_table_ptr,
                        type_template_sink_ptr,
                        out_type_ptr,
                    );
                }
                let element_type_id: i32 = array_type_element_type(ast_base, const_type);
                if element_type_id < 0 {
                    return -1;
                }
                if !type_id_contains_only_type_values(ast_base, element_type_id) {
                    return -1;
                }
                suffix_cursor = expect_char(base, len, suffix_cursor, '[');
                if suffix_cursor < 0 {
                    return -1;
                }
                suffix_cursor = skip_whitespace(base, len, suffix_cursor);
                let temp_base: i32 = parser_temp_scratch_base(ast_base, params_table_ptr);
                let expr_kind_ptr: i32 = temp_base;
                let expr_data0_ptr: i32 = expr_kind_ptr + 4;
                let expr_data1_ptr: i32 = expr_data0_ptr + 4;
                let locals_stack_count_ptr: i32 = expr_kind_ptr + 12;
                let locals_table_ptr: i32 = locals_stack_count_ptr + 4;
                let locals_next_index_ptr: i32 =
                    locals_table_ptr + MAX_LOCALS * LOCALS_ENTRY_SIZE;
                let loop_depth_ptr: i32 = locals_next_index_ptr + 4;
                let expr_temp_base: i32 = loop_depth_ptr + 4;
                store_i32(locals_stack_count_ptr, 0);
                store_i32(locals_next_index_ptr, 0);
                store_i32(loop_depth_ptr, 0);
                let expr_cursor: i32 = parse_expression(
                    base,
                    len,
                    suffix_cursor,
                    ast_base,
                    params_table_ptr,
                    params_count,
                    const_mask_table_ptr,
                    locals_table_ptr,
                    locals_stack_count_ptr,
                    locals_next_index_ptr,
                    expr_temp_base,
                    loop_depth_ptr,
                    type_template_sink_ptr,
                    expr_kind_ptr,
                    expr_data0_ptr,
                    expr_data1_ptr,
                );
                if expr_cursor < 0 {
                    return -1;
                }
                let index_value_ptr: i32 = expr_temp_base;
                let index_type_ptr: i32 = index_value_ptr + 4;
                let eval_scratch_base: i32 = index_type_ptr + 4;
                if evaluate_expression_literal(
                    ast_base,
                    expr_kind_ptr,
                    expr_data0_ptr,
                    expr_data1_ptr,
                    eval_scratch_base,
                    index_value_ptr,
                    index_type_ptr,
                ) < 0 {
                    return -1;
                }
                let index_type: i32 = load_i32(index_type_ptr);
                if !constant_eval_integer_type_supported(index_type) {
                    return -1;
                }
                let normalized_index: i32 = normalize_integer_value(
                    load_i32(index_value_ptr),
                    index_type,
                );
                if normalized_index < 0 {
                    return -1;
                }
                suffix_cursor = skip_whitespace(base, len, expr_cursor);
                suffix_cursor = expect_char(base, len, suffix_cursor, ']');
                if suffix_cursor < 0 {
                    return -1;
                }
                let array_length: i32 = array_type_length(ast_base, const_type);
                if array_length < 0 {
                    return -1;
                }
                if normalized_index >= array_length {
                    return -1;
                }
                let array_value_ptr: i32 = ast_constant_entry_value(const_entry_ptr);
                if array_length > 0 {
                    if array_value_ptr <= 0 {
                        return -1;
                    }
                }
                let slot_ptr: i32 =
                    array_value_ptr + normalized_index * 2 * WORD_SIZE;
                let recorded_type_id: i32 = load_i32(slot_ptr + WORD_SIZE);
                if recorded_type_id != BUILTIN_TYPE_ID_TYPE {
                    return -1;
                }
                let element_value: i32 = load_i32(slot_ptr);
                if element_value < 0 {
                    return -1;
                }
                if out_type_ptr >= 0 {
                    store_i32(out_type_ptr, element_value);
                }
                return suffix_cursor;
            }
            if suffix_byte == '.' {
                if !type_id_is_tuple(const_type) {
                    return parse_type_expression(
                        base,
                        len,
                        offset,
                        ast_base,
                        params_table_ptr,
                        params_count,
                        const_mask_table_ptr,
                        type_template_sink_ptr,
                        out_type_ptr,
                    );
                }
                let tuple_index: i32 = tuple_type_index(const_type);
                if tuple_index < 0 {
                    return -1;
                }
                if ensure_tuple_type_metadata(0, ast_base, tuple_index, const_type) < 0 {
                    return -1;
                }
                let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_index);
                if element_count < 0 {
                    return -1;
                }
                let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_index);
                if elements_ptr < 0 {
                    return -1;
                }
                let field_start: i32 = skip_whitespace(base, len, suffix_cursor + 1);
                if field_start >= len {
                    return -1;
                }
                let mut field_cursor: i32 = field_start;
                let mut field_digits: i32 = 0;
                while field_cursor < len {
                    let field_byte: i32 = load_u8(base + field_cursor);
                    if field_byte < '0' || field_byte > '9' {
                        break;
                    }
                    field_cursor = field_cursor + 1;
                    field_digits = field_digits + 1;
                };
                if field_digits <= 0 {
                    return -1;
                }
                let mut field_index: i32 = 0;
                let mut digit_idx: i32 = 0;
                while digit_idx < field_digits {
                    let digit_byte: i32 = load_u8(base + field_start + digit_idx);
                    field_index = field_index * 10 + (digit_byte - '0');
                    digit_idx = digit_idx + 1;
                };
                if field_index < 0 {
                    return -1;
                }
                if field_index >= element_count {
                    return -1;
                }
                let field_type_id: i32 = load_i32(elements_ptr + field_index * WORD_SIZE);
                if !type_id_contains_only_type_values(ast_base, field_type_id) {
                    return -1;
                }
                let tuple_value_ptr: i32 = ast_constant_entry_value(const_entry_ptr);
                if element_count > 0 {
                    if tuple_value_ptr <= 0 {
                        return -1;
                    }
                }
                let slot_ptr: i32 = tuple_value_ptr + field_index * 2 * WORD_SIZE;
                let recorded_type_id: i32 = load_i32(slot_ptr + WORD_SIZE);
                if recorded_type_id != BUILTIN_TYPE_ID_TYPE {
                    return -1;
                }
                let element_value: i32 = load_i32(slot_ptr);
                if element_value < 0 {
                    return -1;
                }
                if out_type_ptr >= 0 {
                    store_i32(out_type_ptr, element_value);
                }
                return field_cursor;
            }
        }
        return parse_type_expression(
            base,
            len,
            offset,
            ast_base,
            params_table_ptr,
            params_count,
            const_mask_table_ptr,
            type_template_sink_ptr,
            out_type_ptr,
        );
    }
    parse_type_expression(
        base,
        len,
        offset,
        ast_base,
        params_table_ptr,
        params_count,
        const_mask_table_ptr,
        type_template_sink_ptr,
        out_type_ptr,
    )
}

fn parse_i32_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    }
    let mut idx: i32 = offset;
    let mut sign: i32 = 1;
    let first: i32 = load_u8(base + idx);
    if first == '-' {
        sign = -1;
        idx = idx + 1;
        if idx >= len {
            return -1;
        }
    }
    if idx + 1 < len {
        let leading: i32 = load_u8(base + idx);
        let prefix: i32 = load_u8(base + idx + 1);
        if leading == '0' && (prefix == 'x' || prefix == 'X') {
            idx = idx + 2;
            let mut digits: i32 = 0;
            let mut value: i32 = 0;
            while idx < len {
                let byte: i32 = load_u8(base + idx);
                let hex: i32 = if byte >= '0' && byte <= '9' {
                    byte - '0'
                } else if byte >= 'a' && byte <= 'f' {
                    byte - 'a' + 10
                } else if byte >= 'A' && byte <= 'F' {
                    byte - 'A' + 10
                } else {
                    -1
                };
                if hex < 0 {
                    break;
                }
                value = value * 16 + hex;
                idx = idx + 1;
                digits = digits + 1;
            };
            if digits == 0 {
                return -1;
            }
            store_i32(out_value_ptr, value * sign);
            return idx;
        }
    }
    let mut digits: i32 = 0;
    let mut value: i32 = 0;
    while idx < len {
        let byte: i32 = load_u8(base + idx);
        if !is_digit(byte) {
            break;
        }
        value = value * 10 + (byte - '0');
        idx = idx + 1;
        digits = digits + 1;
    };
    if digits == 0 {
        return -1;
    }
    store_i32(out_value_ptr, value * sign);
    idx
}

fn parse_char_literal(base: i32, len: i32, offset: i32, out_value_ptr: i32) -> i32 {
    if offset >= len {
        return -1;
    }
    let quote: i32 = load_u8(base + offset);
    if quote != '\'' {
        return -1;
    }
    let mut idx: i32 = offset + 1;
    if idx >= len {
        return -1;
    }
    let mut value: i32 = load_u8(base + idx);
    if value == '\\' {
        idx = idx + 1;
        if idx >= len {
            return -1;
        }
        let escape: i32 = load_u8(base + idx);
        value = if escape == 'n' {
            '\n'
        } else if escape == 'r' {
            '\r'
        } else if escape == 't' {
            '\t'
        } else if escape == '0' {
            '\0'
        } else if escape == '\\' {
            '\\'
        } else if escape == '\'' {
            '\''
        } else {
            return -1;
        };
    } else if value == '\n' || value == '\r' {
        return -1;
    }
    idx = idx + 1;
    if idx >= len {
        return -1;
    }
    let closing: i32 = load_u8(base + idx);
    if closing != '\'' {
        return -1;
    }
    store_i32(out_value_ptr, value);
    idx + 1
}

