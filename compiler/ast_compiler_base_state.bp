use "./ast_compiler_base_lexing.bp";

const WORD_SIZE: i32 = 4;

const SCRATCH_TYPE_METADATA_DEBUG_CONTEXT_OFFSET: i32 = 4032;

const SCRATCH_TYPE_METADATA_DEBUG_SUBJECT_OFFSET: i32 = 4036;

const SCRATCH_TYPE_METADATA_DEBUG_EXTRA_OFFSET: i32 = 4040;

const SCRATCH_TYPE_METADATA_DEBUG_FAILURE_COUNT_OFFSET: i32 = 4044;

const SCRATCH_FAILURE_PATH_PTR_OFFSET: i32 = 4048;

const SCRATCH_FAILURE_PATH_LEN_OFFSET: i32 = 4052;

const SCRATCH_FAILURE_LINE_OFFSET: i32 = 4056;

const SCRATCH_FAILURE_COLUMN_OFFSET: i32 = 4060;

const SCRATCH_FAILURE_CHARACTER_OFFSET: i32 = 4064;

const SCRATCH_FAILURE_OFFSET_OFFSET: i32 = 4068;
const CONST_ARRAY_DEBUG_EXPR_TYPE_OFFSET: i32 = 5000;
const CONST_ARRAY_DEBUG_ELEMENT_TYPE_OFFSET: i32 = 5004;
const CONST_ARRAY_DEBUG_ENV_COUNT_OFFSET: i32 = 5008;
const CONST_ARRAY_DEBUG_PARAM_COUNT_OFFSET: i32 = 5012;
const CONST_ARRAY_DEBUG_TREAT_AS_TYPE_OFFSET: i32 = 5016;
const TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET: i32 = 5020;
const TYPE_METADATA_DEBUG_LAST_SUBJECT_OFFSET: i32 = 5024;
const TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET: i32 = 5028;
const CONST_EVAL_DEBUG_EXPR_OFFSET: i32 = 5032;
const CONST_EVAL_DEBUG_KIND_OFFSET: i32 = 5036;
const CONST_EVAL_DEBUG_STEP_OFFSET: i32 = 5040;
const CONST_EVAL_DEBUG_LOCAL_OFFSET: i32 = 5044;
const CLONE_DEBUG_LOCAL_INDEX_OFFSET: i32 = 5048;
const CLONE_DEBUG_INIT_TYPE_OFFSET: i32 = 5052;
const CLONE_DEBUG_PUSHED_OFFSET: i32 = 5056;


const SCRATCH_MODULE_BASE_OFFSET: i32 = 4080;

const SCRATCH_MODULE_LEN_OFFSET: i32 = 4084;

const SCRATCH_MODULE_INDEX_OFFSET: i32 = 4088;

const SCRATCH_EXPR_TYPE_OFFSET: i32 = 4092;

const SCRATCH_INSTR_OFFSET: i32 = 4096;

const SCRATCH_INSTR_BASE_OFFSET: i32 = 8192;

const SCRATCH_INSTR_CAPACITY: i32 = 131072;

const SCRATCH_FN_COUNT_OFFSET: i32 = 917496;

const SCRATCH_FN_BASE_OFFSET: i32 = 917504;

const TYPE_ENTRY_SIZE: i32 = 16;

const TYPE_ENTRY_TYPE_ID_OFFSET: i32 = 0;

const TYPE_ENTRY_NAME_PTR_OFFSET: i32 = 4;

const TYPE_ENTRY_NAME_LEN_OFFSET: i32 = 8;

const TYPE_ENTRY_EXTRA_OFFSET: i32 = 12;

const SCRATCH_TYPES_BASE_OFFSET: i32 = SCRATCH_FN_BASE_OFFSET - SCRATCH_TYPES_CAPACITY * TYPE_ENTRY_SIZE;

const SCRATCH_TYPES_COUNT_OFFSET: i32 = SCRATCH_TYPES_BASE_OFFSET - WORD_SIZE;

const MODULE_STATE_BASE: i32 = 1048576;

const MODULE_COUNT_OFFSET: i32 = 0;

const MODULE_STORAGE_TOP_OFFSET: i32 = 4;

const MODULE_TABLE_OFFSET: i32 = 8;

const MODULE_MAX_COUNT: i32 = 256;

const MODULE_ENTRY_SIZE: i32 = 20;

const MODULE_PATH_PTR_OFFSET: i32 = 0;

const MODULE_PATH_LEN_OFFSET: i32 = 4;

const MODULE_CONTENT_PTR_OFFSET: i32 = 8;

const MODULE_CONTENT_LEN_OFFSET: i32 = 12;

const MODULE_FLAGS_OFFSET: i32 = 16;

const MODULE_FLAG_IMPORTED: i32 = 1;

const MODULE_FLAG_IMPORTING: i32 = 2;

const MODULE_PATH_MAX_LENGTH: i32 = 1024;

const MODULE_CONTENT_BASE_OFFSET: i32 = MODULE_TABLE_OFFSET + MODULE_MAX_COUNT * MODULE_ENTRY_SIZE;

fn module_count_ptr() -> i32 {
    MODULE_STATE_BASE + MODULE_COUNT_OFFSET
}

fn module_storage_top_ptr() -> i32 {
    MODULE_STATE_BASE + MODULE_STORAGE_TOP_OFFSET
}

fn module_table_base() -> i32 {
    MODULE_STATE_BASE + MODULE_TABLE_OFFSET
}

fn module_entry_ptr(index: i32) -> i32 {
    module_table_base() + index * MODULE_ENTRY_SIZE
}

fn module_entry_path_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_PATH_PTR_OFFSET
}

fn module_entry_path_len_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_PATH_LEN_OFFSET
}

fn module_entry_content_ptr_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_CONTENT_PTR_OFFSET
}

fn module_entry_content_len_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_CONTENT_LEN_OFFSET
}

fn module_entry_flags_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + MODULE_FLAGS_OFFSET
}

fn module_entry_flags(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_flags_ptr(entry_ptr))
}

fn module_entry_set_flags(index: i32, flags: i32) {
    let entry_ptr: i32 = module_entry_ptr(index);
    store_i32(module_entry_flags_ptr(entry_ptr), flags);
}

fn module_clear_flags() {
    let count: i32 = module_count();
    let mut idx: i32 = 0;
    while idx < count {
        module_entry_set_flags(idx, 0);
        idx = idx + 1;
    };
}

fn module_content_base() -> i32 {
    MODULE_STATE_BASE + MODULE_CONTENT_BASE_OFFSET
}

fn module_count() -> i32 {
    load_i32(module_count_ptr())
}

fn module_set_count(count: i32) {
    store_i32(module_count_ptr(), count);
}

fn module_storage_top() -> i32 {
    load_i32(module_storage_top_ptr())
}

fn module_set_storage_top(value: i32) {
    store_i32(module_storage_top_ptr(), value);
}

fn module_ensure_state_initialized() {
    let top: i32 = module_storage_top();
    if top == 0 {
        module_set_storage_top(module_content_base());
        module_set_count(0);
    }
}

fn resolve_module_failure_detail_ptr(detail_ptr: i32) -> i32 {
    if detail_ptr > 0 {
        return detail_ptr;
    }
    module_set_storage_top(module_content_base());
    module_storage_top()
}

fn module_allocate_bytes(len: i32) -> i32 {
    module_ensure_state_initialized();
    if len < 0 {
        return -1;
    }
    let mut top: i32 = module_storage_top();
    if top <= 0 {
        return -1;
    }
    top = align_to(top, WORD_SIZE);
    let start: i32 = top;
    let end: i32 = start + len;
    if ensure_memory_capacity(end + 1) < 0 {
        let detail_out_ptr: i32 = module_storage_top();
        if detail_out_ptr > 0 {
            write_failure_detail(detail_out_ptr, 50, "failed to reserve linear memory for module storage");
        }
        return -1;
    }
    module_set_storage_top(end);
    start
}

fn module_find_index(path_ptr: i32, path_len: i32) -> i32 {
    let count: i32 = module_count();
    if count <= 0 {
        return -1;
    }
    let mut index: i32 = 0;
    while index < count {
        let entry_ptr: i32 = module_entry_ptr(index);
        let stored_len: i32 = load_i32(module_entry_path_len_ptr(entry_ptr));
        if stored_len == path_len {
            let stored_ptr: i32 = load_i32(module_entry_path_ptr(entry_ptr));
            if stored_ptr > 0 && memory_equal(stored_ptr, path_ptr, path_len) {
                return index;
            }
        }
        index = index + 1;
    };
    -1
}

fn module_find_index_by_content_ptr(content_ptr: i32) -> i32 {
    if content_ptr <= 0 {
        return -1;
    }
    let count: i32 = module_count();
    if count <= 0 {
        return -1;
    }
    let mut index: i32 = 0;
    while index < count {
        if module_entry_content(index) == content_ptr {
            return index;
        }
        index = index + 1;
    };
    -1
}

fn module_entry_path(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_path_ptr(entry_ptr))
}

fn module_entry_path_len(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_path_len_ptr(entry_ptr))
}

fn module_entry_content(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_content_ptr_ptr(entry_ptr))
}

fn module_entry_content_len(index: i32) -> i32 {
    let entry_ptr: i32 = module_entry_ptr(index);
    load_i32(module_entry_content_len_ptr(entry_ptr))
}

fn module_write_entry(index: i32, path_ptr: i32, path_len: i32, content_ptr: i32, content_len: i32) {
    let entry_ptr: i32 = module_entry_ptr(index);
    store_i32(module_entry_path_ptr(entry_ptr), path_ptr);
    store_i32(module_entry_path_len_ptr(entry_ptr), path_len);
    store_i32(module_entry_content_ptr_ptr(entry_ptr), content_ptr);
    store_i32(module_entry_content_len_ptr(entry_ptr), content_len);
    store_i32(module_entry_flags_ptr(entry_ptr), 0);
}

fn scratch_instr_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_INSTR_OFFSET
}

fn scratch_expr_type_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_EXPR_TYPE_OFFSET
}

fn scratch_failure_path_ptr_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_PATH_PTR_OFFSET
}

fn scratch_failure_path_len_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_PATH_LEN_OFFSET
}

fn scratch_failure_line_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_LINE_OFFSET
}

fn scratch_failure_column_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_COLUMN_OFFSET
}

fn scratch_failure_character_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_CHARACTER_OFFSET
}

fn scratch_failure_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FAILURE_OFFSET_OFFSET
}

fn clear_failure_location(out_ptr: i32) {
    if out_ptr > 0 {
        let required: i32 = out_ptr + SCRATCH_FAILURE_OFFSET_OFFSET + WORD_SIZE;
        if ensure_memory_capacity(required) >= 0 {
            store_i32(scratch_failure_path_ptr_ptr(out_ptr), 0);
            store_i32(scratch_failure_path_len_ptr(out_ptr), 0);
            store_i32(scratch_failure_line_ptr(out_ptr), 0);
            store_i32(scratch_failure_column_ptr(out_ptr), 0);
            store_i32(scratch_failure_character_ptr(out_ptr), 0);
            store_i32(scratch_failure_offset_ptr(out_ptr), 0);
        }
    }
}

fn store_failure_detail_location(
    detail_out_ptr: i32,
    path_ptr: i32,
    path_len: i32,
    line: i32,
    column: i32,
) {
    if detail_out_ptr > 0 && path_ptr > 0 && path_len > 0 && line > 0 && column > 0 {
        store_i32(scratch_failure_path_ptr_ptr(detail_out_ptr), path_ptr);
        store_i32(scratch_failure_path_len_ptr(detail_out_ptr), path_len);
        store_i32(scratch_failure_line_ptr(detail_out_ptr), line);
        store_i32(scratch_failure_column_ptr(detail_out_ptr), column);
        store_i32(scratch_failure_character_ptr(detail_out_ptr), 1);
        store_i32(scratch_failure_offset_ptr(detail_out_ptr), 0);
    }
}

fn scratch_failure_path_ptr(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_path_ptr_ptr(out_ptr))
}

fn scratch_failure_path_len(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_path_len_ptr(out_ptr))
}

fn scratch_failure_line(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_line_ptr(out_ptr))
}

fn scratch_failure_column(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_column_ptr(out_ptr))
}

fn scratch_failure_character(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_character_ptr(out_ptr))
}

fn scratch_failure_offset(out_ptr: i32) -> i32 {
    load_i32(scratch_failure_offset_ptr(out_ptr))
}

fn scratch_module_base_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_MODULE_BASE_OFFSET
}

fn scratch_module_len_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_MODULE_LEN_OFFSET
}

fn scratch_module_index_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_MODULE_INDEX_OFFSET
}

fn scratch_module_base(out_ptr: i32) -> i32 {
    load_i32(scratch_module_base_ptr(out_ptr))
}

fn scratch_module_len(out_ptr: i32) -> i32 {
    load_i32(scratch_module_len_ptr(out_ptr))
}

fn scratch_module_index(out_ptr: i32) -> i32 {
    load_i32(scratch_module_index_ptr(out_ptr))
}

fn scratch_fn_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_FN_COUNT_OFFSET
}

fn scratch_types_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_TYPES_COUNT_OFFSET
}

fn scratch_types_base(out_ptr: i32) -> i32 {
    out_ptr + SCRATCH_TYPES_BASE_OFFSET
}

fn scratch_type_entry_ptr(out_ptr: i32, index: i32) -> i32 {
    scratch_types_base(out_ptr) + index * TYPE_ENTRY_SIZE
}

fn scratch_types_count(out_ptr: i32) -> i32 {
    load_i32(scratch_types_count_ptr(out_ptr))
}

fn scratch_types_set_count(out_ptr: i32, count: i32) {
    store_i32(scratch_types_count_ptr(out_ptr), count);
}

const AST_MAX_FUNCTIONS: i32 = 1024;

const AST_FUNCTION_ENTRY_SIZE: i32 = 60;

const FUNCTION_FLAG_CONST: i32 = 1;
const FUNCTION_FLAG_HAS_CONST_PARAMS: i32 = 2;

const AST_NAMES_CAPACITY: i32 = 131072;

const AST_CONSTANTS_CAPACITY: i32 = 1024;

const AST_CONSTANT_ENTRY_SIZE: i32 = 28;

const AST_CONSTANT_ENTRY_NAME_OFFSET: i32 = 0;

const AST_CONSTANT_ENTRY_NAME_LEN_OFFSET: i32 = 4;

const AST_CONSTANT_ENTRY_VALUE_OFFSET: i32 = 8;

const AST_CONSTANT_ENTRY_TYPE_OFFSET: i32 = 12;

const AST_CONSTANT_ENTRY_EXPR_INDEX_OFFSET: i32 = 16;

const AST_CONSTANT_ENTRY_EVAL_STATE_OFFSET: i32 = 20;

const AST_CONSTANT_ENTRY_MODULE_INDEX_OFFSET: i32 = 24;

const AST_CONSTANTS_SECTION_SIZE: i32 = WORD_SIZE + AST_CONSTANTS_CAPACITY * AST_CONSTANT_ENTRY_SIZE;

const AST_CONSTANTS_SECTION_WORDS: i32 = AST_CONSTANTS_SECTION_SIZE >> 2;

const AST_CALL_DATA_CAPACITY: i32 = 131072 - AST_CONSTANTS_SECTION_WORDS;

fn decimal_length(value: i32) -> i32 {
    if value <= 0 {
        return 1;
    }
    let mut digits: i32 = 0;
    let mut remaining: i32 = value;
    while remaining > 0 {
        digits = digits + 1;
        remaining = remaining / 10;
    };
    digits
}

fn append_decimal_component(detail_out_ptr: i32, write_offset: i32, value: i32) -> (i32, bool) {
    let mut offset: i32 = write_offset;
    let mut truncated: bool = false;
    let digits_len: i32 = decimal_length(value);
    let mut divisor: i32 = 1;
    let mut divisor_idx: i32 = 1;
    while divisor_idx < digits_len {
        divisor = divisor * 10;
        divisor_idx = divisor_idx + 1;
    };
    let mut remaining: i32 = if value <= 0 { 0 } else { value };
    let mut written: i32 = 0;
    while written < digits_len {
        if offset >= FAILURE_DETAIL_CAPACITY {
            truncated = true;
            break;
        }
        let digit: i32 = remaining / divisor;
        store_u8(detail_out_ptr + offset, digit + '0');
        offset = offset + 1;
        remaining = remaining - digit * divisor;
        written = written + 1;
        if divisor <= 1 {
            divisor = 1;
        } else {
            divisor = divisor / 10;
        }
    };
    (offset, truncated)
}

fn write_failure_detail_suffix(
    detail_out_ptr: i32,
    write_offset: i32,
    include_location: bool,
    line: i32,
    column: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) -> (i32, bool) {
    let mut offset: i32 = write_offset;
    let mut truncated: bool = false;
    if include_location {
        if offset < FAILURE_DETAIL_CAPACITY {
            store_u8(detail_out_ptr + offset, ':');
            offset = offset + 1;
        } else {
            truncated = true;
        }
        let line_result: (i32, bool) = append_decimal_component(detail_out_ptr, offset, line);
        offset = line_result.0;
        if line_result.1 {
            truncated = true;
        }
        if offset < FAILURE_DETAIL_CAPACITY {
            store_u8(detail_out_ptr + offset, ':');
            offset = offset + 1;
        } else {
            truncated = true;
        }
        let column_result: (i32, bool) = append_decimal_component(detail_out_ptr, offset, column);
        offset = column_result.0;
        if column_result.1 {
            truncated = true;
        }
        if offset < FAILURE_DETAIL_CAPACITY {
            store_u8(detail_out_ptr + offset, ':');
            offset = offset + 1;
        } else {
            truncated = true;
        }
        if offset < FAILURE_DETAIL_CAPACITY {
            store_u8(detail_out_ptr + offset, ' ');
            offset = offset + 1;
        } else {
            truncated = true;
        }
    }
    let mut message_idx: i32 = 0;
    while message_idx < MESSAGE_LEN {
        if offset >= FAILURE_DETAIL_CAPACITY {
            truncated = true;
            break;
        }
        let byte: i32 = message[message_idx] as i32;
        store_u8(detail_out_ptr + offset, byte);
        offset = offset + 1;
        message_idx = message_idx + 1;
    };
    (offset, truncated)
}

fn write_failure_detail(
    detail_out_ptr: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) {
    if detail_out_ptr > 0 {
        let path_ptr: i32 = scratch_failure_path_ptr(detail_out_ptr);
        let path_len: i32 = scratch_failure_path_len(detail_out_ptr);
        let line: i32 = scratch_failure_line(detail_out_ptr);
        let column: i32 = scratch_failure_column(detail_out_ptr);
        let mut write_offset: i32 = 0;
        let include_location: bool = path_ptr > 0 && path_len > 0 && line > 0 && column > 0;
        if include_location {
            let mut path_idx: i32 = 0;
            while path_idx < path_len {
                if write_offset >= FAILURE_DETAIL_CAPACITY {
                    break;
                }
                let byte: i32 = load_u8(path_ptr + path_idx);
                store_u8(detail_out_ptr + write_offset, byte);
                write_offset = write_offset + 1;
                path_idx = path_idx + 1;
            };
        }
        let suffix_result: (i32, bool) = write_failure_detail_suffix(
            detail_out_ptr,
            write_offset,
            include_location,
            line,
            column,
            MESSAGE_LEN,
            message,
        );
        write_offset = suffix_result.0;
        while write_offset < FAILURE_DETAIL_CAPACITY {
            store_u8(detail_out_ptr + write_offset, 0);
            write_offset = write_offset + 1;
        };
    }
}

fn ast_output_reserve(input_len: i32) -> i32 {
    let after_output: i32 = input_len + SCRATCH_INSTR_CAPACITY;
    let scratch_end: i32 = SCRATCH_FN_BASE_OFFSET + 16384;
    if after_output > scratch_end { after_output } else { scratch_end }
}

fn ast_program_base(out_ptr: i32, input_len: i32) -> i32 {
    out_ptr + ast_output_reserve(input_len)
}

fn ast_functions_count_ptr(ast_base: i32) -> i32 {
    ast_base
}

fn ast_functions_count(ast_base: i32) -> i32 {
    load_i32(ast_functions_count_ptr(ast_base))
}

fn ast_functions_set_count(ast_base: i32, count: i32) {
    store_i32(ast_functions_count_ptr(ast_base), count);
}

fn ast_function_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_base + WORD_SIZE + index * AST_FUNCTION_ENTRY_SIZE
}

fn ast_function_param_count(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_entry_ptr(ast_base, index) + 8)
}

fn ast_function_flags_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 32
}

fn ast_function_const_params_ptr_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 36
}

fn ast_function_template_owner_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 40
}

fn ast_function_entry_module_base_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 44
}

fn ast_function_entry_module_len_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 48
}

fn ast_function_entry_module_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 52
}

fn ast_function_entry_name_start_ptr(ast_base: i32, index: i32) -> i32 {
    ast_function_entry_ptr(ast_base, index) + 56
}

fn ast_function_flags(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_flags_ptr(ast_base, index))
}

fn ast_function_const_params_ptr(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_const_params_ptr_ptr(ast_base, index))
}

fn ast_function_template_owner_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_template_owner_index_ptr(ast_base, index))
}

fn ast_function_entry_module_base(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_entry_module_base_ptr(ast_base, index))
}

fn ast_function_entry_module_len(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_entry_module_len_ptr(ast_base, index))
}

fn ast_function_entry_module_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_entry_module_index_ptr(ast_base, index))
}

fn ast_function_entry_name_start(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_function_entry_name_start_ptr(ast_base, index))
}

fn ast_function_set_template_owner_index(ast_base: i32, index: i32, value: i32) {
    store_i32(ast_function_template_owner_index_ptr(ast_base, index), value);
}

fn ast_function_type_template_payload_ptr(ast_base: i32, index: i32) -> i32 {
    let raw_ptr: i32 = ast_function_template_owner_index(ast_base, index);
    if raw_ptr > 0 { raw_ptr } else { 0 }
}

fn ast_function_param_requires_specialization(
    ast_base: i32,
    index: i32,
    param_index: i32,
) -> bool {
    if param_index < 0 { return false; }
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return false; }
    if param_index >= ast_function_param_count(ast_base, index) {
        return false;
    }
    let handle_index: i32 =
        TYPE_TEMPLATE_PAYLOAD_PARAM_BASE_INDEX
        + param_index * TYPE_TEMPLATE_PAYLOAD_PARAM_STRIDE;
    let handle_ptr: i32 = payload_ptr + handle_index * WORD_SIZE;
    load_i32(handle_ptr) > 0
}

fn ast_function_param_template_payload(ast_base: i32, index: i32, param_index: i32) -> i32 {
    if param_index < 0 { return 0; }
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return 0; }
    if param_index >= ast_function_param_count(ast_base, index) {
        return 0;
    }
    let handle_index: i32 =
        TYPE_TEMPLATE_PAYLOAD_PARAM_BASE_INDEX
        + param_index * TYPE_TEMPLATE_PAYLOAD_PARAM_STRIDE;
    load_i32(payload_ptr + handle_index * WORD_SIZE)
}

fn ast_function_param_template_base_type(ast_base: i32, index: i32, param_index: i32) -> i32 {
    if param_index < 0 { return 0; }
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return 0; }
    if param_index >= ast_function_param_count(ast_base, index) {
        return 0;
    }
    let base_index: i32 =
        TYPE_TEMPLATE_PAYLOAD_PARAM_BASE_INDEX
        + param_index * TYPE_TEMPLATE_PAYLOAD_PARAM_STRIDE
        + 1;
    load_i32(payload_ptr + base_index * WORD_SIZE)
}

fn ast_function_return_requires_specialization(ast_base: i32, index: i32) -> bool {
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return false; }
    load_i32(payload_ptr + TYPE_TEMPLATE_PAYLOAD_RETURN_HANDLE_INDEX * WORD_SIZE) > 0
}

fn ast_function_return_template_payload(ast_base: i32, index: i32) -> i32 {
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return 0; }
    load_i32(payload_ptr + TYPE_TEMPLATE_PAYLOAD_RETURN_HANDLE_INDEX * WORD_SIZE)
}

fn ast_function_return_template_base_type(ast_base: i32, index: i32) -> i32 {
    let payload_ptr: i32 = ast_function_type_template_payload_ptr(ast_base, index);
    if payload_ptr <= 0 { return 0; }
    load_i32(payload_ptr + TYPE_TEMPLATE_PAYLOAD_RETURN_BASE_INDEX * WORD_SIZE)
}

fn ast_function_param_template_kind(ast_base: i32, index: i32, param_index: i32) -> i32 {
    let handle: i32 = ast_function_param_template_payload(ast_base, index, param_index);
    type_template_entry_kind(handle)
}

fn ast_function_return_template_kind(ast_base: i32, index: i32) -> i32 {
    let handle: i32 = ast_function_return_template_payload(ast_base, index);
    type_template_entry_kind(handle)
}

fn ast_function_is_const(ast_base: i32, index: i32) -> bool {
    (ast_function_flags(ast_base, index) & FUNCTION_FLAG_CONST) != 0
}

fn ast_function_has_const_params(ast_base: i32, index: i32) -> bool {
    (ast_function_flags(ast_base, index) & FUNCTION_FLAG_HAS_CONST_PARAMS) != 0
}

fn ast_function_const_params_count(ast_base: i32, index: i32) -> i32 {
    let ptr: i32 = ast_function_const_params_ptr(ast_base, index);
    if ptr <= 0 {
        return 0;
    }
    load_i32(ptr)
}

fn ast_function_const_params_mask_ptr(ast_base: i32, index: i32) -> i32 {
    let ptr: i32 = ast_function_const_params_ptr(ast_base, index);
    if ptr <= 0 {
        return 0;
    }
    ptr + WORD_SIZE
}

fn ast_function_param_is_const(ast_base: i32, index: i32, param_index: i32) -> bool {
    if param_index < 0 {
        return false;
    }
    if !ast_function_has_const_params(ast_base, index) {
        return false;
    }
    let param_count: i32 = ast_function_param_count(ast_base, index);
    if param_index >= param_count {
        return false;
    }
    let mask_ptr: i32 = ast_function_const_params_mask_ptr(ast_base, index);
    if mask_ptr <= 0 {
        return false;
    }
    let mut mask_word_count: i32 = (param_count + 31) >> 5;
    if mask_word_count <= 0 {
        mask_word_count = 1;
    }
    let mask_word_index: i32 = param_index >> 5;
    if mask_word_index >= mask_word_count {
        return false;
    }
    let mask_word_value: i32 = load_i32(mask_ptr + mask_word_index * WORD_SIZE);
    if mask_word_value == 0 {
        return false;
    }
    let mask_bit: i32 = 1 << (param_index & 31);
    (mask_word_value & mask_bit) != 0
}

fn ast_function_runtime_param_count(ast_base: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    let total_params: i32 = ast_function_param_count(ast_base, index);
    if total_params < 0 {
        return -1;
    }
    if !ast_function_has_const_params(ast_base, index) {
        return total_params;
    }
    let const_count: i32 = ast_function_const_params_count(ast_base, index);
    if const_count < 0 {
        return -1;
    }
    if const_count > total_params {
        return -1;
    }
    total_params - const_count
}

fn ast_function_param_runtime_index(
    ast_base: i32,
    index: i32,
    param_index: i32,
) -> i32 {
    if param_index < 0 {
        return -1;
    }
    let total_params: i32 = ast_function_param_count(ast_base, index);
    if param_index >= total_params {
        return -1;
    }
    if ast_function_param_is_const(ast_base, index, param_index) {
        return -1;
    }
    let mut runtime_index: i32 = 0;
    let mut scan_index: i32 = 0;
    while scan_index < param_index {
        if !ast_function_param_is_const(ast_base, index, scan_index) {
            runtime_index = runtime_index + 1;
        }
        scan_index = scan_index + 1;
    };
    runtime_index
}

fn const_specialization_keys_equal(existing_key_ptr: i32, query_key_ptr: i32) -> bool {
    if existing_key_ptr <= 0 {
        return false;
    }
    if query_key_ptr <= 0 {
        return false;
    }
    if existing_key_ptr == query_key_ptr {
        return true;
    }
    let existing_count: i32 = load_i32(existing_key_ptr);
    let query_count: i32 = load_i32(query_key_ptr);
    if existing_count < 0 {
        return false;
    }
    if existing_count != query_count {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < existing_count {
        let existing_entry_ptr: i32 =
            existing_key_ptr + WORD_SIZE + idx * 3 * WORD_SIZE;
        let query_entry_ptr: i32 = query_key_ptr + WORD_SIZE + idx * 3 * WORD_SIZE;
        let existing_param: i32 = load_i32(existing_entry_ptr);
        let query_param: i32 = load_i32(query_entry_ptr);
        if existing_param != query_param {
            return false;
        }
        let existing_value: i32 = load_i32(existing_entry_ptr + WORD_SIZE);
        let query_value: i32 = load_i32(query_entry_ptr + WORD_SIZE);
        if existing_value != query_value {
            return false;
        }
        let existing_type: i32 = load_i32(existing_entry_ptr + 2 * WORD_SIZE);
        let query_type: i32 = load_i32(query_entry_ptr + 2 * WORD_SIZE);
        if existing_type != query_type {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn ast_function_find_const_specialization(
    ast_base: i32,
    index: i32,
    key_ptr: i32,
) -> i32 {
    if index < 0 {
        return -1;
    }
    if key_ptr <= 0 {
        return -1;
    }
    if !ast_function_has_const_params(ast_base, index) {
        return -1;
    }
    let mut entry_ptr: i32 = ast_const_specialization_registry_head(ast_base);
    while entry_ptr > 0 {
        let entry_template_index: i32 = load_i32(entry_ptr);
        if entry_template_index == index {
            let existing_key_ptr: i32 = load_i32(entry_ptr + WORD_SIZE);
            if const_specialization_keys_equal(existing_key_ptr, key_ptr) {
                return load_i32(entry_ptr + 2 * WORD_SIZE);
            }
        }
        entry_ptr = load_i32(entry_ptr + 3 * WORD_SIZE);
    };
    -1
}

fn ast_function_register_const_specialization(
    ast_base: i32,
    index: i32,
    key_ptr: i32,
    specialized_index: i32,
) -> i32 {
    if index < 0 {
        return -1;
    }
    if key_ptr <= 0 {
        return -1;
    }
    if specialized_index < 0 {
        return -1;
    }
    if !ast_function_has_const_params(ast_base, index) {
        return -1;
    }
    let new_entry_ptr: i32 = ast_call_data_alloc(ast_base, 4);
    if new_entry_ptr < 0 {
        return -1;
    }
    let previous_head: i32 = ast_const_specialization_registry_head(ast_base);
    store_i32(new_entry_ptr, index);
    store_i32(new_entry_ptr + WORD_SIZE, key_ptr);
    store_i32(new_entry_ptr + 2 * WORD_SIZE, specialized_index);
    store_i32(new_entry_ptr + 3 * WORD_SIZE, previous_head);
    ast_const_specialization_registry_set_head(ast_base, new_entry_ptr);
    new_entry_ptr
}

const CONST_SPECIALIZATION_ENTRY_NAME_CAP: i32 = 5;

const ConstSpecializationEntry = struct(
    CONST_SPECIALIZATION_ENTRY_NAME_CAP,
    2,
    [
        ("value", i32),
        ("type\0", i32),
    ],
);

fn const_specialization_lookup_entry(
    key_ptr: i32,
    param_index: i32,
) -> ConstSpecializationEntry {
    if key_ptr <= 0 {
        return ConstSpecializationEntry { value: -1, type: -1 };
    }
    if param_index < 0 {
        return ConstSpecializationEntry { value: -1, type: -1 };
    }
    let entry_count: i32 = load_i32(key_ptr);
    if entry_count <= 0 {
        return ConstSpecializationEntry { value: -1, type: -1 };
    }
    let mut scan_index: i32 = 0;
    while scan_index < entry_count {
        let entry_ptr: i32 =
            key_ptr + WORD_SIZE + scan_index * 3 * WORD_SIZE;
        let recorded_param: i32 = load_i32(entry_ptr);
        if recorded_param == param_index {
            let value: i32 = load_i32(entry_ptr + WORD_SIZE);
            let value_type: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
            return ConstSpecializationEntry {
                value: value,
                type: value_type,
            };
        }
        scan_index = scan_index + 1;
    };
    ConstSpecializationEntry { value: -1, type: -1 }
}

const CONST_SPECIALIZATION_LOCAL_STACK_ENTRY_SIZE: i32 = 8;

fn clone_const_specialization_expr_list(
    ast_base: i32,
    template_index: i32,
    key_ptr: i32,
    removed_const_count: i32,
    values_ptr: i32,
    count: i32,
    env_values_ptr: i32,
    param_count: i32,
    eval_stack_base: i32,
    eval_stack_top_ptr: i32,
    eval_value_ptr: i32,
    eval_type_ptr: i32,
            local_type_stack_ptr: i32,
            local_type_stack_top_ptr: i32,
            local_type_stack_capacity: i32,
) -> i32 {
    if count <= 0 {
        return 0;
    }
    if values_ptr < 0 {
        return -1;
    }
    let new_ptr: i32 = ast_call_data_alloc(ast_base, count);
    if new_ptr < 0 {
        return -1;
    }
    let mut idx: i32 = 0;
    while idx < count {
        let original_expr: i32 = load_i32(values_ptr + idx * WORD_SIZE);
        let cloned_expr: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            original_expr,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_expr < 0 {
            return -1;
        }
        store_i32(new_ptr + idx * WORD_SIZE, cloned_expr);
        idx = idx + 1;
    };
    new_ptr
}

fn clone_const_specialization_call_metadata(
    ast_base: i32,
    template_index: i32,
    key_ptr: i32,
    removed_const_count: i32,
    metadata_ptr: i32,
    env_values_ptr: i32,
    param_count: i32,
    eval_stack_base: i32,
    eval_stack_top_ptr: i32,
    eval_value_ptr: i32,
    eval_type_ptr: i32,
            local_type_stack_ptr: i32,
            local_type_stack_top_ptr: i32,
            local_type_stack_capacity: i32,
) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    let name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
    let name_len: i32 = call_metadata_name_len(metadata_ptr);
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    if arg_count < 0 {
        return -1;
    }
    let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
    let trim_const_args: bool = callee_index >= 0
        && !ast_function_has_const_params(ast_base, callee_index);
    let mut runtime_arg_count: i32 = arg_count;
    if trim_const_args {
        runtime_arg_count = 0;
        let mut count_idx: i32 = 0;
        while count_idx < arg_count {
            if !ast_function_param_is_const(ast_base, callee_index, count_idx) {
                runtime_arg_count = runtime_arg_count + 1;
            }
            count_idx = count_idx + 1;
        };
    }
    let total_words: i32 = 4 + runtime_arg_count + 5;
    if total_words <= 0 {
        return -1;
    }
    let new_metadata: i32 = ast_call_data_alloc(ast_base, total_words);
    if new_metadata < 0 {
        return -1;
    }
    store_i32(new_metadata, name_ptr);
    store_i32(new_metadata + WORD_SIZE, name_len);
    store_i32(new_metadata + 2 * WORD_SIZE, runtime_arg_count);
    store_i32(new_metadata + 3 * WORD_SIZE, callee_index);
    let original_args_base: i32 = call_metadata_args_base(metadata_ptr);
    if arg_count > 0 && original_args_base < 0 {
        return -1;
    }
    let new_args_base: i32 = call_metadata_args_base(new_metadata);
    let mut arg_idx: i32 = 0;
    let mut runtime_idx: i32 = 0;
    while arg_idx < arg_count {
        let original_arg: i32 = load_i32(original_args_base + arg_idx * WORD_SIZE);
        let skip_arg: bool = trim_const_args
            && ast_function_param_is_const(ast_base, callee_index, arg_idx);
        if !skip_arg {
        let cloned_arg: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            original_arg,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
            if cloned_arg < 0 {
                return -1;
            }
            if runtime_arg_count > 0 {
                store_i32(new_args_base + runtime_idx * WORD_SIZE, cloned_arg);
                runtime_idx = runtime_idx + 1;
            }
        }
        arg_idx = arg_idx + 1;
    };
    if trim_const_args {
        if runtime_idx != runtime_arg_count {
            return -1;
        }
    } else {
        if runtime_idx != arg_count {
            return -1;
        }
    }
    let original_extra: i32 = call_metadata_extra_slot_base(metadata_ptr);
    let new_extra: i32 = call_metadata_extra_slot_base(new_metadata);
    if original_extra > 0 && new_extra > 0 {
        let mut extra_idx: i32 = 0;
        while extra_idx < 5 {
            let value: i32 = load_i32(original_extra + extra_idx * WORD_SIZE);
            store_i32(new_extra + extra_idx * WORD_SIZE, value);
            extra_idx = extra_idx + 1;
        };
    }
    if new_extra > 0 {
        store_i32(new_extra, 0);
        store_i32(new_extra + WORD_SIZE, 0);
        store_i32(new_extra + 3 * WORD_SIZE, 0);
        store_i32(new_extra + 4 * WORD_SIZE, 0);
    }
    new_metadata
}

fn clone_const_specialization_expr(
    ast_base: i32,
    template_index: i32,
    key_ptr: i32,
    removed_const_count: i32,
    expr_index: i32,
    env_values_ptr: i32,
    param_count: i32,
    eval_stack_base: i32,
    eval_stack_top_ptr: i32,
    eval_value_ptr: i32,
    eval_type_ptr: i32,
            local_type_stack_ptr: i32,
            local_type_stack_top_ptr: i32,
            local_type_stack_capacity: i32,
) -> i32 {
    if expr_index < 0 {
        return expr_index;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + WORD_SIZE);
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        return ast_expr_alloc_literal(ast_base, value, expr_type);
    }
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + WORD_SIZE);
        let cloned_metadata: i32 = clone_const_specialization_call_metadata(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            metadata_ptr,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_metadata < 0 {
            return -1;
        }
        let location_offset: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_call(ast_base, cloned_metadata, location_offset);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if template_index >= 0 {
            if ast_function_param_is_const(ast_base, template_index, param_index) {
                let entry: ConstSpecializationEntry =
                    const_specialization_lookup_entry(key_ptr, param_index);
                if entry.type < 0 {
                    return -1;
                }
                let literal_index: i32 = ast_expr_alloc_literal(
                    ast_base,
                    entry.value,
                    entry.type,
                );
                if literal_index < 0 {
                    return -1;
                }
                return literal_index;
            }
            if env_values_ptr > 0 {
                let type_slot_ptr: i32 = env_values_ptr + param_index * 8 + WORD_SIZE;
                let specialized_type: i32 = load_i32(type_slot_ptr);
                if specialized_type >= 0 {
                    expr_type = specialized_type;
                }
            }
            let runtime_index: i32 =
                ast_function_param_runtime_index(ast_base, template_index, param_index);
            if runtime_index < 0 {
                return -1;
            }
            return ast_expr_alloc_param(ast_base, runtime_index, expr_type);
        }
        return ast_expr_alloc_param(ast_base, param_index, expr_type);
    }
    if kind == 7 {
        let cond_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let then_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let else_index: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let cloned_cond: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            cond_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_cond < 0 {
            return -1;
        }
        let cloned_then: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            then_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_then < 0 {
            return -1;
        }
        let cloned_else: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            else_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_else < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 7, cloned_cond, cloned_then, cloned_else);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 8 {
        let mut local_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        if removed_const_count > 0 {
            local_index = local_index - removed_const_count;
            if local_index < 0 {
                return -1;
            }
        }
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            if local_type_stack_ptr > 0 && local_type_stack_top_ptr > 0 {
                let stack_count: i32 = load_i32(local_type_stack_top_ptr);
                let mut stack_idx: i32 = stack_count - 1;
                while stack_idx >= 0 {
                    let entry_offset: i32 =
                        local_type_stack_ptr + stack_idx * CONST_SPECIALIZATION_LOCAL_STACK_ENTRY_SIZE;
                    let recorded_index: i32 = load_i32(entry_offset);
                    if recorded_index == local_index {
                        let recorded_type: i32 = load_i32(entry_offset + 4);
                        if recorded_type >= 0 {
                            expr_type = recorded_type;
                            ast_expr_set_type(ast_base, expr_index, expr_type);
                        }
                        break;
                    }
                    stack_idx = stack_idx - 1;
                };
            }
        }
        return ast_expr_alloc_local(ast_base, local_index, expr_type);
    }
    if kind == 9 {
        let mut local_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        if removed_const_count > 0 {
            local_index = local_index - removed_const_count;
            if local_index < 0 {
                return -1;
            }
        }
        let init_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let body_index: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let cloned_init: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            init_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_init < 0 {
            return -1;
        }
        let mut pushed: bool = false;
        if local_type_stack_ptr > 0 && local_type_stack_top_ptr > 0 {
            if local_type_stack_capacity <= 0 {
                return -1;
            }
            let stack_top: i32 = load_i32(local_type_stack_top_ptr);
            if stack_top >= local_type_stack_capacity {
                return -1;
            }
            let init_type: i32 = ast_expr_type(ast_base, cloned_init);
            store_i32(CLONE_DEBUG_LOCAL_INDEX_OFFSET, local_index);
            store_i32(CLONE_DEBUG_INIT_TYPE_OFFSET, init_type);
            if init_type >= 0 {
                let entry_offset: i32 =
                    local_type_stack_ptr
                    + stack_top * CONST_SPECIALIZATION_LOCAL_STACK_ENTRY_SIZE;
                store_i32(entry_offset, local_index);
                store_i32(entry_offset + 4, init_type);
                store_i32(local_type_stack_top_ptr, stack_top + 1);
                pushed = true;
            }
        }
        store_i32(
            CLONE_DEBUG_PUSHED_OFFSET,
            if pushed { 1 } else { 0 },
        );
        let cloned_body: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            body_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if pushed {
            let stack_top: i32 = load_i32(local_type_stack_top_ptr);
            if stack_top <= 0 {
                return -1;
            }
            store_i32(local_type_stack_top_ptr, stack_top - 1);
        }
        if cloned_body < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 9, local_index, cloned_init, cloned_body);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 10 {
        let mut local_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        if removed_const_count > 0 {
            local_index = local_index - removed_const_count;
            if local_index < 0 {
                return -1;
            }
        }
        let value_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 10, local_index, cloned_value, 0);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let then_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_first: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            first_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_first < 0 {
            return -1;
        }
        let cloned_then: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            then_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_then < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 11, cloned_first, cloned_then, 0);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let loop_flags: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_body: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            body_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_body < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc_loop(ast_base, cloned_body, loop_flags);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let mut cloned_value: i32 = -1;
        if value_index >= 0 {
            cloned_value = clone_const_specialization_expr(
                ast_base,
                template_index,
                key_ptr,
                removed_const_count,
                value_index,
                env_values_ptr,
                param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                local_type_stack_ptr,
                local_type_stack_top_ptr,
                local_type_stack_capacity,
            );
            if cloned_value < 0 {
                return -1;
            }
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 13, -1, cloned_value, 0);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let location_offset: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_return(ast_base, cloned_value, location_offset);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 24 {
        let new_index: i32 = ast_expr_alloc_continue(ast_base, -1);
        if new_index < 0 {
            return -1;
        }
        return new_index;
    }
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc(ast_base, 22, cloned_value, 0, 0);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let mut length: i32 = ast_expr_array_repeat_length(ast_base, expr_index);
        let length_expr_index: i32 = ast_expr_array_repeat_length_expr(ast_base, expr_index);
        let cloned_element: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            element_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_element < 0 {
            return -1;
        }
        let mut resolved_length: bool = false;
        let mut metadata_ptr: i32 = -1;
        if length_expr_index >= 0 {
            let original_metadata_ptr: i32 =
                ast_expr_array_repeat_length_metadata(ast_base, expr_index);
            let mut usage_list_ptr: i32 = 0;
            let mut usage_count: i32 = 0;
            if original_metadata_ptr > 0 {
                usage_list_ptr = load_i32(original_metadata_ptr + WORD_SIZE);
                usage_count = load_i32(original_metadata_ptr + 2 * WORD_SIZE);
            }
            let cloned_length_expr: i32 = clone_const_specialization_expr(
                ast_base,
                template_index,
                key_ptr,
                removed_const_count,
                length_expr_index,
                env_values_ptr,
                param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
            );
            if cloned_length_expr < 0 {
                return -1;
            }
            let saved_top: i32 = load_i32(eval_stack_top_ptr);
            store_i32(eval_stack_top_ptr, 0);
            let status: i32 = interpret_constant_expression(
                ast_base,
                cloned_length_expr,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                env_values_ptr,
                param_count,
                param_count,
            );
            store_i32(eval_stack_top_ptr, saved_top);
            if status == CONST_EVAL_STATUS_OK {
                let result_type: i32 = load_i32(eval_type_ptr);
                if constant_eval_integer_type_supported(result_type) {
                    let normalized: i32 =
                        normalize_integer_value(load_i32(eval_value_ptr), result_type);
                    if normalized >= 0 {
                        length = normalized;
                        resolved_length = true;
                    }
                }
            }
            if !resolved_length {
                if usage_count == 1 && usage_list_ptr > 0 && key_ptr > 0 {
                    let recorded_param: i32 = load_i32(usage_list_ptr);
                    if recorded_param >= 0 {
                        let const_entry: ConstSpecializationEntry =
                            const_specialization_lookup_entry(key_ptr, recorded_param);
                        if const_entry.type >= 0 {
                            if constant_eval_integer_type_supported(const_entry.type) {
                                let normalized: i32 =
                                    normalize_integer_value(
                                        const_entry.value,
                                        const_entry.type,
                                    );
                                if normalized >= 0 {
                                    length = normalized;
                                    resolved_length = true;
                                }
                            }
                        }
                    }
                }
            }
            if !resolved_length {
                let mut copied_usage_ptr: i32 = 0;
                if usage_count > 0 && usage_list_ptr > 0 {
                    copied_usage_ptr = ast_call_data_alloc(ast_base, usage_count);
                    if copied_usage_ptr < 0 {
                        return -1;
                    }
                    let mut copy_idx: i32 = 0;
                    while copy_idx < usage_count {
                        let value: i32 = load_i32(usage_list_ptr + copy_idx * WORD_SIZE);
                        store_i32(copied_usage_ptr + copy_idx * WORD_SIZE, value);
                        copy_idx = copy_idx + 1;
                    };
                }
                metadata_ptr = ast_call_data_alloc(ast_base, 3);
                if metadata_ptr < 0 {
                    return -1;
                }
                store_i32(metadata_ptr, cloned_length_expr);
                store_i32(metadata_ptr + WORD_SIZE, copied_usage_ptr);
                store_i32(metadata_ptr + 2 * WORD_SIZE, usage_count);
            }
        }
        if resolved_length {
            metadata_ptr = -1;
        } else if metadata_ptr < 0 {
            metadata_ptr = ast_expr_array_repeat_length_metadata(ast_base, expr_index);
        }
        let location: i32 = ast_expr_array_repeat_location(ast_base, expr_index);
        let new_index: i32 =
            ast_expr_alloc_array_repeat(ast_base, cloned_element, length, metadata_ptr, location);
        if new_index < 0 {
            return -1;
        }
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if resolved_length {
            let element_type: i32 = ast_expr_type(ast_base, cloned_element);
            if element_type >= 0 {
                let specialized_array: i32 =
                    ast_register_array_type(ast_base, element_type, length);
                if specialized_array >= 0 {
                    expr_type = specialized_array;
                }
            }
        }
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let index_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_array: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            array_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_array < 0 {
            return -1;
        }
        let cloned_index: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            index_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_index < 0 {
            return -1;
        }
        let location_offset: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_array_get(
            ast_base,
            cloned_array,
            cloned_index,
            location_offset,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let index_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let value_index: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let cloned_array: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            array_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_array < 0 {
            return -1;
        }
        let cloned_index: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            index_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_index < 0 {
            return -1;
        }
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let location: i32 = ast_expr_array_set_location(ast_base, expr_index);
        let new_index: i32 = ast_expr_alloc_array_set(
            ast_base,
            cloned_array,
            cloned_index,
            cloned_value,
            location,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let field_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let value_index: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let cloned_tuple: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            tuple_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_tuple < 0 {
            return -1;
        }
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let location: i32 = ast_expr_tuple_set_location(ast_base, expr_index);
        let new_index: i32 = ast_expr_alloc_tuple_set(
            ast_base,
            cloned_tuple,
            field_index,
            cloned_value,
            location,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + WORD_SIZE);
        let count: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        if count < 0 {
            return -1;
        }
        let cloned_ptr: i32 = clone_const_specialization_expr_list(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            values_ptr,
            count,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_ptr < 0 {
            return -1;
        }
        let location: i32 = ast_expr_array_list_location(ast_base, expr_index);
        let new_index: i32 =
            ast_expr_alloc_array_list(ast_base, cloned_ptr, count, location);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let cloned_array: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            array_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_array < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc_array_len(ast_base, cloned_array);
        if new_index < 0 {
            return -1;
        }
        return new_index;
    }
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let target_type: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_value: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            value_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_value < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc_cast(ast_base, cloned_value, target_type);
        if new_index < 0 {
            return -1;
        }
        return new_index;
    }
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + WORD_SIZE);
        let count: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        if count < 0 {
            return -1;
        }
        let cloned_ptr: i32 = clone_const_specialization_expr_list(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            values_ptr,
            count,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_ptr < 0 {
            return -1;
        }
        let new_index: i32 = ast_expr_alloc_tuple(ast_base, cloned_ptr, count);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        } else {
            if count == 0 {
                let tuple_type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
                if tuple_type_id >= 0 {
                    let resolved_tuple: i32 = resolve_type_id(0, ast_base, tuple_type_id);
                    if resolved_tuple >= 0 {
                        ast_expr_set_type(ast_base, new_index, resolved_tuple);
                    }
                }
            } else {
                let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
                let saved_used: i32 = load_i32(call_data_used_ptr);
                let element_types_ptr: i32 = ast_call_data_alloc(ast_base, count);
                if element_types_ptr >= 0 {
                    let mut idx: i32 = 0;
                    let mut all_resolved: bool = true;
                    loop {
                        if idx >= count {
                            break;
                        }
                        let cloned_value_index: i32 =
                            load_i32(cloned_ptr + idx * WORD_SIZE);
                        let cloned_value_type: i32 =
                            ast_expr_type(ast_base, cloned_value_index);
                        if cloned_value_type < 0 {
                            all_resolved = false;
                            break;
                        }
                        let resolved_element: i32 =
                            resolve_type_id(0, ast_base, cloned_value_type);
                        if resolved_element < 0 {
                            all_resolved = false;
                            break;
                        }
                        store_i32(
                            element_types_ptr + idx * WORD_SIZE,
                            resolved_element,
                        );
                        idx = idx + 1;
                    };
                    if all_resolved {
                        let before_count: i32 = ast_tuple_types_count(ast_base);
                        let tuple_type_id: i32 = ast_register_tuple_type(
                            ast_base,
                            element_types_ptr,
                            count,
                        );
                        if tuple_type_id >= 0 {
                            let after_count: i32 = ast_tuple_types_count(ast_base);
                            if after_count == before_count {
                                store_i32(call_data_used_ptr, saved_used);
                            }
                            let resolved_tuple: i32 =
                                resolve_type_id(0, ast_base, tuple_type_id);
                            if resolved_tuple >= 0 {
                                ast_expr_set_type(ast_base, new_index, resolved_tuple);
                            }
                        } else {
                            store_i32(call_data_used_ptr, saved_used);
                        }
                    } else {
                        store_i32(call_data_used_ptr, saved_used);
                    }
                }
            }
        }
        return new_index;
    }
    if kind == 47 {
        let type_expr_index: i32 = ast_expr_struct_literal_type_expr(ast_base, expr_index);
        let metadata_ptr: i32 = ast_expr_struct_literal_metadata(ast_base, expr_index);
        let field_count: i32 = ast_expr_struct_literal_field_count(ast_base, expr_index);
        if field_count < 0 {
            return -1;
        }
        let cloned_type: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            type_expr_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_type < 0 {
            return -1;
        }
        let metadata_words: i32 =
            STRUCT_LITERAL_METADATA_HEADER_WORDS
                + field_count * STRUCT_LITERAL_FIELD_ENTRY_WORDS;
        let cloned_metadata: i32 = if metadata_words > 0 {
            ast_call_data_alloc(ast_base, metadata_words)
        } else {
            0
        };
        if metadata_words > 0 && cloned_metadata < 0 {
            return -1;
        }
        if metadata_words > 0 {
            store_i32(cloned_metadata, ast_expr_struct_literal_location(ast_base, expr_index));
        }
        let mut field_idx: i32 = 0;
        while field_idx < field_count {
            let source_entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, field_idx);
            let label_kind: i32 = struct_literal_field_label_kind(source_entry);
            let label_data: i32 = struct_literal_field_label_data(source_entry);
            let label_extra: i32 = struct_literal_field_label_extra(source_entry);
            let field_location: i32 = struct_literal_field_location(source_entry);
            let value_index: i32 = struct_literal_field_value_index(source_entry);
            let cloned_label: i32 = if label_kind == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
                clone_const_specialization_expr(
                    ast_base,
                    template_index,
                    key_ptr,
                    removed_const_count,
                    label_data,
                    env_values_ptr,
                    param_count,
                    eval_stack_base,
                    eval_stack_top_ptr,
                    eval_value_ptr,
                    eval_type_ptr,
                    local_type_stack_ptr,
                    local_type_stack_top_ptr,
                    local_type_stack_capacity,
                )
            } else {
                label_data
            };
            if cloned_label < 0 {
                return -1;
            }
            let cloned_value: i32 = clone_const_specialization_expr(
                ast_base,
                template_index,
                key_ptr,
                removed_const_count,
                value_index,
                env_values_ptr,
                param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                local_type_stack_ptr,
                local_type_stack_top_ptr,
                local_type_stack_capacity,
            );
            if cloned_value < 0 {
                return -1;
            }
            if cloned_metadata > 0 {
                let target_entry: i32 = struct_literal_field_entry_ptr(cloned_metadata, field_idx);
                struct_literal_field_set_label_kind(target_entry, label_kind);
                struct_literal_field_set_label_data(target_entry, cloned_label);
                struct_literal_field_set_label_extra(target_entry, label_extra);
                struct_literal_field_set_location(target_entry, field_location);
                struct_literal_field_set_value(target_entry, cloned_value);
            }
            field_idx = field_idx + 1;
        };
        let location: i32 = ast_expr_struct_literal_location(ast_base, expr_index);
        let new_index: i32 = ast_expr_alloc_struct_literal(
            ast_base,
            cloned_type,
            cloned_metadata,
            field_count,
            location,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let field_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_tuple: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            tuple_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_tuple < 0 {
            return -1;
        }
        let tuple_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, cloned_tuple);
        if load_i32(tuple_entry_ptr) == 0 {
            let literal_value: i32 = load_i32(tuple_entry_ptr + WORD_SIZE);
            let mut literal_type: i32 = ast_expr_type(ast_base, cloned_tuple);
            if literal_type < 0 {
                return -1;
            }
            if literal_type == BUILTIN_TYPE_ID_TYPE {
                if literal_value < 0 {
                    return -1;
                }
                if !type_id_is_tuple(literal_value) {
                    return -1;
                }
                let resolved_tuple: i32 = resolve_type_id(0, ast_base, literal_value);
                if resolved_tuple < 0 {
                    return -1;
                }
                if !type_id_is_tuple(resolved_tuple) {
                    return -1;
                }
                let tuple_idx: i32 = tuple_type_index(resolved_tuple);
                if tuple_idx < 0 {
                    return -1;
                }
                if tuple_idx >= ast_tuple_types_count(ast_base) {
                    return -1;
                }
                if ensure_tuple_type_metadata(0, ast_base, tuple_idx, resolved_tuple) < 0 {
                    return -1;
                }
                let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
                if field_index < 0 || field_index >= element_count {
                    return -1;
                }
                let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
                if elements_ptr < 0 {
                    return -1;
                }
                let element_type: i32 = load_i32(elements_ptr + field_index * WORD_SIZE);
                if element_type < 0 {
                    return -1;
                }
                let literal_index: i32 =
                    ast_expr_alloc_literal(ast_base, element_type, BUILTIN_TYPE_ID_TYPE);
                if literal_index < 0 {
                    return -1;
                }
                return literal_index;
            }
            if type_id_is_tuple(literal_type) {
                let resolved_tuple: i32 = resolve_type_id(0, ast_base, literal_type);
                if resolved_tuple < 0 {
                    return -1;
                }
                if resolved_tuple != literal_type {
                    ast_expr_set_type(ast_base, cloned_tuple, resolved_tuple);
                    literal_type = resolved_tuple;
                }
                let tuple_idx: i32 = tuple_type_index(literal_type);
                if tuple_idx < 0 {
                    return -1;
                }
                if tuple_idx >= ast_tuple_types_count(ast_base) {
                    return -1;
                }
                if ensure_tuple_type_metadata(0, ast_base, tuple_idx, literal_type) < 0 {
                    return -1;
                }
                let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
                if field_index < 0 || field_index >= element_count {
                    return -1;
                }
                let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
                if elements_ptr < 0 {
                    return -1;
                }
                let element_type: i32 = load_i32(elements_ptr + field_index * WORD_SIZE);
                if element_type < 0 {
                    return -1;
                }
                if element_count > 0 {
                    if literal_value <= 0 {
                        return -1;
                    }
                    let slot_ptr: i32 = literal_value + field_index * 2 * WORD_SIZE;
                    let element_value: i32 = load_i32(slot_ptr);
                    let element_value_type: i32 = load_i32(slot_ptr + WORD_SIZE);
                    if element_value_type < 0 {
                        return -1;
                    }
                    let literal_index: i32 =
                        ast_expr_alloc_literal(ast_base, element_value, element_value_type);
                    if literal_index < 0 {
                        return -1;
                    }
                    return literal_index;
                }
            }
        }
        let location_offset: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_tuple_get(
            ast_base,
            cloned_tuple,
            field_index,
            location_offset,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 48 {
        let struct_index: i32 = ast_expr_struct_get_base(ast_base, expr_index);
        let metadata_ptr: i32 = ast_expr_struct_get_metadata(ast_base, expr_index);
        let cloned_struct: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            struct_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_struct < 0 {
            return -1;
        }
        let cloned_metadata: i32 = ast_call_data_alloc(ast_base, STRUCT_GET_LABEL_ENTRY_WORDS);
        if cloned_metadata < 0 {
            return -1;
        }
        let label_kind: i32 = struct_get_label_kind(metadata_ptr);
        let label_data: i32 = struct_get_label_data(metadata_ptr);
        let label_extra: i32 = struct_get_label_extra(metadata_ptr);
        let cloned_label: i32 = if label_kind == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
            clone_const_specialization_expr(
                ast_base,
                template_index,
                key_ptr,
                removed_const_count,
                label_data,
                env_values_ptr,
                param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                local_type_stack_ptr,
                local_type_stack_top_ptr,
                local_type_stack_capacity,
            )
        } else {
            label_data
        };
        if cloned_label < 0 {
            return -1;
        }
        struct_get_label_set_kind(cloned_metadata, label_kind);
        struct_get_label_set_data(cloned_metadata, cloned_label);
        struct_get_label_set_extra(cloned_metadata, label_extra);
        let location: i32 = ast_expr_struct_get_location(ast_base, expr_index);
        let new_index: i32 = ast_expr_alloc_struct_get(
            ast_base,
            cloned_struct,
            cloned_metadata,
            location,
        );
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + WORD_SIZE);
        let byte_count: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_inline_wasm(ast_base, bytes_ptr, byte_count);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 43 {
        let name_start: i32 = load_i32(entry_ptr + WORD_SIZE);
        let name_len: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let source_base: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc_const_ref(ast_base, source_base, name_start, name_len);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    if kind == 25 || kind == 26 || kind == 27 || kind == 28 || kind == 29 || kind == 30
        || kind == 31 || kind == 32 || kind == 33 || kind == 34 || kind == 2 || kind == 3
        || kind == 4 || kind == 5 || kind == 46 || kind == 14 || kind == 15 || kind == 16 || kind == 17
        || kind == 18 || kind == 19 || kind == 20 || kind == 21
    {
        let left_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        let right_index: i32 = load_i32(entry_ptr + 2 * WORD_SIZE);
        let cloned_left: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            left_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_left < 0 {
            return -1;
        }
        let cloned_right: i32 = clone_const_specialization_expr(
            ast_base,
            template_index,
            key_ptr,
            removed_const_count,
            right_index,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_right < 0 {
            return -1;
        }
        let data2: i32 = load_i32(entry_ptr + 3 * WORD_SIZE);
        let new_index: i32 = ast_expr_alloc(ast_base, kind, cloned_left, cloned_right, data2);
        if new_index < 0 {
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            ast_expr_set_type(ast_base, new_index, expr_type);
        }
        return new_index;
    }
    -1
}

fn ast_function_clone_const_template(
    ast_base: i32,
    index: i32,
    key_ptr: i32,
    detail_out_ptr: i32,
    caller_func_index: i32,
    location_offset: i32,
) -> i32 {
    if index < 0 {
        return -1;
    }
    if key_ptr <= 0 {
        return -1;
    }
    let const_entry_count: i32 = load_i32(key_ptr);
    if const_entry_count < 0 {
        return -1;
    }
    let declared_const: i32 = ast_function_const_params_count(ast_base, index);
    if declared_const < 0 {
        return -1;
    }
    if const_entry_count != declared_const {
        return -1;
    }
    let param_count: i32 = ast_function_param_count(ast_base, index);
    if param_count < 0 {
        return -1;
    }
    if param_count > MAX_PARAMS {
        return -1;
    }
    let runtime_param_count: i32 = ast_function_runtime_param_count(ast_base, index);
    if runtime_param_count < 0 {
        return -1;
    }
    if runtime_param_count + const_entry_count != param_count {
        return -1;
    }
    let env_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
    let env_values_ptr: i32 = env_base;
    let eval_value_ptr: i32 = env_values_ptr + MAX_PARAMS * 8;
    let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
    let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
    let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
    store_i32(eval_stack_top_ptr, 0);
    let mut init_idx: i32 = 0;
    while init_idx < param_count {
        let slot_ptr: i32 = env_values_ptr + init_idx * 8;
        store_i32(slot_ptr, 0);
        store_i32(slot_ptr + WORD_SIZE, -1);
        init_idx = init_idx + 1;
    };
    let mut key_idx: i32 = 0;
    while key_idx < const_entry_count {
        let entry_ptr: i32 = key_ptr + WORD_SIZE + key_idx * 3 * WORD_SIZE;
        let recorded_param: i32 = load_i32(entry_ptr);
        if recorded_param < 0 {
            return -1;
        }
        if recorded_param >= param_count {
            return -1;
        }
        let slot_ptr: i32 = env_values_ptr + recorded_param * 8;
        store_i32(slot_ptr, load_i32(entry_ptr + WORD_SIZE));
        store_i32(slot_ptr + WORD_SIZE, load_i32(entry_ptr + 2 * WORD_SIZE));
        key_idx = key_idx + 1;
    };
    let current_count: i32 = ast_functions_count(ast_base);
    if current_count < 0 {
        return -1;
    }
    if index >= current_count {
        return -1;
    }
    if current_count >= AST_MAX_FUNCTIONS {
        if detail_out_ptr > 0 {
            let mut module_base: i32 = scratch_module_base(detail_out_ptr);
            let mut module_len: i32 = scratch_module_len(detail_out_ptr);
            let mut module_index: i32 = scratch_module_index(detail_out_ptr);
            if caller_func_index >= 0 {
                let func_base: i32 = ast_function_entry_module_base(ast_base, caller_func_index);
                let func_len: i32 = ast_function_entry_module_len(ast_base, caller_func_index);
                let func_index: i32 = ast_function_entry_module_index(ast_base, caller_func_index);
                if func_base > 0 { module_base = func_base; }
                if func_len > 0 { module_len = func_len; }
                if func_index >= 0 { module_index = func_index; }
            }
            if location_offset >= 0 && module_base > 0 && module_len > 0 {
                write_failure_detail_with_location(
                    detail_out_ptr,
                    module_index,
                    module_base,
                    module_len,
                    location_offset,
                    44,
                    "const specialization function limit exceeded",
                );
            } else {
                write_failure_detail(
                    detail_out_ptr,
                    44,
                    "const specialization function limit exceeded",
                );
            }
        }
        return -1;
    }
    let source_ptr: i32 = ast_function_entry_ptr(ast_base, index);
    let body_kind: i32 = load_i32(source_ptr + 12);
    let body_data0: i32 = load_i32(source_ptr + 16);
    let source_param_types_ptr: i32 = load_i32(source_ptr + 24);
    if param_count > 0 && source_param_types_ptr < 0 {
        return -1;
    }
    let locals_count: i32 = load_i32(source_ptr + 20);
    let mut local_type_stack_ptr: i32 = 0;
    let mut local_type_stack_top_ptr: i32 = 0;
    let mut local_type_stack_capacity: i32 = locals_count;
    if locals_count > 0 {
        local_type_stack_ptr = ast_temp_base(ast_base);
        local_type_stack_top_ptr =
            local_type_stack_ptr
            + locals_count * CONST_SPECIALIZATION_LOCAL_STACK_ENTRY_SIZE;
        store_i32(local_type_stack_top_ptr, 0);
    }
    let mut specialized_param_types_ptr: i32 = -1;
    if runtime_param_count > 0 {
        specialized_param_types_ptr = ast_call_data_alloc(ast_base, runtime_param_count);
        if specialized_param_types_ptr < 0 {
            return -1;
        }
    }
    let mut param_idx: i32 = 0;
    let mut runtime_write_index: i32 = 0;
    while param_idx < param_count {
        let mut resolved_type: i32 = -1;
        if source_param_types_ptr >= 0 {
            resolved_type = load_i32(source_param_types_ptr + param_idx * WORD_SIZE);
        }
        if ast_function_param_requires_specialization(ast_base, index, param_idx) {
            let template_handle: i32 = ast_function_param_template_payload(
                ast_base,
                index,
                param_idx,
            );
            if template_handle <= 0 {
                return -1;
            }
            let mut specialized_type: i32 = type_template_resolve_type(
                ast_base,
                template_handle,
                env_values_ptr,
                param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
            );
            if specialized_type < 0 {
                return -1;
            }
            if specialized_type == BUILTIN_TYPE_ID_TYPE {
                let usage_count: i32 = type_template_entry_param_count(template_handle);
                if usage_count > 0 {
                    let first_param: i32 = type_template_entry_param_index(template_handle, 0);
                    if first_param >= 0 && first_param < param_count {
                        let env_slot: i32 = env_values_ptr + first_param * 8;
                        let captured_kind: i32 = load_i32(env_slot + WORD_SIZE);
                        if captured_kind == BUILTIN_TYPE_ID_TYPE {
                            let captured_value: i32 = load_i32(env_slot);
                            if captured_value < 0 {
                                return -1;
                            }
                            specialized_type = captured_value;
                        }
                    }
                }
            }
            resolved_type = specialized_type;
        }
        if resolved_type < 0 {
            return -1;
        }
        let type_slot_ptr: i32 = env_values_ptr + param_idx * 8 + WORD_SIZE;
        store_i32(type_slot_ptr, resolved_type);
        if !ast_function_param_is_const(ast_base, index, param_idx) {
            if runtime_param_count > 0 {
                if specialized_param_types_ptr < 0 || runtime_write_index >= runtime_param_count {
                    return -1;
                }
                store_i32(
                    specialized_param_types_ptr + runtime_write_index * WORD_SIZE,
                    resolved_type,
                );
            }
            runtime_write_index = runtime_write_index + 1;
        }
        param_idx = param_idx + 1;
    };
    if runtime_write_index != runtime_param_count {
        return -1;
    }
    let original_return_type: i32 = load_i32(source_ptr + 28);
    let mut specialized_return_type: i32 = original_return_type;
    if ast_function_return_requires_specialization(ast_base, index) {
        let return_template_handle: i32 =
            ast_function_return_template_payload(ast_base, index);
        if return_template_handle <= 0 {
            return -1;
        }
        let resolved_return: i32 = type_template_resolve_type(
            ast_base,
            return_template_handle,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
        );
        if resolved_return < 0 {
            return -1;
        }
        specialized_return_type = resolved_return;
        if specialized_return_type == BUILTIN_TYPE_ID_TYPE {
            let usage_count: i32 = type_template_entry_param_count(return_template_handle);
            if usage_count > 0 {
                let first_param: i32 = type_template_entry_param_index(return_template_handle, 0);
                if first_param >= 0 && first_param < param_count {
                    let env_slot: i32 = env_values_ptr + first_param * 8;
                    let captured_kind: i32 = load_i32(env_slot + WORD_SIZE);
                    if captured_kind == BUILTIN_TYPE_ID_TYPE {
                        let captured_value: i32 = load_i32(env_slot);
                        if captured_value < 0 {
                            return -1;
                        }
                        specialized_return_type = captured_value;
                    }
                }
            }
        }
    }
    let mut cloned_body_data0: i32 = body_data0;
    if body_kind == 2 {
        cloned_body_data0 = clone_const_specialization_expr(
            ast_base,
            index,
            key_ptr,
            const_entry_count,
            body_data0,
            env_values_ptr,
            param_count,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            local_type_stack_ptr,
            local_type_stack_top_ptr,
            local_type_stack_capacity,
        );
        if cloned_body_data0 < 0 {
            return -1;
        }
    }
    let new_index: i32 = current_count;
    let dest_ptr: i32 = ast_function_entry_ptr(ast_base, new_index);
    let mut word_idx: i32 = 0;
    let total_words: i32 = AST_FUNCTION_ENTRY_SIZE >> 2;
    while word_idx < total_words {
        let value: i32 = load_i32(source_ptr + word_idx * WORD_SIZE);
        store_i32(dest_ptr + word_idx * WORD_SIZE, value);
        word_idx = word_idx + 1;
    };
    store_i32(dest_ptr, 0);
    store_i32(dest_ptr + 4, 0);
    if body_kind == 2 {
        store_i32(dest_ptr + 16, cloned_body_data0);
    }
    store_i32(dest_ptr + 8, runtime_param_count);
    if runtime_param_count > 0 {
        store_i32(dest_ptr + 24, specialized_param_types_ptr);
    } else {
        store_i32(dest_ptr + 24, -1);
    }
    store_i32(dest_ptr + 28, specialized_return_type);
    let original_flags: i32 = load_i32(dest_ptr + 32);
    let const_mask: i32 = original_flags & FUNCTION_FLAG_HAS_CONST_PARAMS;
    let cleared_flags: i32 = original_flags - const_mask;
    store_i32(dest_ptr + 32, cleared_flags);
    store_i32(dest_ptr + 36, 0);
    ast_function_set_template_owner_index(ast_base, new_index, 0);
    ast_functions_set_count(ast_base, new_index + 1);
    new_index
}

fn canonicalize_const_value(
    ast_base: i32,
    raw_value: i32,
    raw_type: i32,
    call_data_used_ptr: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
) -> i32 {
    if raw_type < 0 {
        return -1;
    }
    if type_id_is_bool(raw_type) {
        let normalized: i32 = if raw_value == 0 { 0 } else { 1 };
        store_i32(out_value_ptr, normalized);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        return 0;
    }
    if constant_eval_integer_type_supported(raw_type) {
        let normalized: i32 = normalize_integer_value(raw_value, raw_type);
        if normalized < 0 {
            return -1;
        }
        store_i32(out_value_ptr, normalized);
        store_i32(out_type_ptr, raw_type);
        return 0;
    }
    if type_id_is_type(raw_type) {
        if raw_value < 0 {
            return -1;
        }
        store_i32(out_value_ptr, raw_value);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
        return 0;
    }
    if type_id_is_tuple(raw_type) {
        let tuple_idx: i32 = tuple_type_index(raw_type);
        if tuple_idx < 0 {
            return -1;
        }
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count < 0 {
            return -1;
        }
        if element_count == 0 {
            store_i32(out_value_ptr, 0);
            store_i32(out_type_ptr, raw_type);
            return 0;
        }
        if raw_value <= 0 {
            return -1;
        }
        let pair_words: i32 = element_count * 2;
        if pair_words <= 0 {
            return -1;
        }
        let canonical_ptr: i32 = ast_call_data_alloc(ast_base, pair_words);
        if canonical_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            }
            let element_slot: i32 = raw_value + idx * 2 * WORD_SIZE;
            let element_value: i32 = load_i32(element_slot);
            let element_type: i32 = load_i32(element_slot + WORD_SIZE);
            let canonical_slot: i32 = canonical_ptr + idx * 2 * WORD_SIZE;
            store_i32(canonical_slot, element_value);
            store_i32(canonical_slot + WORD_SIZE, element_type);
            idx = idx + 1;
        };
        store_i32(out_value_ptr, canonical_ptr);
        store_i32(out_type_ptr, raw_type);
        return 0;
    }
    if type_id_is_array(raw_type) {
        if array_type_element_type(ast_base, raw_type) < 0 {
            return -1;
        }
        let length: i32 = array_type_length(ast_base, raw_type);
        if length < 0 {
            return -1;
        }
        if length == 0 {
            store_i32(out_value_ptr, 0);
            store_i32(out_type_ptr, raw_type);
            return 0;
        }
        if raw_value <= 0 {
            return -1;
        }
        let pair_words: i32 = length * 2;
        if pair_words <= 0 {
            return -1;
        }
        let canonical_ptr: i32 = ast_call_data_alloc(ast_base, pair_words);
        if canonical_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        loop {
            if idx >= length {
                break;
            }
            let element_slot: i32 = raw_value + idx * 2 * WORD_SIZE;
            let element_value: i32 = load_i32(element_slot);
            let element_value_type: i32 = load_i32(element_slot + WORD_SIZE);
            let canonical_slot: i32 = canonical_ptr + idx * 2 * WORD_SIZE;
            store_i32(canonical_slot, element_value);
            store_i32(canonical_slot + WORD_SIZE, element_value_type);
            idx = idx + 1;
        };
        store_i32(out_value_ptr, canonical_ptr);
        store_i32(out_type_ptr, raw_type);
        return 0;
    }
    -1
}

fn ast_function_canonicalize_const_env(
    ast_base: i32,
    index: i32,
    env_ptr: i32,
) -> i32 {
    if index < 0 {
        return -1;
    }
    if !ast_function_has_const_params(ast_base, index) {
        return 0;
    }
    if env_ptr <= 0 {
        return -1;
    }
    let param_count: i32 = ast_function_param_count(ast_base, index);
    if param_count < 0 {
        return -1;
    }
    let env_param_count: i32 = load_i32(env_ptr);
    if env_param_count != param_count {
        return -1;
    }
    let const_count: i32 = ast_function_const_params_count(ast_base, index);
    if const_count <= 0 {
        return 0;
    }
    let values_ptr: i32 = env_ptr + WORD_SIZE;
    let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let saved_call_data_used: i32 = load_i32(call_data_used_ptr);
    let payload_words: i32 = 1 + const_count * 3;
    if payload_words <= 0 {
        return -1;
    }
    let payload_ptr: i32 = ast_call_data_alloc(ast_base, payload_words);
    if payload_ptr < 0 {
        return -1;
    }
    store_i32(payload_ptr, const_count);
    let mut collected: i32 = 0;
    let mut param_index: i32 = 0;
    while param_index < param_count {
        if ast_function_param_is_const(ast_base, index, param_index) {
            let slot_ptr: i32 = values_ptr + param_index * 8;
            let raw_value: i32 = load_i32(slot_ptr);
            let raw_type: i32 = load_i32(slot_ptr + 4);
            if raw_type < 0 {
                store_i32(call_data_used_ptr, saved_call_data_used);
                return -1;
            }
            let entry_ptr: i32 = payload_ptr + WORD_SIZE + collected * 3 * WORD_SIZE;
            store_i32(entry_ptr, param_index);
            if canonicalize_const_value(
                ast_base,
                raw_value,
                raw_type,
                call_data_used_ptr,
                entry_ptr + WORD_SIZE,
                entry_ptr + 2 * WORD_SIZE,
            ) < 0 {
                store_i32(call_data_used_ptr, saved_call_data_used);
                return -1;
            }
            collected = collected + 1;
        }
        param_index = param_index + 1;
    };
    if collected != const_count {
        store_i32(call_data_used_ptr, saved_call_data_used);
        return -1;
    }
    payload_ptr
}

fn ast_names_len_ptr(ast_base: i32) -> i32 {
    ast_base + WORD_SIZE + AST_MAX_FUNCTIONS * AST_FUNCTION_ENTRY_SIZE
}

fn ast_names_base(ast_base: i32) -> i32 {
    ast_names_len_ptr(ast_base) + WORD_SIZE
}

fn ast_call_data_len_ptr(ast_base: i32) -> i32 {
    ast_names_base(ast_base) + AST_NAMES_CAPACITY
}

fn ast_call_data_base(ast_base: i32) -> i32 {
    ast_call_data_len_ptr(ast_base) + WORD_SIZE
}

fn ast_const_specialization_registry_head_ptr(ast_base: i32) -> i32 {
    ast_call_data_base(ast_base)
}

fn ast_const_specialization_registry_head(ast_base: i32) -> i32 {
    load_i32(ast_const_specialization_registry_head_ptr(ast_base))
}

fn ast_const_specialization_registry_set_head(ast_base: i32, value: i32) {
    store_i32(ast_const_specialization_registry_head_ptr(ast_base), value);
}

fn ast_reset(ast_base: i32) {
    store_i32(ast_functions_count_ptr(ast_base), 0);
    store_i32(ast_names_len_ptr(ast_base), 0);
    store_i32(ast_call_data_len_ptr(ast_base), 1);
    ast_const_specialization_registry_set_head(ast_base, 0);
    ast_constants_reset(ast_base);
    ast_array_types_reset(ast_base);
    ast_tuple_types_reset(ast_base);
    ast_struct_types_reset(ast_base);
    ast_expr_reset(ast_base);
}

fn ast_store_name(ast_base: i32, source_base: i32, start: i32, len: i32) -> i32 {
    let name_len_ptr: i32 = ast_names_len_ptr(ast_base);
    let mut used: i32 = load_i32(name_len_ptr);
    if used + len > AST_NAMES_CAPACITY {
        return -1;
    }
    let name_ptr: i32 = ast_names_base(ast_base) + used;
    let mut idx: i32 = 0;
    while idx < len {
        let byte: i32 = load_u8(source_base + start + idx);
        store_u8(name_ptr + idx, byte);
        idx = idx + 1;
    };
    used = used + len;
    store_i32(name_len_ptr, used);
    name_ptr
}

fn ast_call_data_alloc(ast_base: i32, word_count: i32) -> i32 {
    if word_count <= 0 {
        return -1;
    }
    let used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let used: i32 = load_i32(used_ptr);
    if used + word_count > AST_CALL_DATA_CAPACITY {
        return -1;
    }
    let entry_ptr: i32 = ast_call_data_base(ast_base) + used * WORD_SIZE;
    store_i32(used_ptr, used + word_count);
    entry_ptr
}

fn inline_wasm_literal_byte(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind != 0 {
        return -1;
    }
    let literal_type: i32 = ast_expr_type(ast_base, expr_index);
    if literal_type < 0 {
        return -1;
    }
    if !type_id_is_integer(literal_type) {
        return -1;
    }
    let value: i32 = load_i32(entry_ptr + 4);
    let normalized: i32 = normalize_integer_value(value, literal_type);
    if normalized < 0 {
        return -1;
    }
    if normalized > 255 {
        return -1;
    }
    normalized
}

fn inline_wasm_collect_bytes(
    ast_base: i32,
    expr_index: i32,
    out_ptr_ptr: i32,
    out_len_ptr: i32,
) -> i32 {
    if out_ptr_ptr < 0 {
        return -1;
    }
    if out_len_ptr < 0 {
        return -1;
    }
    store_i32(out_ptr_ptr, 0);
    store_i32(out_len_ptr, 0);
    if expr_index < 0 {
        return -1;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        }
        if length == 0 {
            return 0;
        }
        let byte_value: i32 = inline_wasm_literal_byte(ast_base, element_index);
        if byte_value < 0 {
            return -1;
        }
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let bytes_ptr: i32 = ast_call_data_alloc(ast_base, length);
        if bytes_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < length {
            store_i32(bytes_ptr + idx * WORD_SIZE, byte_value);
            idx = idx + 1;
        };
        store_i32(out_ptr_ptr, bytes_ptr);
        store_i32(out_len_ptr, length);
        return 0;
    }
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        }
        if element_count == 0 {
            return 0;
        }
        if values_ptr < 0 {
            return -1;
        }
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let bytes_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if bytes_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < element_count {
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let byte_value: i32 = inline_wasm_literal_byte(ast_base, element_index);
            if byte_value < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            store_i32(bytes_ptr + idx * WORD_SIZE, byte_value);
            idx = idx + 1;
        };
        store_i32(out_ptr_ptr, bytes_ptr);
        store_i32(out_len_ptr, element_count);
        return 0;
    }
    -1
}

fn call_metadata_name_ptr(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr)
}

fn call_metadata_name_len(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 4)
}

fn call_metadata_arg_count(metadata_ptr: i32) -> i32 {
    load_i32(metadata_ptr + 8)
}

fn call_metadata_callee_index_ptr(metadata_ptr: i32) -> i32 {
    metadata_ptr + 12
}

fn call_metadata_args_base(metadata_ptr: i32) -> i32 {
    metadata_ptr + 16
}

fn call_metadata_extra_slot_base(metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 { return 0; }
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    metadata_ptr + 16 + arg_count * WORD_SIZE
}

fn call_metadata_compact_runtime_args(
    ast_base: i32,
    metadata_ptr: i32,
    callee_index: i32,
    runtime_param_count: i32,
) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    if runtime_param_count < 0 {
        return -1;
    }
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    if arg_count < 0 {
        return -1;
    }
    if runtime_param_count == arg_count {
        return metadata_ptr;
    }
    if runtime_param_count > arg_count {
        return -1;
    }
    let key_ptr: i32 = call_metadata_const_key_ptr(metadata_ptr);
    if key_ptr <= 0 {
        return -1;
    }
    let const_entry_count: i32 = load_i32(key_ptr);
    if const_entry_count <= 0 {
        return -1;
    }
    let name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
    let name_len: i32 = call_metadata_name_len(metadata_ptr);
    let original_args_base: i32 = call_metadata_args_base(metadata_ptr);
    if arg_count > 0 && original_args_base < 0 {
        return -1;
    }
    let total_words: i32 = 4 + runtime_param_count + 5;
    if total_words <= 0 {
        return -1;
    }
    let new_metadata: i32 = ast_call_data_alloc(ast_base, total_words);
    if new_metadata < 0 {
        return -1;
    }
    store_i32(new_metadata, name_ptr);
    store_i32(new_metadata + WORD_SIZE, name_len);
    store_i32(new_metadata + 2 * WORD_SIZE, runtime_param_count);
    store_i32(new_metadata + 3 * WORD_SIZE, callee_index);
    let new_args_base: i32 = call_metadata_args_base(new_metadata);
    let mut arg_idx: i32 = 0;
    let mut runtime_idx: i32 = 0;
    let mut key_idx: i32 = 0;
    while arg_idx < arg_count {
        let mut skip_arg: bool = false;
        while key_idx < const_entry_count {
            let entry_ptr: i32 = key_ptr + WORD_SIZE + key_idx * 3 * WORD_SIZE;
            let recorded_param: i32 = load_i32(entry_ptr);
            if recorded_param < 0 {
                return -1;
            }
            if recorded_param < arg_idx {
                key_idx = key_idx + 1;
                continue;
            }
            if recorded_param == arg_idx {
                skip_arg = true;
                key_idx = key_idx + 1;
            }
            break;
        };
        if !skip_arg {
            if runtime_idx >= runtime_param_count {
                return -1;
            }
            let arg_expr_index: i32 = load_i32(original_args_base + arg_idx * WORD_SIZE);
            store_i32(new_args_base + runtime_idx * WORD_SIZE, arg_expr_index);
            runtime_idx = runtime_idx + 1;
        }
        arg_idx = arg_idx + 1;
    };
    if runtime_idx != runtime_param_count {
        return -1;
    }
    let original_extra: i32 = call_metadata_extra_slot_base(metadata_ptr);
    let new_extra: i32 = call_metadata_extra_slot_base(new_metadata);
    if original_extra > 0 && new_extra > 0 {
        let mut extra_idx: i32 = 0;
        while extra_idx < 5 {
            let value: i32 = load_i32(original_extra + extra_idx * WORD_SIZE);
            store_i32(new_extra + extra_idx * WORD_SIZE, value);
            extra_idx = extra_idx + 1;
        };
    }
    new_metadata
}

fn call_metadata_const_usage_list_slot(metadata_ptr: i32) -> i32 {
    call_metadata_extra_slot_base(metadata_ptr)
}

fn call_metadata_const_usage_count_ptr(metadata_ptr: i32) -> i32 {
    let base_ptr: i32 = call_metadata_extra_slot_base(metadata_ptr);
    if base_ptr <= 0 { return 0; }
    base_ptr + WORD_SIZE
}

fn call_metadata_const_usage_count(metadata_ptr: i32) -> i32 {
    let count_ptr: i32 = call_metadata_const_usage_count_ptr(metadata_ptr);
    if count_ptr <= 0 { return 0; }
    load_i32(count_ptr)
}

fn call_metadata_template_payload_ptr(metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 { return 0; }
    let base_ptr: i32 = call_metadata_extra_slot_base(metadata_ptr);
    if base_ptr <= 0 { return 0; }
    base_ptr + 2 * WORD_SIZE
}

fn call_metadata_const_env_ptr_ptr(metadata_ptr: i32) -> i32 {
    let base_ptr: i32 = call_metadata_extra_slot_base(metadata_ptr);
    if base_ptr <= 0 { return 0; }
    base_ptr + 3 * WORD_SIZE
}

fn call_metadata_const_env_ptr(metadata_ptr: i32) -> i32 {
    let ptr: i32 = call_metadata_const_env_ptr_ptr(metadata_ptr);
    if ptr <= 0 { return 0; }
    load_i32(ptr)
}

fn call_metadata_const_key_ptr_ptr(metadata_ptr: i32) -> i32 {
    let base_ptr: i32 = call_metadata_extra_slot_base(metadata_ptr);
    if base_ptr <= 0 { return 0; }
    base_ptr + 4 * WORD_SIZE
}

fn call_metadata_const_key_ptr(metadata_ptr: i32) -> i32 {
    let ptr: i32 = call_metadata_const_key_ptr_ptr(metadata_ptr);
    if ptr <= 0 { return 0; }
    load_i32(ptr)
}

fn ast_write_function_entry(
    ast_base: i32,
    index: i32,
    name_ptr: i32,
    name_len: i32,
    param_count: i32,
    body_kind: i32,
    body_data0: i32,
    locals_count: i32,
    param_types_ptr: i32,
    return_type_id: i32,
    flags: i32,
    const_params_ptr: i32,
    template_owner_index: i32,
    module_base: i32,
    module_len: i32,
    module_index: i32,
    name_start: i32,
) {
    let entry_ptr: i32 = ast_function_entry_ptr(ast_base, index);
    store_i32(entry_ptr, name_ptr);
    store_i32(entry_ptr + 4, name_len);
    store_i32(entry_ptr + 8, param_count);
    store_i32(entry_ptr + 12, body_kind);
    store_i32(entry_ptr + 16, body_data0);
    store_i32(entry_ptr + 20, locals_count);
    store_i32(entry_ptr + 24, param_types_ptr);
    store_i32(entry_ptr + 28, return_type_id);
    store_i32(entry_ptr + 32, flags);
    store_i32(entry_ptr + 36, const_params_ptr);
    store_i32(entry_ptr + 40, template_owner_index);
    store_i32(entry_ptr + 44, module_base);
    store_i32(entry_ptr + 48, module_len);
    store_i32(entry_ptr + 52, module_index);
    store_i32(entry_ptr + 56, name_start);
}

fn ast_constants_count_ptr(ast_base: i32) -> i32 {
    ast_call_data_base(ast_base) + AST_CALL_DATA_CAPACITY * WORD_SIZE
}

fn ast_constant_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + WORD_SIZE + index * AST_CONSTANT_ENTRY_SIZE
}

fn ast_constant_entry_name_start_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_NAME_OFFSET
}

fn ast_constant_entry_name_len_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_NAME_LEN_OFFSET
}

fn ast_constant_entry_value_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_VALUE_OFFSET
}

fn ast_constant_entry_type_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_TYPE_OFFSET
}

fn ast_constant_entry_expr_index_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_EXPR_INDEX_OFFSET
}

fn ast_constant_entry_eval_state_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_EVAL_STATE_OFFSET
}

fn ast_constant_entry_module_index_ptr(entry_ptr: i32) -> i32 {
    entry_ptr + AST_CONSTANT_ENTRY_MODULE_INDEX_OFFSET
}

fn ast_constant_entry_name_start(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_name_start_ptr(entry_ptr))
}

fn ast_constant_entry_name_len(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_name_len_ptr(entry_ptr))
}

fn ast_constant_entry_value(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_value_ptr(entry_ptr))
}

fn ast_constant_entry_type(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_type_ptr(entry_ptr))
}

fn ast_constant_entry_expr_index(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_expr_index_ptr(entry_ptr))
}

fn ast_constant_entry_eval_state(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_eval_state_ptr(entry_ptr))
}

fn ast_constant_entry_module_index(entry_ptr: i32) -> i32 {
    load_i32(ast_constant_entry_module_index_ptr(entry_ptr))
}

fn ast_constant_entry_set_expr_index(entry_ptr: i32, expr_index: i32) {
    store_i32(ast_constant_entry_expr_index_ptr(entry_ptr), expr_index);
}

fn ast_constant_entry_set_eval_state(entry_ptr: i32, eval_state: i32) {
    store_i32(ast_constant_entry_eval_state_ptr(entry_ptr), eval_state);
}

fn ast_constant_entry_set_module_index(entry_ptr: i32, module_index: i32) {
    store_i32(ast_constant_entry_module_index_ptr(entry_ptr), module_index);
}

const AST_CONSTANT_EVAL_STATE_UNEVALUATED: i32 = 0;

const AST_CONSTANT_EVAL_STATE_EVALUATING: i32 = 1;

const AST_CONSTANT_EVAL_STATE_EVALUATED: i32 = 2;

fn ast_constants_count(ast_base: i32) -> i32 {
    load_i32(ast_constants_count_ptr(ast_base))
}

fn ast_constants_reset(ast_base: i32) {
    store_i32(ast_constants_count_ptr(ast_base), 0);
    let mut idx: i32 = 0;
    while idx < AST_CONSTANTS_CAPACITY {
        let entry_ptr: i32 = ast_constant_entry_ptr(ast_base, idx);
        ast_constant_entry_set_expr_index(entry_ptr, -1);
        ast_constant_entry_set_eval_state(entry_ptr, AST_CONSTANT_EVAL_STATE_UNEVALUATED);
        ast_constant_entry_set_module_index(entry_ptr, -1);
        idx = idx + 1;
    };
}

const AST_ARRAY_TYPES_CAPACITY: i32 = ARRAY_TYPE_CAPACITY;

const AST_ARRAY_TYPE_ENTRY_SIZE: i32 = 12;

const AST_ARRAY_TYPE_ELEMENT_OFFSET: i32 = 0;

const AST_ARRAY_TYPE_LENGTH_OFFSET: i32 = 4;

const AST_ARRAY_TYPE_CACHE_OFFSET: i32 = 8;

const AST_ARRAY_TYPES_SECTION_SIZE: i32 = WORD_SIZE + AST_ARRAY_TYPES_CAPACITY * AST_ARRAY_TYPE_ENTRY_SIZE;

fn ast_array_types_count_ptr(ast_base: i32) -> i32 {
    ast_constants_count_ptr(ast_base) + AST_CONSTANTS_SECTION_SIZE
}

fn ast_array_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + WORD_SIZE + index * AST_ARRAY_TYPE_ENTRY_SIZE
}

fn ast_array_type_element_type(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_ELEMENT_OFFSET)
}

fn ast_array_type_length(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_LENGTH_OFFSET)
}

fn tuple_type_metadata_index(index: i32) -> i32 {
    ARRAY_TYPE_CAPACITY + index
}

fn struct_type_metadata_index(index: i32) -> i32 {
    ARRAY_TYPE_CAPACITY + TUPLE_TYPE_CAPACITY + index
}

fn ast_array_type_payload_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_type_entry_ptr(ast_base, index)
}

fn ast_array_types_count(ast_base: i32) -> i32 {
    load_i32(ast_array_types_count_ptr(ast_base))
}

fn ast_array_types_reset(ast_base: i32) {
    store_i32(ast_array_types_count_ptr(ast_base), 0);
}

const AST_TUPLE_TYPES_CAPACITY: i32 = TUPLE_TYPE_CAPACITY;

const AST_TUPLE_TYPE_ENTRY_SIZE: i32 = 12;

const AST_TUPLE_TYPE_COUNT_OFFSET: i32 = 0;

const AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET: i32 = 4;

const AST_TUPLE_TYPE_CACHE_OFFSET: i32 = 8;

const AST_TUPLE_TYPES_SECTION_SIZE: i32 =
    WORD_SIZE + AST_TUPLE_TYPES_CAPACITY * AST_TUPLE_TYPE_ENTRY_SIZE;

fn ast_tuple_types_count_ptr(ast_base: i32) -> i32 {
    ast_array_types_count_ptr(ast_base) + AST_ARRAY_TYPES_SECTION_SIZE
}

const AST_ARRAY_HEAP_INDEX_SECTION_SIZE: i32 = ARRAY_TYPE_CAPACITY * WORD_SIZE;

fn ast_array_heap_indices_base(ast_base: i32) -> i32 {
    ast_tuple_types_count_ptr(ast_base) + AST_TUPLE_TYPES_SECTION_SIZE
}

fn ast_array_heap_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_array_heap_indices_base(ast_base) + index * WORD_SIZE
}

fn ast_array_heap_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_heap_index_ptr(ast_base, index))
}

fn ast_array_heap_index_set(ast_base: i32, index: i32, heap_index: i32) {
    store_i32(ast_array_heap_index_ptr(ast_base, index), heap_index);
}

const AST_TUPLE_HEAP_INDEX_SECTION_SIZE: i32 = TUPLE_TYPE_CAPACITY * WORD_SIZE;

fn ast_tuple_heap_indices_base(ast_base: i32) -> i32 {
    ast_array_heap_indices_base(ast_base) + AST_ARRAY_HEAP_INDEX_SECTION_SIZE
}

const AST_STRUCT_TYPES_CAPACITY: i32 = STRUCT_TYPE_CAPACITY;

const AST_STRUCT_TYPE_ENTRY_SIZE: i32 = 20;

const AST_STRUCT_TYPE_FIELD_COUNT_OFFSET: i32 = 0;

const AST_STRUCT_TYPE_NAME_LEN_OFFSET: i32 = 4;

const AST_STRUCT_TYPE_FIELD_STRIDE_OFFSET: i32 = 8;

const AST_STRUCT_TYPE_FIELDS_PTR_OFFSET: i32 = 12;

const AST_STRUCT_TYPE_CACHE_OFFSET: i32 = 16;

const STRUCT_FIELD_METADATA_HEADER_WORDS: i32 = 2;

const STRUCT_FIELD_TYPE_WORD_OFFSET: i32 = 0;

const STRUCT_FIELD_OFFSET_WORD_OFFSET: i32 = 1;

const STRUCT_LITERAL_METADATA_HEADER_WORDS: i32 = 1;

const STRUCT_LITERAL_FIELD_ENTRY_WORDS: i32 = 5;

const STRUCT_LITERAL_FIELD_LABEL_KIND_OFFSET: i32 = 0;

const STRUCT_LITERAL_FIELD_LABEL_DATA_OFFSET: i32 = 1;

const STRUCT_LITERAL_FIELD_LABEL_EXTRA_OFFSET: i32 = 2;

const STRUCT_LITERAL_FIELD_LOCATION_OFFSET: i32 = 3;

const STRUCT_LITERAL_FIELD_VALUE_OFFSET: i32 = 4;

const STRUCT_LITERAL_LABEL_KIND_IDENTIFIER: i32 = 0;

const STRUCT_LITERAL_LABEL_KIND_EXPRESSION: i32 = 1;

const STRUCT_GET_LABEL_ENTRY_WORDS: i32 = 3;

const STRUCT_GET_LABEL_KIND_OFFSET: i32 = 0;

const STRUCT_GET_LABEL_DATA_OFFSET: i32 = 1;

const STRUCT_GET_LABEL_EXTRA_OFFSET: i32 = 2;
const AST_STRUCT_TYPES_SECTION_SIZE: i32 =
    WORD_SIZE + AST_STRUCT_TYPES_CAPACITY * AST_STRUCT_TYPE_ENTRY_SIZE;

const AST_STRUCT_HEAP_INDEX_SECTION_SIZE: i32 = STRUCT_TYPE_CAPACITY * WORD_SIZE;

fn ast_tuple_heap_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_tuple_heap_indices_base(ast_base) + index * WORD_SIZE
}

fn ast_tuple_heap_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_heap_index_ptr(ast_base, index))
}

fn ast_tuple_heap_index_set(ast_base: i32, index: i32, heap_index: i32) {
    store_i32(ast_tuple_heap_index_ptr(ast_base, index), heap_index);
}

fn ast_tuple_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_tuple_types_count_ptr(ast_base) + WORD_SIZE + index * AST_TUPLE_TYPE_ENTRY_SIZE
}

fn ast_tuple_types_count(ast_base: i32) -> i32 {
    load_i32(ast_tuple_types_count_ptr(ast_base))
}

fn ast_tuple_types_reset(ast_base: i32) {
    store_i32(ast_tuple_types_count_ptr(ast_base), 0);
}

fn ast_struct_types_count_ptr(ast_base: i32) -> i32 {
    ast_tuple_heap_indices_base(ast_base) + AST_TUPLE_HEAP_INDEX_SECTION_SIZE
}

fn ast_struct_heap_indices_base(ast_base: i32) -> i32 {
    ast_struct_types_count_ptr(ast_base) + AST_STRUCT_TYPES_SECTION_SIZE
}

fn ast_struct_heap_index_ptr(ast_base: i32, index: i32) -> i32 {
    ast_struct_heap_indices_base(ast_base) + index * WORD_SIZE
}

fn ast_struct_heap_index(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_heap_index_ptr(ast_base, index))
}

fn ast_struct_heap_index_set(ast_base: i32, index: i32, heap_index: i32) {
    store_i32(ast_struct_heap_index_ptr(ast_base, index), heap_index);
}

fn ast_struct_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_struct_types_count_ptr(ast_base)
        + WORD_SIZE
        + index * AST_STRUCT_TYPE_ENTRY_SIZE
}

fn ast_struct_types_count(ast_base: i32) -> i32 {
    load_i32(ast_struct_types_count_ptr(ast_base))
}

fn ast_struct_types_reset(ast_base: i32) {
    store_i32(ast_struct_types_count_ptr(ast_base), 0);
}

fn ast_struct_type_field_count(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_FIELD_COUNT_OFFSET)
}

fn ast_struct_type_name_length(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_NAME_LEN_OFFSET)
}

fn ast_struct_type_field_stride(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_FIELD_STRIDE_OFFSET)
}

fn ast_struct_type_fields_ptr(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_FIELDS_PTR_OFFSET)
}

fn ast_struct_type_field_record_ptr(
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
) -> i32 {
    if struct_index < 0 {
        return -1;
    }
    if field_index < 0 {
        return -1;
    }
    if struct_index >= ast_struct_types_count(ast_base) {
        return -1;
    }
    let field_count: i32 = ast_struct_type_field_count(ast_base, struct_index);
    if field_index >= field_count {
        return -1;
    }
    let fields_ptr: i32 = ast_struct_type_fields_ptr(ast_base, struct_index);
    if field_count > 0 {
        if fields_ptr <= 0 {
            return -1;
        }
    }
    let stride: i32 = ast_struct_type_field_stride(ast_base, struct_index);
    if stride < STRUCT_FIELD_METADATA_HEADER_WORDS {
        return -1;
    }
    fields_ptr + field_index * stride * WORD_SIZE
}

fn ast_struct_type_field_type(
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
) -> i32 {
    let record_ptr: i32 = ast_struct_type_field_record_ptr(ast_base, struct_index, field_index);
    if record_ptr < 0 {
        return -1;
    }
    load_i32(record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE)
}

fn struct_field_trimmed_length(
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
) -> i32 {
    let name_length: i32 = ast_struct_type_name_length(ast_base, struct_index);
    if name_length <= 0 {
        return 0;
    }
    let mut trimmed: i32 = name_length;
    loop {
        if trimmed <= 0 {
            break;
        }
        let byte: i32 = ast_struct_type_field_canonical_byte(
            ast_base,
            struct_index,
            field_index,
            trimmed - 1,
        );
        if byte != 0 {
            break;
        }
        trimmed = trimmed - 1;
    };
    trimmed
}

fn struct_field_identifier_matches(
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
    ident_ptr: i32,
    ident_len: i32,
) -> bool {
    if ident_ptr <= 0 {
        return false;
    }
    if ident_len < 0 {
        return false;
    }
    let trimmed: i32 = struct_field_trimmed_length(ast_base, struct_index, field_index);
    if ident_len != trimmed {
        return false;
    }
    let mut idx: i32 = 0;
    loop {
        if idx >= trimmed {
            break;
        }
        let expected: i32 = ast_struct_type_field_canonical_byte(
            ast_base,
            struct_index,
            field_index,
            idx,
        );
        let actual: i32 = load_u8(ident_ptr + idx);
        if expected != actual {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn struct_literal_field_entry_ptr(metadata_ptr: i32, index: i32) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    if index < 0 {
        return -1;
    }
    metadata_ptr
        + STRUCT_LITERAL_METADATA_HEADER_WORDS * WORD_SIZE
        + index * STRUCT_LITERAL_FIELD_ENTRY_WORDS * WORD_SIZE
}

fn struct_literal_field_label_kind(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_KIND_OFFSET * WORD_SIZE)
}

fn struct_literal_field_label_data(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_DATA_OFFSET * WORD_SIZE)
}

fn struct_literal_field_label_extra(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_EXTRA_OFFSET * WORD_SIZE)
}

fn struct_literal_field_location(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + STRUCT_LITERAL_FIELD_LOCATION_OFFSET * WORD_SIZE)
}

fn struct_literal_field_value_index(entry_ptr: i32) -> i32 {
    load_i32(entry_ptr + STRUCT_LITERAL_FIELD_VALUE_OFFSET * WORD_SIZE)
}

fn struct_literal_field_set_label_kind(entry_ptr: i32, value: i32) {
    store_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_KIND_OFFSET * WORD_SIZE, value);
}

fn struct_literal_field_set_label_data(entry_ptr: i32, value: i32) {
    store_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_DATA_OFFSET * WORD_SIZE, value);
}

fn struct_literal_field_set_label_extra(entry_ptr: i32, value: i32) {
    store_i32(entry_ptr + STRUCT_LITERAL_FIELD_LABEL_EXTRA_OFFSET * WORD_SIZE, value);
}

fn struct_literal_field_set_location(entry_ptr: i32, value: i32) {
    store_i32(entry_ptr + STRUCT_LITERAL_FIELD_LOCATION_OFFSET * WORD_SIZE, value);
}

fn struct_literal_field_set_value(entry_ptr: i32, value: i32) {
    store_i32(entry_ptr + STRUCT_LITERAL_FIELD_VALUE_OFFSET * WORD_SIZE, value);
}

fn struct_get_label_kind(metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    return load_i32(metadata_ptr + STRUCT_GET_LABEL_KIND_OFFSET * WORD_SIZE);
}

fn struct_get_label_data(metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    load_i32(metadata_ptr + STRUCT_GET_LABEL_DATA_OFFSET * WORD_SIZE)
}

fn struct_get_label_extra(metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    load_i32(metadata_ptr + STRUCT_GET_LABEL_EXTRA_OFFSET * WORD_SIZE)
}

fn struct_get_label_set_kind(metadata_ptr: i32, value: i32) {
    if metadata_ptr > 0 {
        store_i32(metadata_ptr + STRUCT_GET_LABEL_KIND_OFFSET * WORD_SIZE, value);
    }
}

fn struct_get_label_set_data(metadata_ptr: i32, value: i32) {
    if metadata_ptr > 0 {
        store_i32(metadata_ptr + STRUCT_GET_LABEL_DATA_OFFSET * WORD_SIZE, value);
    }
}

fn struct_get_label_set_extra(metadata_ptr: i32, value: i32) {
    if metadata_ptr > 0 {
        store_i32(metadata_ptr + STRUCT_GET_LABEL_EXTRA_OFFSET * WORD_SIZE, value);
    }
}


fn ast_struct_type_field_canonical_byte(
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
    byte_index: i32,
) -> i32 {
    if byte_index < 0 {
        return -1;
    }
    let record_ptr: i32 = ast_struct_type_field_record_ptr(ast_base, struct_index, field_index);
    if record_ptr < 0 {
        return -1;
    }
    let name_length: i32 = ast_struct_type_name_length(ast_base, struct_index);
    if byte_index >= name_length {
        return -1;
    }
    load_i32(
        record_ptr
            + (STRUCT_FIELD_METADATA_HEADER_WORDS + byte_index) * WORD_SIZE,
    )
}

fn struct_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_CACHE_OFFSET)
}

fn struct_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_struct_type_entry_ptr(ast_base, index) + AST_STRUCT_TYPE_CACHE_OFFSET, type_id);
}

fn ast_tuple_type_element_count(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_COUNT_OFFSET)
}

fn ast_tuple_type_elements_ptr(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET)
}

fn tuple_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_CACHE_OFFSET)
}

fn tuple_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_tuple_type_entry_ptr(ast_base, index) + AST_TUPLE_TYPE_CACHE_OFFSET, type_id);
}

const TYPE_METADATA_CACHE_IN_PROGRESS: i32 = -2;

fn record_type_metadata_debug(out_ptr: i32, context: i32, subject: i32, extra: i32) {
    if out_ptr > 0 {
        store_i32(out_ptr + SCRATCH_TYPE_METADATA_DEBUG_CONTEXT_OFFSET, context);
        store_i32(out_ptr + SCRATCH_TYPE_METADATA_DEBUG_SUBJECT_OFFSET, subject);
        store_i32(out_ptr + SCRATCH_TYPE_METADATA_DEBUG_EXTRA_OFFSET, extra);
    } else {
        store_i32(SCRATCH_TYPE_METADATA_DEBUG_CONTEXT_OFFSET, context);
        store_i32(SCRATCH_TYPE_METADATA_DEBUG_SUBJECT_OFFSET, subject);
        store_i32(SCRATCH_TYPE_METADATA_DEBUG_EXTRA_OFFSET, extra);
    };
}

fn record_type_metadata_failure(out_ptr: i32) {
    record_type_metadata_debug(out_ptr, 255, 0, 0);
    if out_ptr > 0 {
        let current: i32 =
            load_i32(out_ptr + SCRATCH_TYPE_METADATA_DEBUG_FAILURE_COUNT_OFFSET);
        store_i32(out_ptr + SCRATCH_TYPE_METADATA_DEBUG_FAILURE_COUNT_OFFSET, current + 1);
    } else {
        let current: i32 = load_i32(SCRATCH_TYPE_METADATA_DEBUG_FAILURE_COUNT_OFFSET);
        store_i32(SCRATCH_TYPE_METADATA_DEBUG_FAILURE_COUNT_OFFSET, current + 1);
    };
    if out_ptr > 0 {
        if load_u8(out_ptr) == 0 {
            let message: [u8; 31] = "type metadata resolution failed";
            write_failure_detail(out_ptr, 31, message);
        }
    }
}

fn array_type_cached_id(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET)
}

fn array_type_set_cached_id(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_array_type_entry_ptr(ast_base, index) + AST_ARRAY_TYPE_CACHE_OFFSET, type_id);
}

fn array_type_id(index: i32) -> i32 {
    TYPE_ID_ARRAY_BASE + index
}

fn array_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_ARRAY_BASE
}

fn array_type_element_type(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    }
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    }
    if index >= ast_array_types_count(ast_base) {
        return -1;
    }
    ast_array_type_element_type(ast_base, index)
}

fn array_type_length(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    }
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    }
    if index >= ast_array_types_count(ast_base) {
        return -1;
    }
    ast_array_type_length(ast_base, index)
}

fn tuple_type_id(index: i32) -> i32 {
    TYPE_ID_TUPLE_BASE + index
}

fn tuple_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_TUPLE_BASE
}

fn struct_type_id(index: i32) -> i32 {
    TYPE_ID_STRUCT_BASE + index
}

fn struct_type_index(type_id: i32) -> i32 {
    type_id - TYPE_ID_STRUCT_BASE
}

fn array_type_heap_index(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_array(type_id) {
        return -1;
    }
    let index: i32 = array_type_index(type_id);
    if index < 0 {
        return -1;
    }
    if index >= ast_array_types_count(ast_base) {
        return -1;
    }
    let heap_index: i32 = ast_array_heap_index(ast_base, index);
    if heap_index < 0 {
        return -1;
    }
    heap_index
}

fn tuple_type_heap_index(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_tuple(type_id) {
        return -1;
    }
    let index: i32 = tuple_type_index(type_id);
    if index < 0 {
        return -1;
    }
    if index >= ast_tuple_types_count(ast_base) {
        return -1;
    }
    let heap_index: i32 = ast_tuple_heap_index(ast_base, index);
    if heap_index < 0 {
        return -1;
    }
    heap_index
}

fn struct_type_heap_index(ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_struct(type_id) {
        return -1;
    }
    let index: i32 = struct_type_index(type_id);
    if index < 0 {
        return -1;
    }
    if index >= ast_struct_types_count(ast_base) {
        return -1;
    }
    let heap_index: i32 = ast_struct_heap_index(ast_base, index);
    if heap_index < 0 {
        return -1;
    }
    heap_index
}

fn type_id_heap_type_index(ast_base: i32, type_id: i32) -> i32 {
    if type_id_is_array(type_id) {
        return array_type_heap_index(ast_base, type_id);
    }
    if type_id_is_tuple(type_id) {
        return tuple_type_heap_index(ast_base, type_id);
    }
    if type_id_is_struct(type_id) {
        return struct_type_heap_index(ast_base, type_id);
    }
    -1
}

fn composite_type_dependency_resolved(
    ast_base: i32,
    array_count: i32,
    tuple_count: i32,
    struct_count: i32,
    resolved_ptr: i32,
    type_id: i32,
) -> bool {
    if type_id_is_array(type_id) {
        let dep_index: i32 = array_type_index(type_id);
        if dep_index < 0 {
            return false;
        }
        if dep_index >= array_count {
            return false;
        }
        let resolved: i32 = load_i32(resolved_ptr + dep_index * WORD_SIZE);
        return resolved != 0;
    }
    if type_id_is_tuple(type_id) {
        let dep_index: i32 = tuple_type_index(type_id);
        if dep_index < 0 {
            return false;
        }
        if dep_index >= tuple_count {
            return false;
        }
        let resolved: i32 =
            load_i32(resolved_ptr + (array_count + dep_index) * WORD_SIZE);
        return resolved != 0;
    }
    if type_id_is_struct(type_id) {
        let dep_index: i32 = struct_type_index(type_id);
        if dep_index < 0 {
            return false;
        }
        if dep_index >= struct_count {
            return false;
        }
        let offset: i32 = array_count + tuple_count + dep_index;
        let resolved: i32 = load_i32(resolved_ptr + offset * WORD_SIZE);
        return resolved != 0;
    }
    true
}

fn composite_type_dependencies_resolved(
    ast_base: i32,
    array_count: i32,
    tuple_count: i32,
    struct_count: i32,
    resolved_ptr: i32,
    node_index: i32,
) -> bool {
    if node_index < array_count {
        let element_type_id: i32 = ast_array_type_element_type(ast_base, node_index);
        if element_type_id < 0 {
            return false;
        }
        return composite_type_dependency_resolved(
            ast_base,
            array_count,
            tuple_count,
            struct_count,
            resolved_ptr,
            element_type_id,
        );
    }
    let tuple_idx: i32 = node_index - array_count;
    if tuple_idx < tuple_count {
        if tuple_idx < 0 {
            return false;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count < 0 {
            return false;
        }
        if element_count == 0 {
            return true;
        }
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return false;
        }
        let mut field_idx: i32 = 0;
        while field_idx < element_count {
            let field_type_id: i32 = load_i32(elements_ptr + field_idx * WORD_SIZE);
            if field_type_id < 0 {
                return false;
            }
            if !composite_type_dependency_resolved(
                ast_base,
                array_count,
                tuple_count,
                struct_count,
                resolved_ptr,
                field_type_id,
            ) {
                return false;
            }
            field_idx = field_idx + 1;
        };
        return true;
    }
    let struct_idx: i32 = tuple_idx - tuple_count;
    if struct_idx < 0 {
        return false;
    }
    if struct_idx >= struct_count {
        return false;
    }
    let field_count: i32 = ast_struct_type_field_count(ast_base, struct_idx);
    if field_count < 0 {
        return false;
    }
    if field_count == 0 {
        return true;
    }
    let fields_ptr: i32 = ast_struct_type_fields_ptr(ast_base, struct_idx);
    if fields_ptr < 0 {
        return false;
    }
    let stride: i32 = ast_struct_type_field_stride(ast_base, struct_idx);
    if stride <= 0 {
        return false;
    }
    let mut struct_field_idx: i32 = 0;
    while struct_field_idx < field_count {
        let record_ptr: i32 = fields_ptr + struct_field_idx * stride * WORD_SIZE;
        let field_type_id: i32 = load_i32(record_ptr);
        if field_type_id < 0 {
            return false;
        }
        if !composite_type_dependency_resolved(
            ast_base,
            array_count,
            tuple_count,
            struct_count,
            resolved_ptr,
            field_type_id,
        ) {
            return false;
        }
        struct_field_idx = struct_field_idx + 1;
    };
    true
}

fn assign_heap_type_indices(out_ptr: i32, ast_base: i32) -> i32 {
    let array_count: i32 = ast_array_types_count(ast_base);
    if array_count < 0 {
        return -1;
    }
    let tuple_count: i32 = ast_tuple_types_count(ast_base);
    if tuple_count < 0 {
        return -1;
    }
    let struct_count: i32 = ast_struct_types_count(ast_base);
    if struct_count < 0 {
        return -1;
    }
    let total: i32 = array_count + tuple_count + struct_count;
    let mut idx: i32 = 0;
    while idx < array_count {
        ast_array_heap_index_set(ast_base, idx, -1);
        idx = idx + 1;
    };
    idx = 0;
    while idx < tuple_count {
        ast_tuple_heap_index_set(ast_base, idx, -1);
        idx = idx + 1;
    };
    idx = 0;
    while idx < struct_count {
        ast_struct_heap_index_set(ast_base, idx, -1);
        idx = idx + 1;
    };
    if total <= 0 {
        return 0;
    }
    let resolved_ptr: i32 = ast_temp_base(ast_base);
    let indices_ptr: i32 = resolved_ptr + total * WORD_SIZE;
    idx = 0;
    while idx < total {
        store_i32(resolved_ptr + idx * WORD_SIZE, 0);
        store_i32(indices_ptr + idx * WORD_SIZE, -1);
        idx = idx + 1;
    };
    let mut assigned: i32 = 0;
    let mut next_index: i32 = 0;
    while assigned < total {
        let mut progress: bool = false;
        let mut node: i32 = 0;
        while node < total {
            let resolved: i32 = load_i32(resolved_ptr + node * WORD_SIZE);
            if resolved != 0 {
                node = node + 1;
                continue;
            }
            if composite_type_dependencies_resolved(
                ast_base,
                array_count,
                tuple_count,
                struct_count,
                resolved_ptr,
                node,
            ) {
                store_i32(indices_ptr + node * WORD_SIZE, next_index);
                store_i32(resolved_ptr + node * WORD_SIZE, 1);
                next_index = next_index + 1;
                assigned = assigned + 1;
                progress = true;
            }
            node = node + 1;
        };
        if !progress {
            return -1;
        }
    };
    idx = 0;
    while idx < array_count {
        let heap_index: i32 = load_i32(indices_ptr + idx * WORD_SIZE);
        if heap_index < 0 {
            return -1;
        }
        ast_array_heap_index_set(ast_base, idx, heap_index);
        idx = idx + 1;
    };
    idx = 0;
    while idx < tuple_count {
        let node: i32 = array_count + idx;
        let heap_index: i32 = load_i32(indices_ptr + node * WORD_SIZE);
        if heap_index < 0 {
            return -1;
        }
        ast_tuple_heap_index_set(ast_base, idx, heap_index);
        idx = idx + 1;
    };
    idx = 0;
    while idx < struct_count {
        let node: i32 = array_count + tuple_count + idx;
        let heap_index: i32 = load_i32(indices_ptr + node * WORD_SIZE);
        if heap_index < 0 {
            return -1;
        }
        ast_struct_heap_index_set(ast_base, idx, heap_index);
        idx = idx + 1;
    };
    0
}

fn ast_register_array_type(ast_base: i32, element_type_id: i32, length: i32) -> i32 {
    if length < 0 {
        return -1;
    }
    let count_ptr: i32 = ast_array_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    while idx < count {
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, idx);
        let existing_element: i32 = load_i32(entry_ptr);
        let existing_length: i32 = load_i32(entry_ptr + 4);
        if existing_element == element_type_id && existing_length == length {
            return array_type_id(idx);
        }
        idx = idx + 1;
    };
    if count >= AST_ARRAY_TYPES_CAPACITY {
        return -1;
    }
    let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, count);
    store_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET, element_type_id);
    store_i32(entry_ptr + AST_ARRAY_TYPE_LENGTH_OFFSET, length);
    store_i32(entry_ptr + AST_ARRAY_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    array_type_id(count)
}

fn ast_register_tuple_type(ast_base: i32, elements_ptr: i32, element_count: i32) -> i32 {
    if element_count < 0 {
        return -1;
    }
    if element_count > 0 && elements_ptr < 0 {
        return -1;
    }
    let count_ptr: i32 = ast_tuple_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    while idx < count {
        let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, idx);
        let existing_count: i32 =
            load_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET);
        if existing_count != element_count {
            idx = idx + 1;
            continue;
        }
        if element_count == 0 {
            return tuple_type_id(idx);
        }
        let existing_ptr: i32 =
            load_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET);
        if existing_ptr < 0 {
            return -1;
        }
        let mut match_idx: i32 = 0;
        let mut matches: bool = true;
        while match_idx < element_count {
            let existing_type: i32 =
                load_i32(existing_ptr + match_idx * WORD_SIZE);
            let new_type: i32 =
                load_i32(elements_ptr + match_idx * WORD_SIZE);
            if existing_type != new_type {
                matches = false;
                break;
            }
            match_idx = match_idx + 1;
        };
        if matches {
            return tuple_type_id(idx);
        }
        idx = idx + 1;
    };
    if count >= AST_TUPLE_TYPES_CAPACITY {
        return -1;
    }
    let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, count);
    let stored_ptr: i32 = if element_count == 0 { 0 } else { elements_ptr };
    store_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET, element_count);
    store_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET, stored_ptr);
    store_i32(entry_ptr + AST_TUPLE_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    tuple_type_id(count)
}

fn ast_register_struct_type(
    ast_base: i32,
    name_length: i32,
    field_count: i32,
    field_stride: i32,
    fields_ptr: i32,
) -> i32 {
    if name_length < 0 {
        return -1;
    }
    if field_count < 0 {
        return -1;
    }
    if field_stride < STRUCT_FIELD_METADATA_HEADER_WORDS {
        return -1;
    }
    if field_stride - STRUCT_FIELD_METADATA_HEADER_WORDS < name_length {
        return -1;
    }
    if field_count > 0 {
        if fields_ptr <= 0 {
            return -1;
        }
    }
    let count_ptr: i32 = ast_struct_types_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    let mut idx: i32 = 0;
    while idx < count {
        let entry_ptr: i32 = ast_struct_type_entry_ptr(ast_base, idx);
        let existing_count: i32 =
            load_i32(entry_ptr + AST_STRUCT_TYPE_FIELD_COUNT_OFFSET);
        if existing_count != field_count {
            idx = idx + 1;
            continue;
        }
        let existing_name_len: i32 =
            load_i32(entry_ptr + AST_STRUCT_TYPE_NAME_LEN_OFFSET);
        if existing_name_len != name_length {
            idx = idx + 1;
            continue;
        }
        let existing_stride: i32 =
            load_i32(entry_ptr + AST_STRUCT_TYPE_FIELD_STRIDE_OFFSET);
        if existing_stride != field_stride {
            idx = idx + 1;
            continue;
        }
        if field_count == 0 {
            return struct_type_id(idx);
        }
        let existing_fields_ptr: i32 =
            load_i32(entry_ptr + AST_STRUCT_TYPE_FIELDS_PTR_OFFSET);
        if existing_fields_ptr < 0 {
            return -1;
        }
        let mut field_idx: i32 = 0;
        let mut matches: bool = true;
        while field_idx < field_count {
            let existing_record_ptr: i32 = existing_fields_ptr
                + field_idx * existing_stride * WORD_SIZE;
            let new_record_ptr: i32 = fields_ptr
                + field_idx * field_stride * WORD_SIZE;
            let existing_type: i32 = load_i32(
                existing_record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE,
            );
            let new_type: i32 = load_i32(
                new_record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE,
            );
            if existing_type != new_type {
                matches = false;
                break;
            }
            let mut byte_idx: i32 = 0;
            while byte_idx < name_length {
                let existing_byte: i32 = load_i32(
                    existing_record_ptr
                        + (STRUCT_FIELD_METADATA_HEADER_WORDS + byte_idx)
                            * WORD_SIZE,
                );
                let new_byte: i32 = load_i32(
                    new_record_ptr
                        + (STRUCT_FIELD_METADATA_HEADER_WORDS + byte_idx)
                            * WORD_SIZE,
                );
                if existing_byte != new_byte {
                    matches = false;
                    break;
                }
                byte_idx = byte_idx + 1;
            };
            if !matches {
                break;
            }
            field_idx = field_idx + 1;
        };
        if matches {
            return struct_type_id(idx);
        }
        idx = idx + 1;
    };
    if count >= AST_STRUCT_TYPES_CAPACITY {
        return -1;
    }
    let entry_ptr: i32 = ast_struct_type_entry_ptr(ast_base, count);
    let stored_ptr: i32 = if field_count == 0 { 0 } else { fields_ptr };
    store_i32(entry_ptr + AST_STRUCT_TYPE_FIELD_COUNT_OFFSET, field_count);
    store_i32(entry_ptr + AST_STRUCT_TYPE_NAME_LEN_OFFSET, name_length);
    store_i32(entry_ptr + AST_STRUCT_TYPE_FIELD_STRIDE_OFFSET, field_stride);
    store_i32(entry_ptr + AST_STRUCT_TYPE_FIELDS_PTR_OFFSET, stored_ptr);
    store_i32(entry_ptr + AST_STRUCT_TYPE_CACHE_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    struct_type_id(count)
}

fn ensure_array_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    }
    let cached: i32 = array_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    }
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_array_type_payload_ptr(ast_base, index),
    );
    array_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if index + 1 > current_count {
        scratch_types_set_count(out_ptr, index + 1);
    }
    0
}

fn ensure_tuple_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    let metadata_index: i32 = tuple_type_metadata_index(index);
    if metadata_index < 0 {
        return -1;
    }
    if metadata_index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    }
    let cached: i32 = tuple_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    }
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, metadata_index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_tuple_type_entry_ptr(ast_base, index),
    );
    tuple_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if metadata_index + 1 > current_count {
        scratch_types_set_count(out_ptr, metadata_index + 1);
    }
    0
}

fn ensure_struct_type_metadata(out_ptr: i32, ast_base: i32, index: i32, type_id: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    let metadata_index: i32 = struct_type_metadata_index(index);
    if metadata_index < 0 {
        return -1;
    }
    if metadata_index >= SCRATCH_TYPES_CAPACITY {
        return -1;
    }
    let cached: i32 = struct_type_cached_id(ast_base, index);
    if cached == type_id {
        return 0;
    }
    let scratch_entry_ptr: i32 = scratch_type_entry_ptr(out_ptr, metadata_index);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_TYPE_ID_OFFSET, type_id);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_PTR_OFFSET, 0);
    store_i32(scratch_entry_ptr + TYPE_ENTRY_NAME_LEN_OFFSET, 0);
    store_i32(
        scratch_entry_ptr + TYPE_ENTRY_EXTRA_OFFSET,
        ast_struct_type_entry_ptr(ast_base, index),
    );
    struct_type_set_cached_id(ast_base, index, type_id);
    let current_count: i32 = scratch_types_count(out_ptr);
    if metadata_index + 1 > current_count {
        scratch_types_set_count(out_ptr, metadata_index + 1);
    }
    0
}

fn type_id_contains_only_type_values(ast_base: i32, type_id: i32) -> bool {
    if type_id < 0 {
        return false;
    }
    if type_id == BUILTIN_TYPE_ID_TYPE {
        return true;
    }
    if type_id_is_array(type_id) {
        let element_type: i32 = array_type_element_type(ast_base, type_id);
        if element_type < 0 {
            return false;
        }
        return type_id_contains_only_type_values(ast_base, element_type);
    }
    if type_id_is_tuple(type_id) {
        let tuple_idx: i32 = tuple_type_index(type_id);
        if tuple_idx < 0 {
            return false;
        }
        if ensure_tuple_type_metadata(0, ast_base, tuple_idx, type_id) < 0 {
            return false;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count < 0 {
            return false;
        }
        if element_count == 0 {
            return true;
        }
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return false;
        }
        let mut idx: i32 = 0;
        while idx < element_count {
            let field_type: i32 = load_i32(elements_ptr + idx * WORD_SIZE);
            if !type_id_contains_only_type_values(ast_base, field_type) {
                return false;
            }
            idx = idx + 1;
        };
        return true;
    }
    false
}

fn materialize_type_like_value_into(
    ast_base: i32,
    recorded_type_id: i32,
    target_type: i32,
    value_ptr: i32,
    type_ptr: i32,
) -> i32 {
    if target_type == BUILTIN_TYPE_ID_TYPE {
        if recorded_type_id < 0 {
            return -1;
        }
        store_i32(value_ptr, recorded_type_id);
        if type_ptr > 0 {
            store_i32(type_ptr, BUILTIN_TYPE_ID_TYPE);
        }
        return BUILTIN_TYPE_ID_TYPE;
    }
    if type_id_is_tuple(target_type) {
        if !type_id_is_tuple(recorded_type_id) {
            return -1;
        }
        let target_idx: i32 = tuple_type_index(target_type);
        if target_idx < 0 {
            return -1;
        }
        if ensure_tuple_type_metadata(0, ast_base, target_idx, target_type) < 0 {
            return -1;
        }
        let recorded_idx: i32 = tuple_type_index(recorded_type_id);
        if recorded_idx < 0 {
            return -1;
        }
        if ensure_tuple_type_metadata(0, ast_base, recorded_idx, recorded_type_id) < 0 {
            return -1;
        }
        let target_count: i32 = ast_tuple_type_element_count(ast_base, target_idx);
        if target_count < 0 {
            return -1;
        }
        let recorded_count: i32 = ast_tuple_type_element_count(ast_base, recorded_idx);
        if recorded_count != target_count {
            return -1;
        }
        let pair_words: i32 = if target_count > 0 { target_count * 2 } else { 0 };
        let pair_storage_ptr: i32 = if pair_words > 0 {
            ast_call_data_alloc(ast_base, pair_words)
        } else {
            0
        };
        if pair_words > 0 && pair_storage_ptr < 0 {
            return -1;
        }
        let target_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, target_idx);
        let recorded_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, recorded_idx);
        if target_elements_ptr < 0 || recorded_elements_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < target_count {
            let target_field_type: i32 = load_i32(target_elements_ptr + idx * WORD_SIZE);
            let recorded_field_type: i32 = load_i32(recorded_elements_ptr + idx * WORD_SIZE);
            let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
            if materialize_type_like_value_into(
                ast_base,
                recorded_field_type,
                target_field_type,
                slot_ptr,
                slot_ptr + WORD_SIZE,
            ) < 0 {
                return -1;
            }
            idx = idx + 1;
        };
        if pair_words == 0 {
            store_i32(value_ptr, 0);
        } else {
            store_i32(value_ptr, pair_storage_ptr);
        }
        if type_ptr > 0 {
            store_i32(type_ptr, target_type);
        }
        return target_type;
    }
    if type_id_is_array(target_type) {
        if !type_id_is_array(recorded_type_id) {
            return -1;
        }
        let target_length: i32 = array_type_length(ast_base, target_type);
        let recorded_length: i32 = array_type_length(ast_base, recorded_type_id);
        if target_length != recorded_length {
            return -1;
        }
        let target_element_type: i32 = array_type_element_type(ast_base, target_type);
        let recorded_element_type: i32 = array_type_element_type(ast_base, recorded_type_id);
        if target_element_type < 0 || recorded_element_type < 0 {
            return -1;
        }
        let pair_words: i32 = if target_length > 0 { target_length * 2 } else { 0 };
        let pair_storage_ptr: i32 = if pair_words > 0 {
            ast_call_data_alloc(ast_base, pair_words)
        } else {
            0
        };
        if pair_words > 0 && pair_storage_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < target_length {
            let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
            if materialize_type_like_value_into(
                ast_base,
                recorded_element_type,
                target_element_type,
                slot_ptr,
                slot_ptr + WORD_SIZE,
            ) < 0 {
                return -1;
            }
            idx = idx + 1;
        };
        if pair_words == 0 {
            store_i32(value_ptr, 0);
        } else {
            store_i32(value_ptr, pair_storage_ptr);
        }
        if type_ptr > 0 {
            store_i32(type_ptr, target_type);
        }
        return target_type;
    }
    -1
}

fn resolve_array_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1000);
    store_i32(TYPE_METADATA_DEBUG_LAST_SUBJECT_OFFSET, type_id);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, 0);
    if !type_id_is_array(type_id) {
        record_type_metadata_debug(out_ptr, 1, type_id, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let index: i32 = array_type_index(type_id);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1001);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, index);
    if index < 0 {
        record_type_metadata_debug(out_ptr, 2, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let type_count: i32 = ast_array_types_count(ast_base);
    if index >= type_count {
        record_type_metadata_debug(out_ptr, 3, type_id, type_count);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let cached: i32 = array_type_cached_id(ast_base, index);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1002);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, cached);
    if cached == type_id {
        return type_id;
    }
    if cached == TYPE_METADATA_CACHE_IN_PROGRESS {
        record_type_metadata_debug(out_ptr, 4, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    array_type_set_cached_id(ast_base, index, TYPE_METADATA_CACHE_IN_PROGRESS);
    let mut element_type_id: i32 = ast_array_type_element_type(ast_base, index);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1003);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, element_type_id);
    let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type_id);
    if resolved_element < 0 {
        array_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_debug(out_ptr, 5, type_id, element_type_id);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if resolved_element != element_type_id {
        let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, index);
        store_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET, resolved_element);
        element_type_id = resolved_element;
    }
    let length: i32 = ast_array_type_length(ast_base, index);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1004);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, length);
    if length < 0 {
        array_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_debug(out_ptr, 6, type_id, length);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if ensure_array_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        array_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_debug(out_ptr, 7, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 1005);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, type_id);
    type_id
}

fn resolve_tuple_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2000);
    store_i32(TYPE_METADATA_DEBUG_LAST_SUBJECT_OFFSET, type_id);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, 0);
    if !type_id_is_tuple(type_id) {
        record_type_metadata_debug(out_ptr, 10, type_id, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let index: i32 = tuple_type_index(type_id);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2001);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, index);
    if index < 0 {
        record_type_metadata_debug(out_ptr, 11, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let tuple_count: i32 = ast_tuple_types_count(ast_base);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2002);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, tuple_count);
    if index >= tuple_count {
        record_type_metadata_debug(out_ptr, 12, type_id, tuple_count);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let cached: i32 = tuple_type_cached_id(ast_base, index);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2003);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, cached);
    if cached == type_id {
        return type_id;
    }
    if cached == TYPE_METADATA_CACHE_IN_PROGRESS {
        record_type_metadata_debug(out_ptr, 13, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    tuple_type_set_cached_id(ast_base, index, TYPE_METADATA_CACHE_IN_PROGRESS);
    let element_count: i32 = ast_tuple_type_element_count(ast_base, index);
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2004);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, element_count);
    if element_count < 0 {
        tuple_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_debug(out_ptr, 14, type_id, element_count);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if element_count > 0 {
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, index);
        store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2005);
        store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, elements_ptr);
        if elements_ptr < 0 {
            tuple_type_set_cached_id(ast_base, index, 0);
            record_type_metadata_debug(out_ptr, 15, type_id, index);
            record_type_metadata_failure(out_ptr);
            return -1;
        }
        let mut elem_idx: i32 = 0;
        while elem_idx < element_count {
            let type_ptr: i32 = elements_ptr + elem_idx * WORD_SIZE;
            let element_type_id: i32 = load_i32(type_ptr);
            store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2006);
            store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, element_type_id);
            let resolved_element: i32 =
                resolve_type_id(out_ptr, ast_base, element_type_id);
            if resolved_element < 0 {
                tuple_type_set_cached_id(ast_base, index, 0);
                record_type_metadata_debug(out_ptr, 16, type_id, element_type_id);
                record_type_metadata_failure(out_ptr);
                return -1;
            }
            if resolved_element != element_type_id {
                store_i32(type_ptr, resolved_element);
            }
            elem_idx = elem_idx + 1;
        };
    }
    if ensure_tuple_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        tuple_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_debug(out_ptr, 17, type_id, index);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    store_i32(TYPE_METADATA_DEBUG_LAST_CONTEXT_OFFSET, 2007);
    store_i32(TYPE_METADATA_DEBUG_LAST_EXTRA_OFFSET, type_id);
    type_id
}

fn resolve_struct_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if !type_id_is_struct(type_id) {
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let index: i32 = struct_type_index(type_id);
    if index < 0 {
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if index >= ast_struct_types_count(ast_base) {
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    let cached: i32 = struct_type_cached_id(ast_base, index);
    if cached == type_id {
        return type_id;
    }
    if cached == TYPE_METADATA_CACHE_IN_PROGRESS {
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    struct_type_set_cached_id(ast_base, index, TYPE_METADATA_CACHE_IN_PROGRESS);
    let field_count: i32 = ast_struct_type_field_count(ast_base, index);
    if field_count < 0 {
        struct_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    if field_count > 0 {
        let fields_ptr: i32 = ast_struct_type_fields_ptr(ast_base, index);
        if fields_ptr < 0 {
            struct_type_set_cached_id(ast_base, index, 0);
            record_type_metadata_failure(out_ptr);
            return -1;
        }
        let stride: i32 = ast_struct_type_field_stride(ast_base, index);
        if stride <= 0 {
            struct_type_set_cached_id(ast_base, index, 0);
            record_type_metadata_failure(out_ptr);
            return -1;
        }
        let mut field_idx: i32 = 0;
        while field_idx < field_count {
            let record_ptr: i32 = fields_ptr + field_idx * stride * WORD_SIZE;
            let field_type_id: i32 = load_i32(record_ptr);
            if field_type_id < 0 {
                struct_type_set_cached_id(ast_base, index, 0);
                record_type_metadata_failure(out_ptr);
                return -1;
            }
            let resolved_field: i32 = resolve_type_id(out_ptr, ast_base, field_type_id);
            if resolved_field < 0 {
                struct_type_set_cached_id(ast_base, index, 0);
                record_type_metadata_failure(out_ptr);
                return -1;
            }
            if resolved_field != field_type_id {
                store_i32(record_ptr, resolved_field);
            }
            field_idx = field_idx + 1;
        };
    }
    if ensure_struct_type_metadata(out_ptr, ast_base, index, type_id) < 0 {
        struct_type_set_cached_id(ast_base, index, 0);
        record_type_metadata_failure(out_ptr);
        return -1;
    }
    struct_type_set_cached_id(ast_base, index, type_id);
    type_id
}

fn resolve_type_id(out_ptr: i32, ast_base: i32, type_id: i32) -> i32 {
    if type_id < 0 {
        return -1;
    }
    if type_id_is_array(type_id) {
        return resolve_array_type_id(out_ptr, ast_base, type_id);
    }
    if type_id_is_tuple(type_id) {
        return resolve_tuple_type_id(out_ptr, ast_base, type_id);
    }
    if type_id_is_struct(type_id) {
        return resolve_struct_type_id(out_ptr, ast_base, type_id);
    }
    if type_id_is_builtin(type_id) {
        return type_id;
    }
    record_type_metadata_debug(out_ptr, 100, type_id, 0);
    record_type_metadata_failure(out_ptr);
    -1
}

fn ast_extra_base(ast_base: i32) -> i32 {
    ast_struct_heap_indices_base(ast_base) + AST_STRUCT_HEAP_INDEX_SECTION_SIZE
}

const AST_EXPR_ENTRY_SIZE: i32 = 20;

const AST_EXPR_ENTRY_EXTRA_OFFSET: i32 = 16;

const AST_EXPR_CAPACITY: i32 = 131072;

fn ast_expr_count_ptr(ast_base: i32) -> i32 {
    ast_extra_base(ast_base)
}

fn ast_expr_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_extra_base(ast_base) + WORD_SIZE + index * AST_EXPR_ENTRY_SIZE
}

fn ast_expr_entry_extra_ptr(ast_base: i32, index: i32) -> i32 {
    ast_expr_entry_ptr(ast_base, index) + AST_EXPR_ENTRY_EXTRA_OFFSET
}

fn ast_expr_entry_extra(ast_base: i32, index: i32) -> i32 {
    load_i32(ast_expr_entry_extra_ptr(ast_base, index))
}

fn ast_expr_entry_set_extra(ast_base: i32, index: i32, value: i32) {
    store_i32(ast_expr_entry_extra_ptr(ast_base, index), value);
}

fn ast_expr_types_base(ast_base: i32) -> i32 {
    // Reserve space for WORD_SIZE + AST_EXPR_CAPACITY * AST_EXPR_ENTRY_SIZE
    // expression entries before the type metadata section.
    ast_extra_base(ast_base) + WORD_SIZE + AST_EXPR_CAPACITY * AST_EXPR_ENTRY_SIZE
}

fn ast_expr_type_entry_ptr(ast_base: i32, index: i32) -> i32 {
    ast_expr_types_base(ast_base) + index * WORD_SIZE
}

fn ast_expr_set_type(ast_base: i32, index: i32, type_id: i32) {
    store_i32(ast_expr_type_entry_ptr(ast_base, index), type_id);
}

fn ast_expr_type(ast_base: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if index >= ast_expr_count(ast_base) {
        return -1;
    }
    load_i32(ast_expr_type_entry_ptr(ast_base, index))
}

fn ast_temp_base(ast_base: i32) -> i32 {
    // Reserve AST_EXPR_CAPACITY words (524288 bytes) for expression type IDs
    // before the temporary workspace.
    ast_expr_types_base(ast_base) + 524288
}

fn ast_expr_reset(ast_base: i32) {
    store_i32(ast_expr_count_ptr(ast_base), 0);
}

fn ast_expr_count(ast_base: i32) -> i32 {
    load_i32(ast_expr_count_ptr(ast_base))
}

fn ast_expr_alloc(ast_base: i32, kind: i32, data0: i32, data1: i32, data2: i32) -> i32 {
    let count_ptr: i32 = ast_expr_count_ptr(ast_base);
    let count: i32 = load_i32(count_ptr);
    if count >= AST_EXPR_CAPACITY {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, count);
    store_i32(entry_ptr, kind);
    store_i32(entry_ptr + 4, data0);
    store_i32(entry_ptr + 8, data1);
    store_i32(entry_ptr + 12, data2);
    store_i32(entry_ptr + AST_EXPR_ENTRY_EXTRA_OFFSET, 0);
    store_i32(count_ptr, count + 1);
    ast_expr_set_type(ast_base, count, -1);
    count
}

fn ast_expr_alloc_literal(ast_base: i32, value: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 0, value, 0, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_call(ast_base: i32, metadata_ptr: i32, location_offset: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 1, metadata_ptr, 0, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_call_metadata(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + WORD_SIZE)
}

fn ast_expr_alloc_add(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 2, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_sub(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 3, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_mul(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 4, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_div(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 5, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_rem(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 46, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_or(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 25, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_bitwise_and(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 26, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_inline_wasm(ast_base: i32, bytes_ptr: i32, byte_count: i32) -> i32 {
    if byte_count < 0 {
        return -1;
    }
    if byte_count > 0 && bytes_ptr < 0 {
        return -1;
    }
    let index: i32 = ast_expr_alloc(ast_base, 42, bytes_ptr, byte_count, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_array_repeat(
    ast_base: i32,
    element_index: i32,
    length: i32,
    length_expr_metadata_ptr: i32,
    location_offset: i32,
) -> i32 {
    if length < 0 {
        if length_expr_metadata_ptr < 0 {
            return -1;
        }
    }
    let index: i32 =
        ast_expr_alloc(ast_base, 35, element_index, length, length_expr_metadata_ptr);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    ast_expr_entry_set_extra(ast_base, index, location_offset);
    index
}

fn ast_expr_array_repeat_length(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 2 * WORD_SIZE)
}

fn ast_expr_array_repeat_length_metadata(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_array_repeat_length_expr(ast_base: i32, expr_index: i32) -> i32 {
    let metadata_ptr: i32 = ast_expr_array_repeat_length_metadata(ast_base, expr_index);
    if metadata_ptr <= 0 {
        return -1;
    }
    load_i32(metadata_ptr)
}

fn ast_expr_alloc_array_list(
    ast_base: i32,
    values_ptr: i32,
    count: i32,
    location_offset: i32,
) -> i32 {
    if count <= 0 {
        return -1;
    }
    if values_ptr < 0 {
        return -1;
    }
    let index: i32 = ast_expr_alloc(ast_base, 37, values_ptr, count, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    ast_expr_entry_set_extra(ast_base, index, location_offset);
    index
}

fn ast_expr_array_list_values_ptr(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + WORD_SIZE)
}

fn ast_expr_array_repeat_location(ast_base: i32, expr_index: i32) -> i32 {
    ast_expr_entry_extra(ast_base, expr_index)
}

fn ast_expr_array_list_location(ast_base: i32, expr_index: i32) -> i32 {
    ast_expr_entry_extra(ast_base, expr_index)
}

fn ast_expr_location(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_alloc_array_get(
    ast_base: i32,
    array_index: i32,
    index_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 =
        ast_expr_alloc(ast_base, 36, array_index, index_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_array_get_location(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_alloc_tuple_get(
    ast_base: i32,
    tuple_index: i32,
    field_index: i32,
    location_offset: i32,
) -> i32 {
    if field_index < 0 {
        return -1;
    }
    let index: i32 = ast_expr_alloc(ast_base, 41, tuple_index, field_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_struct_get(
    ast_base: i32,
    struct_index: i32,
    label_metadata_ptr: i32,
    location_offset: i32,
) -> i32 {
    if struct_index < 0 {
        return -1;
    }
    if label_metadata_ptr <= 0 {
        return -1;
    }
    let index: i32 = ast_expr_alloc(ast_base, 48, struct_index, label_metadata_ptr, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_const_ref(
    ast_base: i32,
    source_base: i32,
    name_start: i32,
    name_len: i32,
) -> i32 {
    ast_expr_alloc(ast_base, 43, name_start, name_len, source_base)
}

fn ast_expr_alloc_array_len(ast_base: i32, array_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 38, array_index, 0, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_I32);
    index
}

fn ast_expr_alloc_tuple(ast_base: i32, values_ptr: i32, count: i32) -> i32 {
    if count < 0 {
        return -1;
    }
    if count > 0 && values_ptr < 0 {
        return -1;
    }
    let index: i32 = ast_expr_alloc(ast_base, 40, values_ptr, count, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_struct_literal(
    ast_base: i32,
    type_expr_index: i32,
    metadata_ptr: i32,
    field_count: i32,
    location_offset: i32,
) -> i32 {
    if type_expr_index < 0 {
        return -1;
    }
    if field_count < 0 {
        return -1;
    }
    if field_count > 0 {
        if metadata_ptr <= 0 {
            return -1;
        }
    }
    let index: i32 = ast_expr_alloc(ast_base, 47, type_expr_index, metadata_ptr, field_count);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    ast_expr_entry_set_extra(ast_base, index, location_offset);
    index
}

fn ast_expr_struct_literal_type_expr(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + WORD_SIZE)
}

fn ast_expr_struct_literal_metadata(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 2 * WORD_SIZE)
}

fn ast_expr_struct_literal_field_count(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_struct_literal_location(ast_base: i32, expr_index: i32) -> i32 {
    ast_expr_entry_extra(ast_base, expr_index)
}

fn ast_expr_struct_get_base(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + WORD_SIZE)
}

fn ast_expr_struct_get_metadata(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 2 * WORD_SIZE)
}

fn ast_expr_struct_get_location(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_alloc_cast(ast_base: i32, value_index: i32, target_type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 39, value_index, target_type_id, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, target_type_id);
    index
}

fn ast_expr_alloc_shl(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 27, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_shr_s(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 28, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, left_index));
    index
}

fn ast_expr_alloc_eq(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 14, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ne(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 15, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_lt(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 16, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_gt(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 17, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_le(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 18, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_ge(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 19, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_or(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 20, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_and(
    ast_base: i32,
    left_index: i32,
    right_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 21, left_index, right_index, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_logical_not(
    ast_base: i32,
    value_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 22, value_index, 0, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, BUILTIN_TYPE_ID_BOOL);
    index
}

fn ast_expr_alloc_param(ast_base: i32, param_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 6, param_index, 0, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_if(
    ast_base: i32,
    condition_index: i32,
    then_index: i32,
    else_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 7, condition_index, then_index, else_index);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_local(ast_base: i32, local_index: i32, type_id: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 8, local_index, 0, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, type_id);
    index
}

fn ast_expr_alloc_let(
    ast_base: i32,
    local_index: i32,
    init_index: i32,
    body_index: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 9, local_index, init_index, body_index);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_set_local(ast_base: i32, local_index: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 10, local_index, value_index, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn ast_expr_alloc_array_set(
    ast_base: i32,
    array_index: i32,
    element_index: i32,
    value_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 44, array_index, element_index, value_index);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    ast_expr_entry_set_extra(ast_base, index, location_offset);
    index
}

fn ast_expr_array_set_location(ast_base: i32, expr_index: i32) -> i32 {
    ast_expr_entry_extra(ast_base, expr_index)
}

fn ast_expr_alloc_tuple_set(
    ast_base: i32,
    tuple_index: i32,
    field_index: i32,
    value_index: i32,
    location_offset: i32,
) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 45, tuple_index, field_index, value_index);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    ast_expr_entry_set_extra(ast_base, index, location_offset);
    index
}

fn ast_expr_tuple_set_location(ast_base: i32, expr_index: i32) -> i32 {
    ast_expr_entry_extra(ast_base, expr_index)
}

fn ast_expr_alloc_sequence(ast_base: i32, first_index: i32, then_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 11, first_index, then_index, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, then_index));
    index
}

fn ast_expr_alloc_loop(ast_base: i32, body_index: i32, flags: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 12, body_index, flags, 0);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, body_index));
    index
}

fn ast_expr_alloc_break(ast_base: i32, location_offset: i32, value_index: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 13, -1, value_index, location_offset);
    if index < 0 {
        return -1;
    }
    let value_type: i32 = if value_index >= 0 {
        ast_expr_type(ast_base, value_index)
    } else {
        -1
    };
    ast_expr_set_type(ast_base, index, value_type);
    index
}

fn ast_expr_break_location(ast_base: i32, expr_index: i32) -> i32 {
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    load_i32(entry_ptr + 3 * WORD_SIZE)
}

fn ast_expr_alloc_continue(ast_base: i32, location_offset: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 24, -1, 0, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, -1);
    index
}

fn ast_expr_alloc_return(ast_base: i32, value_index: i32, location_offset: i32) -> i32 {
    let index: i32 = ast_expr_alloc(ast_base, 23, value_index, 0, location_offset);
    if index < 0 {
        return -1;
    }
    ast_expr_set_type(ast_base, index, ast_expr_type(ast_base, value_index));
    index
}

fn expression_node_from_parts(ast_base: i32, kind: i32, data0: i32, data1: i32) -> i32 {
    if kind == 0 {
        return ast_expr_alloc_literal(ast_base, data0, data1);
    }
    if kind == 1 {
        return ast_expr_alloc_call(ast_base, data0, data1);
    }
    if kind == 6 {
        return ast_expr_alloc_param(ast_base, data0, data1);
    }
    if kind == 8 {
        return ast_expr_alloc_local(ast_base, data0, data1);
    }
    data0
}

fn load_expression_parts(kind_ptr: i32, data0_ptr: i32, data1_ptr: i32) -> ExpressionParts {
    ExpressionParts {
        kind: load_i32(kind_ptr),
        data0: load_i32(data0_ptr),
        data1: load_i32(data1_ptr),
    }
}

fn store_expression_parts(
    kind_ptr: i32,
    data0_ptr: i32,
    data1_ptr: i32,
    parts: ExpressionParts,
) {
    store_i32(kind_ptr, parts.kind);
    store_i32(data0_ptr, parts.data0);
    store_i32(data1_ptr, parts.data1);
}

fn expression_index_from_parts(ast_base: i32, parts: ExpressionParts) -> i32 {
    expression_node_from_parts(ast_base, parts.kind, parts.data0, parts.data1)
}

fn record_struct_intrinsic_invalid_props_failure(
    ast_base: i32,
    metadata_ptr: i32,
    props_expr_index: i32,
) {
    let payload_slot_ptr: i32 = call_metadata_template_payload_ptr(metadata_ptr);
    if payload_slot_ptr > 0 {
        let failure_ptr: i32 = ast_call_data_alloc(ast_base, 2);
        if failure_ptr >= 0 {
            let location: i32 = if props_expr_index >= 0 {
                ast_expr_location(ast_base, props_expr_index)
            } else {
                -1
            };
            store_i32(failure_ptr, STRUCT_INTRINSIC_FAILURE_INVALID_PROPS);
            store_i32(failure_ptr + WORD_SIZE, location);
            store_i32(payload_slot_ptr, failure_ptr);
        }
    }
}

fn record_struct_intrinsic_type_mismatch_failure(
    ast_base: i32,
    metadata_ptr: i32,
    props_expr_index: i32,
) {
    let payload_slot_ptr: i32 = call_metadata_template_payload_ptr(metadata_ptr);
    if payload_slot_ptr > 0 {
        let failure_ptr: i32 = ast_call_data_alloc(ast_base, 2);
        if failure_ptr >= 0 {
            let location: i32 = if props_expr_index >= 0 {
                ast_expr_location(ast_base, props_expr_index)
            } else {
                -1
            };
            store_i32(
                failure_ptr,
                STRUCT_INTRINSIC_FAILURE_TEMPLATE_TYPE_MISMATCH,
            );
            store_i32(failure_ptr + WORD_SIZE, location);
            store_i32(payload_slot_ptr, failure_ptr);
        }
    }
}

fn evaluate_struct_intrinsic(
    ast_base: i32,
    metadata_ptr: i32,
    scratch_base: i32,
    scratch_top_ptr: i32,
    saved_top: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
    param_values_ptr: i32,
    param_count: i32,
    env_values_count: i32,
) -> i32 {
    if metadata_ptr <= 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let payload_slot_ptr: i32 = call_metadata_template_payload_ptr(metadata_ptr);
    if payload_slot_ptr > 0 {
        store_i32(payload_slot_ptr, 0);
    }
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    if arg_count != 3 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    if arg_count > 0 && args_base < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }

    let length_expr_index: i32 = load_i32(args_base);
    let length_offset: i32 = load_i32(scratch_top_ptr);
    let length_value_ptr: i32 = scratch_base + length_offset;
    let length_type_ptr: i32 = length_value_ptr + 4;
    store_i32(scratch_top_ptr, length_offset + 8);
    let length_status: i32 = interpret_constant_expression(
        ast_base,
        length_expr_index,
        scratch_base,
        scratch_top_ptr,
        length_value_ptr,
        length_type_ptr,
        param_values_ptr,
        param_count,
        env_values_count,
    );
    if length_status < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if length_status != CONST_EVAL_STATUS_OK {
        store_i32(scratch_top_ptr, saved_top);
        return length_status;
    }
    let length_type: i32 = load_i32(length_type_ptr);
    if !constant_eval_integer_type_supported(length_type) {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let raw_length: i32 = load_i32(length_value_ptr);
    let str_length: i32 = normalize_integer_value(raw_length, length_type);
    if str_length < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if str_length == 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    store_i32(scratch_top_ptr, length_offset);

    let count_expr_index: i32 = load_i32(args_base + WORD_SIZE);
    let count_offset: i32 = load_i32(scratch_top_ptr);
    let count_value_ptr: i32 = scratch_base + count_offset;
    let count_type_ptr: i32 = count_value_ptr + 4;
    store_i32(scratch_top_ptr, count_offset + 8);
    let count_status: i32 = interpret_constant_expression(
        ast_base,
        count_expr_index,
        scratch_base,
        scratch_top_ptr,
        count_value_ptr,
        count_type_ptr,
        param_values_ptr,
        param_count,
        env_values_count,
    );
    if count_status < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if count_status != CONST_EVAL_STATUS_OK {
        store_i32(scratch_top_ptr, saved_top);
        return count_status;
    }
    let count_type: i32 = load_i32(count_type_ptr);
    if !constant_eval_integer_type_supported(count_type) {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let raw_count: i32 = load_i32(count_value_ptr);
    let prop_count: i32 = normalize_integer_value(raw_count, count_type);
    if prop_count < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    store_i32(scratch_top_ptr, count_offset);

    let props_expr_index: i32 = load_i32(args_base + 2 * WORD_SIZE);
    let props_offset: i32 = load_i32(scratch_top_ptr);
    let props_value_ptr: i32 = scratch_base + props_offset;
    let props_type_ptr: i32 = props_value_ptr + 4;
    store_i32(scratch_top_ptr, props_offset + 8);
    let props_status: i32 = interpret_constant_expression(
        ast_base,
        props_expr_index,
        scratch_base,
        scratch_top_ptr,
        props_value_ptr,
        props_type_ptr,
        param_values_ptr,
        param_count,
        env_values_count,
    );
    if props_status < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if props_status != CONST_EVAL_STATUS_OK {
        store_i32(scratch_top_ptr, saved_top);
        return props_status;
    }
    let props_type: i32 = load_i32(props_type_ptr);
    if !type_id_is_array(props_type) {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let props_length: i32 = array_type_length(ast_base, props_type);
    if props_length < 0 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if props_length != prop_count {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let props_data_ptr: i32 = if prop_count > 0 {
        load_i32(props_value_ptr)
    } else {
        0
    };
    if prop_count > 0 {
        if props_data_ptr <= 0 {
            record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
    }
    let props_element_type: i32 = array_type_element_type(ast_base, props_type);
    if props_element_type < 0 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if !type_id_is_tuple(props_element_type) {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let tuple_index: i32 = tuple_type_index(props_element_type);
    if tuple_index < 0 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if tuple_index >= ast_tuple_types_count(ast_base) {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let tuple_element_count: i32 =
        ast_tuple_type_element_count(ast_base, tuple_index);
    if tuple_element_count != 2 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let tuple_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_index);
    if tuple_elements_ptr < 0 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let name_field_type: i32 = load_i32(tuple_elements_ptr);
    let type_field_type: i32 = load_i32(tuple_elements_ptr + WORD_SIZE);
    if type_field_type != BUILTIN_TYPE_ID_TYPE {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if !type_id_is_array(name_field_type) {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let canonical_name_length: i32 =
        array_type_length(ast_base, name_field_type);
    if canonical_name_length < str_length {
        record_struct_intrinsic_type_mismatch_failure(
            ast_base,
            metadata_ptr,
            props_expr_index,
        );
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let name_element_type: i32 = array_type_element_type(ast_base, name_field_type);
    if name_element_type != BUILTIN_TYPE_ID_U8 {
        record_struct_intrinsic_invalid_props_failure(ast_base, metadata_ptr, props_expr_index);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let mut tuple_expr_list_ptr: i32 = 0;
    if props_expr_index >= 0 {
        tuple_expr_list_ptr = ast_expr_array_list_values_ptr(ast_base, props_expr_index);
    }
    store_i32(scratch_top_ptr, props_offset);

    let field_stride_words: i32 = STRUCT_FIELD_METADATA_HEADER_WORDS + str_length;
    if field_stride_words <= 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if prop_count > 0 && prop_count > AST_CALL_DATA_CAPACITY / field_stride_words {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
    let saved_call_data_used: i32 = load_i32(call_data_used_ptr);
    let total_field_words: i32 =
        if prop_count > 0 { field_stride_words * prop_count } else { 0 };
    let fields_ptr: i32 = if total_field_words > 0 {
        ast_call_data_alloc(ast_base, total_field_words)
    } else {
        0
    };
    if total_field_words > 0 && fields_ptr < 0 {
        store_i32(call_data_used_ptr, saved_call_data_used);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let mut prop_idx: i32 = 0;
    while prop_idx < prop_count {
        let array_slot_ptr: i32 = props_data_ptr + prop_idx * 2 * WORD_SIZE;
        let tuple_value_ptr: i32 = load_i32(array_slot_ptr);
        let tuple_value_type: i32 = load_i32(array_slot_ptr + WORD_SIZE);
        if tuple_value_type != props_element_type {
            store_i32(call_data_used_ptr, saved_call_data_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if tuple_value_ptr <= 0 {
            store_i32(call_data_used_ptr, saved_call_data_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let record_ptr: i32 = fields_ptr + prop_idx * field_stride_words * WORD_SIZE;
        store_i32(
            record_ptr + STRUCT_FIELD_OFFSET_WORD_OFFSET * WORD_SIZE,
            -1,
        );
        let name_slot_ptr: i32 = tuple_value_ptr;
        let field_name_ptr: i32 = load_i32(name_slot_ptr);
        let field_name_type: i32 = load_i32(name_slot_ptr + WORD_SIZE);
        if field_name_type != name_field_type {
            store_i32(call_data_used_ptr, saved_call_data_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if str_length > 0 {
            if field_name_ptr <= 0 {
                store_i32(call_data_used_ptr, saved_call_data_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        if canonical_name_length > str_length {
            let mut extra_idx: i32 = str_length;
            while extra_idx < canonical_name_length {
                let char_slot_ptr: i32 = field_name_ptr + extra_idx * 2 * WORD_SIZE;
                let char_value: i32 = load_i32(char_slot_ptr);
                let char_type: i32 = load_i32(char_slot_ptr + WORD_SIZE);
                if !constant_eval_integer_type_supported(char_type) {
                    store_i32(call_data_used_ptr, saved_call_data_used);
                    store_i32(scratch_top_ptr, saved_top);
                    record_struct_intrinsic_type_mismatch_failure(
                        ast_base,
                        metadata_ptr,
                        props_expr_index,
                    );
                    return -1;
                }
                let normalized_char: i32 = normalize_integer_value(char_value, char_type);
                if normalized_char != 0 {
                    store_i32(call_data_used_ptr, saved_call_data_used);
                    store_i32(scratch_top_ptr, saved_top);
                    record_struct_intrinsic_type_mismatch_failure(
                        ast_base,
                        metadata_ptr,
                        props_expr_index,
                    );
                    return -1;
                }
                extra_idx = extra_idx + 1;
            };
        }
        let type_slot_ptr: i32 = tuple_value_ptr + 2 * WORD_SIZE;
        let field_type_id: i32 = load_i32(type_slot_ptr);
        let field_type_type: i32 = load_i32(type_slot_ptr + WORD_SIZE);
        if field_type_type != BUILTIN_TYPE_ID_TYPE {
            store_i32(call_data_used_ptr, saved_call_data_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if field_type_id < 0 {
            store_i32(call_data_used_ptr, saved_call_data_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(
            record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE,
            field_type_id,
        );
        let mut byte_idx: i32 = 0;
        while byte_idx < str_length {
            let char_slot_ptr: i32 = field_name_ptr + byte_idx * 2 * WORD_SIZE;
            let char_value: i32 = load_i32(char_slot_ptr);
            let char_type: i32 = load_i32(char_slot_ptr + WORD_SIZE);
            if !constant_eval_integer_type_supported(char_type) {
                store_i32(call_data_used_ptr, saved_call_data_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let normalized_char: i32 = normalize_integer_value(char_value, char_type);
            if normalized_char < 0 {
                store_i32(call_data_used_ptr, saved_call_data_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if normalized_char > 255 {
                store_i32(call_data_used_ptr, saved_call_data_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            store_i32(
                record_ptr + (STRUCT_FIELD_METADATA_HEADER_WORDS + byte_idx) * WORD_SIZE,
                normalized_char,
            );
            byte_idx = byte_idx + 1;
        };
        let mut prev_idx: i32 = 0;
        while prev_idx < prop_idx {
            let prev_record_ptr: i32 =
                fields_ptr + prev_idx * field_stride_words * WORD_SIZE;
            let mut matches: bool = true;
            let mut scan_idx: i32 = 0;
            while scan_idx < str_length {
                let prev_byte: i32 = load_i32(
                    prev_record_ptr
                        + (STRUCT_FIELD_METADATA_HEADER_WORDS + scan_idx)
                            * WORD_SIZE,
                );
                let current_byte: i32 = load_i32(
                    record_ptr
                        + (STRUCT_FIELD_METADATA_HEADER_WORDS + scan_idx)
                            * WORD_SIZE,
                );
                if prev_byte != current_byte {
                    matches = false;
                    break;
                }
                scan_idx = scan_idx + 1;
            };
            if matches {
                let mut name_location: i32 = -1;
                if tuple_expr_list_ptr > 0 {
                    let tuple_expr_index: i32 =
                        load_i32(tuple_expr_list_ptr + prop_idx * WORD_SIZE);
                    if tuple_expr_index >= 0 {
                        name_location = ast_expr_location(ast_base, tuple_expr_index);
                    }
                }
                store_i32(call_data_used_ptr, saved_call_data_used);
                store_i32(scratch_top_ptr, saved_top);
                if payload_slot_ptr > 0 {
                    let failure_words: i32 = 4;
                    let failure_ptr: i32 = ast_call_data_alloc(ast_base, failure_words);
                    if failure_ptr >= 0 {
                        store_i32(
                            failure_ptr,
                            STRUCT_INTRINSIC_FAILURE_DUPLICATE_FIELD,
                        );
                        store_i32(failure_ptr + WORD_SIZE, name_location);
                        store_i32(failure_ptr + 2 * WORD_SIZE, str_length);
                        store_i32(failure_ptr + 3 * WORD_SIZE, field_name_ptr);
                        store_i32(payload_slot_ptr, failure_ptr);
                    }
                }
                return -1;
            }
            prev_idx = prev_idx + 1;
        };
        prop_idx = prop_idx + 1;
    };
    let before_count: i32 = ast_struct_types_count(ast_base);
    let struct_type_id: i32 = ast_register_struct_type(
        ast_base,
        str_length,
        prop_count,
        field_stride_words,
        fields_ptr,
    );
    if struct_type_id < 0 {
        store_i32(call_data_used_ptr, saved_call_data_used);
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    let after_count: i32 = ast_struct_types_count(ast_base);
    if after_count == before_count {
        store_i32(call_data_used_ptr, saved_call_data_used);
    }
    store_i32(out_value_ptr, struct_type_id);
    store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
    store_i32(scratch_top_ptr, saved_top);
    CONST_EVAL_STATUS_OK
}

fn resolve_constant_reference(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind != 43 {
        return 0;
    }
    let ident_start: i32 = load_i32(entry_ptr + 4);
    let ident_len: i32 = load_i32(entry_ptr + 8);
    let source_base: i32 = load_i32(entry_ptr + 12);
    if ident_len <= 0 {
        return -1;
    }
    let const_index: i32 = find_constant_entry_index(
        source_base,
        ast_base,
        ident_start,
        ident_len,
        true,
    );
    if const_index < 0 {
        return -1;
    }
    let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_index);
    if interpret_constant_entry(ast_base, const_entry_ptr) < 0 {
        return -1;
    }
    let const_value: i32 = ast_constant_entry_value(const_entry_ptr);
    let const_type: i32 = ast_constant_entry_type(const_entry_ptr);
    store_i32(entry_ptr, 0);
    store_i32(entry_ptr + 4, const_value);
    store_i32(entry_ptr + 8, 0);
    store_i32(entry_ptr + 12, 0);
    ast_expr_set_type(ast_base, expr_index, const_type);
    0
}

const CONST_EVAL_STATUS_OK: i32 = 0;
const CONST_EVAL_STATUS_BREAK: i32 = 1;
const CONST_EVAL_STATUS_CONTINUE: i32 = 2;
const CONST_EVAL_STATUS_RETURN: i32 = 3;
const CONST_EVAL_LOOP_LIMIT: i32 = 1048576;

const CONSTANT_EVAL_SCRATCH_OFFSET: i32 = 32768;

