fn write_byte(base: i32, offset: i32, value: i32) -> i32 {
    store_u8(base + offset, value & 255);
    offset + 1
}

fn emit_i32_const(base: i32, offset: i32, value: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, value);
    out
}

fn emit_add(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 106)
}

fn emit_sub(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 107)
}

fn emit_mul(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 108)
}

fn emit_div(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 109)
}

fn emit_end(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 11)
}

fn emit_local_get(base: i32, offset: i32, index: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 32);
    out = write_u32_leb(base, out, index);
    out
}

fn emit_local_set(base: i32, offset: i32, index: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 33);
    out = write_u32_leb(base, out, index);
    out
}

fn word_size() -> i32 {
    4
}

fn scratch_instr_offset() -> i32 {
    4096
}

fn scratch_expr_type_offset() -> i32 {
    4092
}

fn scratch_instr_base_offset() -> i32 {
    8192
}

fn scratch_instr_capacity() -> i32 {
    65536
}

fn scratch_locals_capacity() -> i32 {
    4096
}

fn scratch_locals_metadata_size() -> i32 {
    12
}

fn scratch_functions_count_offset() -> i32 {
    851960
}

fn scratch_functions_base_offset() -> i32 {
    851968
}

fn type_entry_size() -> i32 {
    16
}

fn scratch_types_capacity() -> i32 {
    2048
}

fn scratch_types_base_offset() -> i32 {
    scratch_functions_base_offset() - scratch_types_capacity() * type_entry_size()
}

fn scratch_types_count_offset() -> i32 {
    scratch_types_base_offset() - word_size()
}

fn scratch_instr_offset_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_instr_offset()
}

fn scratch_expr_type_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_expr_type_offset()
}

fn scratch_instr_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_instr_base_offset()
}

fn scratch_locals_max_ptr(instr_base: i32) -> i32 {
    instr_base + scratch_instr_capacity() - scratch_locals_metadata_size()
}

fn scratch_locals_count_ptr(instr_base: i32) -> i32 {
    scratch_locals_max_ptr(instr_base) + word_size()
}

fn scratch_locals_base(instr_base: i32) -> i32 {
    instr_base + scratch_instr_capacity()
}

fn scratch_control_stack_count_ptr(instr_base: i32) -> i32 {
    scratch_locals_base(instr_base) + scratch_locals_capacity()
}

fn scratch_control_stack_base(instr_base: i32) -> i32 {
    scratch_control_stack_count_ptr(instr_base) + word_size()
}

fn scratch_functions_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_functions_count_offset()
}

fn scratch_functions_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_functions_base_offset()
}

fn scratch_types_count_ptr(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_count_offset()
}

fn scratch_types_base(out_ptr: i32) -> i32 {
    out_ptr + scratch_types_base_offset()
}

fn scratch_current_return_type_ptr(out_ptr: i32) -> i32 {
    scratch_functions_base(out_ptr) - word_size()
}

fn emit_call(base: i32, offset: i32, index: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 16);
    out = write_u32_leb(base, out, index);
    out
}

fn emit_return(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 15)
}

fn emit_eq(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 70)
}

fn emit_ne(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 71)
}

fn emit_drop(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 26)
}

fn emit_lt(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 72)
}

fn emit_gt(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 74)
}

fn emit_le(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 76)
}

fn emit_ge(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 78)
}

fn emit_eqz(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 69)
}

fn emit_and(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 113)
}

fn emit_or(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 114)
}

fn emit_shl(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 116)
}

fn emit_shr_s(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 117)
}

fn emit_if(base: i32, offset: i32, block_type: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 4);
    out = write_byte(base, out, block_type);
    out
}

fn emit_else(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 5)
}

fn emit_block(base: i32, offset: i32, block_type: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 2);
    out = write_byte(base, out, block_type);
    out
}

fn emit_loop_header(base: i32, offset: i32, block_type: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 3);
    out = write_byte(base, out, block_type);
    out
}

fn emit_br(base: i32, offset: i32, depth: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 12);
    out = write_u32_leb(base, out, depth);
    out
}

fn emit_load_u8(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 45);
    out = write_u32_leb(base, out, 0);
    out = write_u32_leb(base, out, 0);
    out
}

fn emit_load_u16(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 47);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, 0);
    out
}

fn emit_store_u8(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 58);
    out = write_u32_leb(base, out, 0);
    out = write_u32_leb(base, out, 0);
    out
}

fn emit_store_u16(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 59);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, 0);
    out
}

fn emit_load_i32(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 40);
    out = write_u32_leb(base, out, 2);
    out = write_u32_leb(base, out, 0);
    out
}

fn emit_store_i32(base: i32, offset: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 54);
    out = write_u32_leb(base, out, 2);
    out = write_u32_leb(base, out, 0);
    out
}

fn control_kind_if() -> i32 {
    1
}

fn control_kind_loop_continue() -> i32 {
    2
}

fn control_kind_loop_break() -> i32 {
    3
}

fn control_kind_loop_break_value() -> i32 {
    4
}

fn control_type_none() -> i32 {
    -1
}

fn control_stack_entry_offset(base: i32, index: i32) -> i32 {
    base + index * 8
}

fn control_stack_push(base: i32, len_ptr: i32, kind: i32, value_type: i32) {
    let len: i32 = load_i32(len_ptr);
    let entry: i32 = control_stack_entry_offset(base, len);
    store_i32(entry, kind);
    store_i32(entry + 4, value_type);
    store_i32(len_ptr, len + 1);
}

fn control_stack_pop(base: i32, len_ptr: i32) -> i32 {
    let len: i32 = load_i32(len_ptr);
    if len <= 0 {
        return -1;
    };
    let new_len: i32 = len - 1;
    store_i32(len_ptr, new_len);
    let entry: i32 = control_stack_entry_offset(base, new_len);
    load_i32(entry)
}

fn control_stack_find_depth(base: i32, len_ptr: i32, kind: i32) -> i32 {
    let len: i32 = load_i32(len_ptr);
    if len <= 0 {
        return -1;
    };
    let mut idx: i32 = len - 1;
    loop {
        if idx < 0 {
            break;
        };
        let entry: i32 = control_stack_entry_offset(base, idx);
        let entry_kind: i32 = load_i32(entry);
        if entry_kind == kind {
            return len - 1 - idx;
        };
        idx = idx - 1;
    };
    -1
}

fn control_stack_type_at_depth(base: i32, len_ptr: i32, depth: i32) -> i32 {
    let len: i32 = load_i32(len_ptr);
    if depth < 0 {
        return -1;
    };
    let index: i32 = len - 1 - depth;
    if index < 0 {
        return -1;
    };
    let entry: i32 = control_stack_entry_offset(base, index);
    load_i32(entry + 4)
}

fn control_stack_set_type_at_depth(base: i32, len_ptr: i32, depth: i32, ty: i32) {
    let len: i32 = load_i32(len_ptr);
    if depth < 0 {
        return;
    };
    let index: i32 = len - 1 - depth;
    if index < 0 {
        return;
    };
    let entry: i32 = control_stack_entry_offset(base, index);
    store_i32(entry + 4, ty);
}

fn intrinsic_kind_none() -> i32 {
    -1
}

fn intrinsic_kind_load_u8() -> i32 {
    0
}

fn intrinsic_kind_store_u8() -> i32 {
    1
}

fn intrinsic_kind_load_i32() -> i32 {
    2
}

fn intrinsic_kind_store_i32() -> i32 {
    3
}

fn intrinsic_kind_load_u16() -> i32 {
    4
}

fn intrinsic_kind_store_u16() -> i32 {
    5
}

fn is_identifier_load_u8(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 7 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 108 {
        return false;
    };
    if load_u8(base + start + 1) != 111 {
        return false;
    };
    if load_u8(base + start + 2) != 97 {
        return false;
    };
    if load_u8(base + start + 3) != 100 {
        return false;
    };
    if load_u8(base + start + 4) != 95 {
        return false;
    };
    if load_u8(base + start + 5) != 117 {
        return false;
    };
    if load_u8(base + start + 6) != 56 {
        return false;
    };
    true
}

fn is_identifier_store_u8(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 8 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 115 {
        return false;
    };
    if load_u8(base + start + 1) != 116 {
        return false;
    };
    if load_u8(base + start + 2) != 111 {
        return false;
    };
    if load_u8(base + start + 3) != 114 {
        return false;
    };
    if load_u8(base + start + 4) != 101 {
        return false;
    };
    if load_u8(base + start + 5) != 95 {
        return false;
    };
    if load_u8(base + start + 6) != 117 {
        return false;
    };
    if load_u8(base + start + 7) != 56 {
        return false;
    };
    true
}

fn is_identifier_load_i32(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 8 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 108 {
        return false;
    };
    if load_u8(base + start + 1) != 111 {
        return false;
    };
    if load_u8(base + start + 2) != 97 {
        return false;
    };
    if load_u8(base + start + 3) != 100 {
        return false;
    };
    if load_u8(base + start + 4) != 95 {
        return false;
    };
    if load_u8(base + start + 5) != 105 {
        return false;
    };
    if load_u8(base + start + 6) != 51 {
        return false;
    };
    if load_u8(base + start + 7) != 50 {
        return false;
    };
    true
}

fn is_identifier_load_u16(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 8 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 108 {
        return false;
    };
    if load_u8(base + start + 1) != 111 {
        return false;
    };
    if load_u8(base + start + 2) != 97 {
        return false;
    };
    if load_u8(base + start + 3) != 100 {
        return false;
    };
    if load_u8(base + start + 4) != 95 {
        return false;
    };
    if load_u8(base + start + 5) != 117 {
        return false;
    };
    if load_u8(base + start + 6) != 49 {
        return false;
    };
    if load_u8(base + start + 7) != 54 {
        return false;
    };
    true
}

fn is_identifier_store_i32(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 9 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 115 {
        return false;
    };
    if load_u8(base + start + 1) != 116 {
        return false;
    };
    if load_u8(base + start + 2) != 111 {
        return false;
    };
    if load_u8(base + start + 3) != 114 {
        return false;
    };
    if load_u8(base + start + 4) != 101 {
        return false;
    };
    if load_u8(base + start + 5) != 95 {
        return false;
    };
    if load_u8(base + start + 6) != 105 {
        return false;
    };
    if load_u8(base + start + 7) != 51 {
        return false;
    };
    if load_u8(base + start + 8) != 50 {
        return false;
    };
    true
}

fn is_identifier_store_u16(base: i32, len: i32, start: i32, ident_len: i32) -> bool {
    if ident_len != 9 {
        return false;
    };
    if start < 0 || start + ident_len > len {
        return false;
    };
    if load_u8(base + start) != 115 {
        return false;
    };
    if load_u8(base + start + 1) != 116 {
        return false;
    };
    if load_u8(base + start + 2) != 111 {
        return false;
    };
    if load_u8(base + start + 3) != 114 {
        return false;
    };
    if load_u8(base + start + 4) != 101 {
        return false;
    };
    if load_u8(base + start + 5) != 95 {
        return false;
    };
    if load_u8(base + start + 6) != 117 {
        return false;
    };
    if load_u8(base + start + 7) != 49 {
        return false;
    };
    if load_u8(base + start + 8) != 54 {
        return false;
    };
    true
}

fn identify_intrinsic(base: i32, len: i32, start: i32, ident_len: i32) -> i32 {
    if is_identifier_load_u8(base, len, start, ident_len) {
        return intrinsic_kind_load_u8();
    };
    if is_identifier_store_u8(base, len, start, ident_len) {
        return intrinsic_kind_store_u8();
    };
    if is_identifier_load_i32(base, len, start, ident_len) {
        return intrinsic_kind_load_i32();
    };
    if is_identifier_store_i32(base, len, start, ident_len) {
        return intrinsic_kind_store_i32();
    };
    if is_identifier_load_u16(base, len, start, ident_len) {
        return intrinsic_kind_load_u16();
    };
    if is_identifier_store_u16(base, len, start, ident_len) {
        return intrinsic_kind_store_u16();
    };
    intrinsic_kind_none()
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122) || byte == 95
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || (byte >= 48 && byte <= 57)
}

fn identifiers_equal(
    base: i32,
    len: i32,
    a_start: i32,
    a_len: i32,
    b_start: i32,
    b_len: i32
) -> bool {
    if a_len != b_len {
        return false;
    };
    if a_len < 0 {
        return false;
    };
    if a_start < 0 || b_start < 0 {
        return false;
    };
    if a_start + a_len > len {
        return false;
    };
    if b_start + b_len > len {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= a_len {
            break;
        };
        let a_byte: i32 = load_u8(base + a_start + idx);
        let b_byte: i32 = load_u8(base + b_start + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn locals_find(
    base: i32,
    len: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    name_start: i32,
    name_len: i32
) -> i32 {
    let count: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry: i32 = locals_base + idx * 20;
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if identifiers_equal(
            base,
            len,
            stored_start,
            stored_len,
            name_start,
            name_len
        ) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn locals_find_in_scope(
    base: i32,
    len: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    scope_start: i32,
    name_start: i32,
    name_len: i32
) -> i32 {
    let count: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = scope_start;
    if idx < 0 {
        idx = 0;
    };
    if idx > count {
        idx = count;
    };
    loop {
        if idx >= count {
            break;
        };
        let entry: i32 = locals_base + idx * 20;
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if identifiers_equal(
            base,
            len,
            stored_start,
            stored_len,
            name_start,
            name_len
        ) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn locals_store_entry(
    locals_base: i32,
    locals_count_ptr: i32,
    name_start: i32,
    name_len: i32,
    wasm_index: i32,
    is_mut: bool,
    ty: i32
) {
    let entry_index: i32 = load_i32(locals_count_ptr);
    let entry: i32 = locals_base + entry_index * 20;
    store_i32(entry, name_start);
    store_i32(entry + 4, name_len);
    store_i32(entry + 8, wasm_index);
    let mut mut_flag: i32 = 0;
    if is_mut {
        mut_flag = 1;
    };
    store_i32(entry + 12, mut_flag);
    store_i32(entry + 16, ty);
    let new_count: i32 = entry_index + 1;
    store_i32(locals_count_ptr, new_count);
    let locals_max_ptr: i32 = locals_count_ptr - 4;
    let current_max: i32 = load_i32(locals_max_ptr);
    if new_count > current_max {
        store_i32(locals_max_ptr, new_count);
    };
}

fn locals_is_mutable(locals_base: i32, entry_index: i32) -> bool {
    let entry: i32 = locals_base + entry_index * 20;
    load_i32(entry + 12) != 0
}

fn locals_entry_wasm_index(locals_base: i32, entry_index: i32) -> i32 {
    let entry: i32 = locals_base + entry_index * 20;
    load_i32(entry + 8)
}

fn locals_entry_type(locals_base: i32, entry_index: i32) -> i32 {
    let entry: i32 = locals_base + entry_index * 20;
    load_i32(entry + 16)
}

fn type_code_i32() -> i32 {
    0
}

fn type_code_bool() -> i32 {
    1
}

fn type_code_unit() -> i32 {
    2
}

fn set_expr_type(expr_type_ptr: i32, ty: i32) {
    store_i32(expr_type_ptr, ty);
}

fn get_expr_type(expr_type_ptr: i32) -> i32 {
    load_i32(expr_type_ptr)
}

fn functions_entry(functions_base: i32, index: i32) -> i32 {
    functions_base + index * 32
}

fn types_entry(types_base: i32, index: i32) -> i32 {
    types_base + index * type_entry_size()
}

fn types_find(
    source_base: i32,
    source_len: i32,
    types_base: i32,
    types_count_ptr: i32,
    name_start: i32,
    name_len: i32,
) -> i32 {
    let count: i32 = load_i32(types_count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry: i32 = types_entry(types_base, idx);
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if identifiers_equal(
            source_base,
            source_len,
            stored_start,
            stored_len,
            name_start,
            name_len,
        ) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn functions_find(
    source_base: i32,
    source_len: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    name_start: i32,
    name_len: i32
) -> i32 {
    let count: i32 = load_i32(functions_count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, idx);
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if identifiers_equal(
            source_base,
            source_len,
            stored_start,
            stored_len,
            name_start,
            name_len
        ) {
            return idx;
        };
        idx = idx + 1;
    };
    -1
}

fn write_u32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let mut byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        if remaining != 0 {
            byte = byte | 128;
        };
        out = write_byte(base, out, byte);
        if remaining == 0 {
            break;
        };
    };
    out
}

fn write_i32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        let mut out_byte: i32 = byte;
        if !done {
            out_byte = out_byte | 128;
        };
        out = write_byte(base, out, out_byte);
        if done {
            break;
        };
    };
    out
}

fn leb_u32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        count = count + 1;
        remaining = remaining >> 7;
        if remaining == 0 {
            break;
        };
    };
    count
}

fn leb_i32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        count = count + 1;
        if done {
            break;
        };
    };
    count
}

fn write_magic(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 97);
    out = write_byte(base, out, 115);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out
}

fn is_whitespace(byte: i32) -> bool {
    byte == 32 || byte == 9 || byte == 10 || byte == 13
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if byte == 47 {
            if idx + 1 < len {
                let next: i32 = load_u8(base + idx + 1);
                if next == 47 {
                    idx = idx + 2;
                    loop {
                        if idx >= len {
                            break;
                        };
                        let comment_byte: i32 = load_u8(base + idx);
                        if comment_byte == 10 {
                            idx = idx + 1;
                            break;
                        };
                        idx = idx + 1;
                    };
                    continue;
                };
            };
        };
        if !is_whitespace(byte) {
            break;
        };
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    };
    offset + 1
}

fn keyword_matches(
    base: i32,
    len: i32,
    offset: i32,
    keyword_len: i32,
    keyword0: i32,
    keyword1: i32,
    keyword2: i32,
    keyword3: i32,
    keyword4: i32,
    keyword5: i32,
    keyword6: i32,
    keyword7: i32,
) -> bool {
    if offset < 0 || offset >= len {
        return false;
    };
    if offset + keyword_len > len {
        return false;
    };

    let mut idx: i32 = 0;
    loop {
        if idx >= keyword_len {
            break;
        };

        let expected: i32 = if idx == 0 {
            keyword0
        } else if idx == 1 {
            keyword1
        } else if idx == 2 {
            keyword2
        } else if idx == 3 {
            keyword3
        } else if idx == 4 {
            keyword4
        } else if idx == 5 {
            keyword5
        } else if idx == 6 {
            keyword6
        } else {
            keyword7
        };

        let actual: i32 = peek_byte(base, len, offset + idx);
        if actual != expected {
            return false;
        };

        idx = idx + 1;
    };

    if offset + keyword_len < len {
        let next_byte: i32 = peek_byte(base, len, offset + keyword_len);
        if is_identifier_continue(next_byte) {
            return false;
        };
    };

    true
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 102);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_type(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 116);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 121);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 112);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let next_byte: i32 = peek_byte(base, len, idx);
        if is_identifier_continue(next_byte) {
            return -1;
        };
    };
    idx
}

fn expect_keyword_let(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 108);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 116);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_main(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 109);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 97);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_i32(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 51);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 50);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_loop(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 108);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 111);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 111);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 112);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let next_byte: i32 = peek_byte(base, len, idx);
        if is_identifier_continue(next_byte) {
            return -1;
        };
    };
    idx
}

fn expect_keyword_break(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 98);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 114);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 97);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 107);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let next_byte: i32 = peek_byte(base, len, idx);
        if is_identifier_continue(next_byte) {
            return -1;
        };
    };
    idx
}

fn expect_keyword_continue(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 99);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 111);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 116);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 117);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let next_byte: i32 = peek_byte(base, len, idx);
        if is_identifier_continue(next_byte) {
            return -1;
        };
    };
    idx
}

fn peek_byte(base: i32, len: i32, offset: i32) -> i32 {
    if offset >= len {
        -1
    } else {
        load_u8(base + offset)
    }
}

fn write_type_section(
    base: i32,
    offset: i32,
    functions_base: i32,
    func_count: i32
) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, idx);
        let param_count: i32 = load_i32(entry + 8);
        let return_type: i32 = load_i32(entry + 24);
        payload_size = payload_size + 1;
        payload_size = payload_size + leb_u32_len(param_count);
        payload_size = payload_size + param_count;
        payload_size = payload_size + 1;
        if return_type != type_code_unit() {
            payload_size = payload_size + 1;
        };
        idx = idx + 1;
    };
    let mut out: i32 = offset;
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);
    let mut write_idx: i32 = 0;
    loop {
        if write_idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, write_idx);
        let param_count: i32 = load_i32(entry + 8);
        let return_type: i32 = load_i32(entry + 24);
        let mut wasm_return: i32 = 127;
        if return_type == type_code_i32() {
            wasm_return = 127;
        } else if return_type == type_code_bool() {
            wasm_return = 127;
        };
        out = write_byte(base, out, 96);
        out = write_u32_leb(base, out, param_count);
        let mut param_idx: i32 = 0;
        loop {
            if param_idx >= param_count {
                break;
            };
            out = write_byte(base, out, 127);
            param_idx = param_idx + 1;
        };
        if return_type == type_code_unit() {
            out = write_byte(base, out, 0);
        } else {
            out = write_byte(base, out, 1);
            out = write_byte(base, out, wasm_return);
        };
        write_idx = write_idx + 1;
    };
    out
}

fn write_function_section(base: i32, offset: i32, func_count: i32) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        payload_size = payload_size + leb_u32_len(idx);
        idx = idx + 1;
    };
    let mut out: i32 = offset;
    out = write_byte(base, out, 3);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);
    let mut write_idx: i32 = 0;
    loop {
        if write_idx >= func_count {
            break;
        };
        out = write_u32_leb(base, out, write_idx);
        write_idx = write_idx + 1;
    };
    out
}

fn write_memory_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 5);
    out = write_u32_leb(base, out, 3);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, 0);
    out = write_u32_leb(base, out, 16);
    out
}

fn write_export_section(
    base: i32,
    offset: i32,
    input_base: i32,
    input_len: i32,
    functions_base: i32,
    func_count: i32
) -> i32 {
    let export_count: i32 = func_count + 1;
    let mut payload_size: i32 = leb_u32_len(export_count);
    payload_size = payload_size + leb_u32_len(6) + 6 + 1 + leb_u32_len(0);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, idx);
        let name_len: i32 = load_i32(entry + 4);
        payload_size = payload_size + leb_u32_len(name_len) + name_len + 1 + leb_u32_len(idx);
        idx = idx + 1;
    };
    let mut out: i32 = offset;
    out = write_byte(base, out, 7);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, export_count);
    out = write_u32_leb(base, out, 6);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 101);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 111);
    out = write_byte(base, out, 114);
    out = write_byte(base, out, 121);
    out = write_byte(base, out, 2);
    out = write_u32_leb(base, out, 0);
    let mut write_idx: i32 = 0;
    loop {
        if write_idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, write_idx);
        let name_start: i32 = load_i32(entry);
        let name_len: i32 = load_i32(entry + 4);
        out = write_u32_leb(base, out, name_len);
        let mut char_idx: i32 = 0;
        loop {
            if char_idx >= name_len {
                break;
            };
            let ch: i32 = load_u8(input_base + name_start + char_idx);
            out = write_byte(base, out, ch);
            char_idx = char_idx + 1;
        };
        out = write_byte(base, out, 0);
        out = write_u32_leb(base, out, write_idx);
        write_idx = write_idx + 1;
    };
    out
}

fn write_code_section(
    base: i32,
    offset: i32,
    instr_base: i32,
    functions_base: i32,
    func_count: i32
) -> i32 {
    let mut payload_size: i32 = leb_u32_len(func_count);
    let mut idx: i32 = 0;
    loop {
        if idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, idx);
        let code_len: i32 = load_i32(entry + 16);
        let local_count: i32 = load_i32(entry + 20);
        let local_decl_size: i32 = if local_count == 0 {
            1
        } else {
            let count_len: i32 = leb_u32_len(local_count);
            1 + count_len + 1
        };
        let body_size: i32 = local_decl_size + code_len;
        payload_size = payload_size + leb_u32_len(body_size) + body_size;
        idx = idx + 1;
    };
    let mut out: i32 = offset;
    out = write_byte(base, out, 10);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, func_count);
    let mut write_idx: i32 = 0;
    loop {
        if write_idx >= func_count {
            break;
        };
        let entry: i32 = functions_entry(functions_base, write_idx);
        let code_start: i32 = load_i32(entry + 12);
        let code_len: i32 = load_i32(entry + 16);
        let local_count: i32 = load_i32(entry + 20);
        let local_decl_size: i32 = if local_count == 0 {
            1
        } else {
            let count_len: i32 = leb_u32_len(local_count);
            1 + count_len + 1
        };
        let body_size: i32 = local_decl_size + code_len;
        out = write_u32_leb(base, out, body_size);
        if local_count == 0 {
            out = write_byte(base, out, 0);
        } else {
            out = write_byte(base, out, 1);
            out = write_u32_leb(base, out, local_count);
            out = write_byte(base, out, 127);
        };
        let mut byte_idx: i32 = 0;
        loop {
            if byte_idx >= code_len {
                break;
            };
            let byte: i32 = load_u8(instr_base + code_start + byte_idx);
            out = write_byte(base, out, byte);
            byte_idx = byte_idx + 1;
        };
        write_idx = write_idx + 1;
    };
    out
}

fn write_module(
    base: i32,
    instr_base: i32,
    functions_base: i32,
    func_count: i32,
    input_base: i32,
    input_len: i32
) -> i32 {
    let mut offset: i32 = 0;
    offset = write_magic(base, offset);
    offset = write_type_section(base, offset, functions_base, func_count);
    offset = write_function_section(base, offset, func_count);
    offset = write_memory_section(base, offset);
    offset = write_export_section(base, offset, input_base, input_len, functions_base, func_count);
    write_code_section(base, offset, instr_base, functions_base, func_count)
}

fn parse_expression(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    parse_or(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        )
}

fn parse_or(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_and(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let first: i32 = peek_byte(base, len, idx);
        if first != 124 {
            if first == 41 || first == 59 || first == 125 || first == 123 {
                break;
            };
            return idx;
        };
        if idx + 1 >= len {
            return -1;
        };
        let second: i32 = peek_byte(base, len, idx + 1);
        if second != 124 {
            return -1;
        };
        idx = idx + 2;
        let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
        let mut instr_offset: i32 = saved_instr_offset;
        instr_offset = emit_if(instr_base, instr_offset, 127);
        instr_offset = emit_i32_const(instr_base, instr_offset, 1);
        instr_offset = emit_else(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);
        if current_type != type_code_bool() {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        let next_idx: i32 = parse_and(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        if get_expr_type(expr_type_ptr) != type_code_bool() {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        saw_operator = true;
        idx = next_idx;
        instr_offset = load_i32(instr_offset_ptr);
        instr_offset = emit_end(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);
        current_type = type_code_bool();
        set_expr_type(expr_type_ptr, current_type);
    };

    set_expr_type(expr_type_ptr, current_type);
    idx
}
fn parse_and(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_bitwise_or(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let first: i32 = peek_byte(base, len, idx);
        if first != 38 {
            if first == 41 || first == 59 || first == 125 || first == 123 {
                break;
            };
            return idx;
        };
        if idx + 1 >= len {
            return -1;
        };
        let second: i32 = peek_byte(base, len, idx + 1);
        if second != 38 {
            return -1;
        };
        idx = idx + 2;
        let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
        let mut instr_offset: i32 = saved_instr_offset;
        instr_offset = emit_if(instr_base, instr_offset, 127);
        store_i32(instr_offset_ptr, instr_offset);
        if get_expr_type(expr_type_ptr) != type_code_bool() {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        let next_idx: i32 = parse_bitwise_or(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        if get_expr_type(expr_type_ptr) != type_code_bool() {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        saw_operator = true;
        idx = next_idx;
        instr_offset = load_i32(instr_offset_ptr);
        instr_offset = emit_else(instr_base, instr_offset);
        instr_offset = emit_i32_const(instr_base, instr_offset, 0);
        instr_offset = emit_end(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);
        set_expr_type(expr_type_ptr, type_code_bool());
    };

    if !saw_operator {
        // preserve existing type when no operator encountered
    };

    idx
}

fn parse_bitwise_or(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_bitwise_and(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte != 124 {
            if op_byte == 41 || op_byte == 59 || op_byte == 125 || op_byte == 123 {
                break;
            };
            return idx;
        };
        if idx + 1 < len {
            let next: i32 = peek_byte(base, len, idx + 1);
            if next == 124 {
                break;
            };
        };

        if current_type != type_code_i32() {
            return -1;
        };

        idx = idx + 1;
        let next_idx: i32 = parse_bitwise_and(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            return -1;
        };
        idx = next_idx;

        let right_type: i32 = get_expr_type(expr_type_ptr);
        if right_type != type_code_i32() {
            return -1;
        };

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_or(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);

        current_type = type_code_i32();
        set_expr_type(expr_type_ptr, current_type);
        saw_operator = true;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}

fn parse_bitwise_and(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_equality(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte != 38 {
            if op_byte == 41 || op_byte == 59 || op_byte == 125 || op_byte == 123 {
                break;
            };
            return idx;
        };
        if idx + 1 < len {
            let next: i32 = peek_byte(base, len, idx + 1);
            if next == 38 {
                break;
            };
        };

        if current_type != type_code_i32() {
            return -1;
        };

        idx = idx + 1;
        let next_idx: i32 = parse_equality(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            return -1;
        };
        idx = next_idx;

        let right_type: i32 = get_expr_type(expr_type_ptr);
        if right_type != type_code_i32() {
            return -1;
        };

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_and(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);

        current_type = type_code_i32();
        set_expr_type(expr_type_ptr, current_type);
        saw_operator = true;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}
fn parse_equality(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_comparison(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        if idx + 1 >= len {
            break;
        };
        let first: i32 = peek_byte(base, len, idx);
        let second: i32 = peek_byte(base, len, idx + 1);
        if first == 61 && second == 61 {
            idx = idx + 2;
            let left_type: i32 = current_type;
            let next_idx: i32 = parse_comparison(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr
                );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;
            let right_type: i32 = get_expr_type(expr_type_ptr);
            if left_type != right_type {
                return -1;
            };
            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            instr_offset = emit_eq(instr_base, instr_offset);
            store_i32(instr_offset_ptr, instr_offset);
            current_type = type_code_bool();
            set_expr_type(expr_type_ptr, current_type);
            continue;
        };

        if first == 33 && second == 61 {
            idx = idx + 2;
            let left_type: i32 = current_type;
            let next_idx: i32 = parse_comparison(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr
                );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;
            let right_type: i32 = get_expr_type(expr_type_ptr);
            if left_type != right_type {
                return -1;
            };
            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            instr_offset = emit_ne(instr_base, instr_offset);
            store_i32(instr_offset_ptr, instr_offset);
            current_type = type_code_bool();
            set_expr_type(expr_type_ptr, current_type);
            continue;
        };

        if first == 41 || first == 59 || first == 125 || first == 123 {
            break;
        };

        break;
    };

    if current_type != get_expr_type(expr_type_ptr) {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}
fn parse_comparison(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_shift(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        let mut consumed: i32 = 0;
        let mut instr_kind: i32 = 0;

        if op_byte == 60 {
            if idx + 1 < len {
                let next: i32 = peek_byte(base, len, idx + 1);
                if next == 60 {
                    break;
                };
                if next == 61 {
                    consumed = 2;
                    instr_kind = 2;
                } else {
                    consumed = 1;
                    instr_kind = 0;
                };
            } else {
                consumed = 1;
                instr_kind = 0;
            };
        } else if op_byte == 62 {
            if idx + 1 < len {
                let next: i32 = peek_byte(base, len, idx + 1);
                if next == 62 {
                    break;
                };
                if next == 61 {
                    consumed = 2;
                    instr_kind = 3;
                } else {
                    consumed = 1;
                    instr_kind = 1;
                };
            } else {
                consumed = 1;
                instr_kind = 1;
            };
        } else if op_byte == 41 || op_byte == 59 || op_byte == 125 || op_byte == 123 {
            break;
        } else {
            break;
        };

        if consumed == 0 {
            break;
        };

        if current_type != type_code_i32() {
            return -1;
        };

        idx = idx + consumed;
        let next_idx: i32 = parse_shift(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            return -1;
        };
        idx = next_idx;

        let right_type: i32 = get_expr_type(expr_type_ptr);
        if right_type != type_code_i32() {
            return -1;
        };

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        if instr_kind == 0 {
            instr_offset = emit_lt(instr_base, instr_offset);
        } else if instr_kind == 1 {
            instr_offset = emit_gt(instr_base, instr_offset);
        } else if instr_kind == 2 {
            instr_offset = emit_le(instr_base, instr_offset);
        } else {
            instr_offset = emit_ge(instr_base, instr_offset);
        };
        store_i32(instr_offset_ptr, instr_offset);

        current_type = type_code_bool();
        set_expr_type(expr_type_ptr, current_type);
        saw_operator = true;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}

fn parse_shift(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_addition(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        if idx + 1 >= len {
            break;
        };

        let first: i32 = peek_byte(base, len, idx);
        let second: i32 = peek_byte(base, len, idx + 1);
        let mut op_kind: i32 = -1;

        if first == 60 && second == 60 {
            op_kind = 0;
        } else if first == 62 && second == 62 {
            op_kind = 1;
        } else if first == 41 || first == 59 || first == 125 || first == 123 {
            break;
        } else {
            break;
        };

        if op_kind < 0 {
            break;
        };

        if current_type != type_code_i32() {
            return -1;
        };

        idx = idx + 2;
        let next_idx: i32 = parse_addition(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if next_idx < 0 {
            return -1;
        };
        idx = next_idx;

        if get_expr_type(expr_type_ptr) != type_code_i32() {
            return -1;
        };

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        if op_kind == 0 {
            instr_offset = emit_shl(instr_base, instr_offset);
        } else {
            instr_offset = emit_shr_s(instr_base, instr_offset);
        };
        store_i32(instr_offset_ptr, instr_offset);

        current_type = type_code_i32();
        set_expr_type(expr_type_ptr, current_type);
        saw_operator = true;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}
fn parse_addition(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_multiplication(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte == 43 || op_byte == 45 {
            if current_type != type_code_i32() {
                return -1;
            };
            idx = idx + 1;
            let next_idx: i32 = parse_multiplication(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr
                );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;

            if get_expr_type(expr_type_ptr) != type_code_i32() {
                return -1;
            };

            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            if op_byte == 43 {
                instr_offset = emit_add(instr_base, instr_offset);
            } else {
                instr_offset = emit_sub(instr_base, instr_offset);
            };
            store_i32(instr_offset_ptr, instr_offset);
            current_type = type_code_i32();
            set_expr_type(expr_type_ptr, current_type);
            saw_operator = true;
            continue;
        };

        if op_byte == 41 || op_byte == 59 || op_byte == 125 || op_byte == 123 {
            break;
        };

        break;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}
fn parse_multiplication(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_unary(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };

    let mut current_type: i32 = get_expr_type(expr_type_ptr);
    let mut saw_operator: bool = false;

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte == 42 || op_byte == 47 {
            if current_type != type_code_i32() {
                return -1;
            };
            idx = idx + 1;
            let next_idx: i32 = parse_unary(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr
                );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;

            if get_expr_type(expr_type_ptr) != type_code_i32() {
                return -1;
            };

            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            if op_byte == 42 {
                instr_offset = emit_mul(instr_base, instr_offset);
            } else {
                instr_offset = emit_div(instr_base, instr_offset);
            };
            store_i32(instr_offset_ptr, instr_offset);
            current_type = type_code_i32();
            set_expr_type(expr_type_ptr, current_type);
            saw_operator = true;
            continue;
        };

        if op_byte == 41 || op_byte == 59 || op_byte == 125 || op_byte == 123 {
            break;
        };

        break;
    };

    if !saw_operator {
        set_expr_type(expr_type_ptr, current_type);
    };

    idx
}
fn parse_unary(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, offset);
    if idx >= len {
        return -1;
    };

    let mut minus_count: i32 = 0;
    let mut not_count: i32 = 0;

    loop {
        if idx >= len {
            return -1;
        };
        let byte: i32 = peek_byte(base, len, idx);
        if byte == 45 {
            minus_count = minus_count + 1;
            idx = idx + 1;
        } else if byte == 43 {
            idx = idx + 1;
        } else if byte == 33 {
            not_count = not_count + 1;
            idx = idx + 1;
        } else {
            break;
        };
        idx = skip_whitespace(base, len, idx);
    };

    let needs_negate: bool = (minus_count & 1) != 0;
    if needs_negate {
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_i32_const(instr_base, instr_offset, 0);
        store_i32(instr_offset_ptr, instr_offset);
    };

    let mut next_idx: i32 = parse_primary(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if next_idx < 0 {
        return -1;
    };

    if needs_negate {
        if get_expr_type(expr_type_ptr) != type_code_i32() {
            return -1;
        };
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_sub(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);
        set_expr_type(expr_type_ptr, type_code_i32());
    };

    if (not_count & 1) != 0 {
        if get_expr_type(expr_type_ptr) != type_code_bool() {
            return -1;
        };
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_eqz(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);
        set_expr_type(expr_type_ptr, type_code_bool());
    };

    next_idx
}
fn parse_primary(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, offset);
    if idx >= len {
        return -1;
    };

    let head_byte: i32 = peek_byte(base, len, idx);
    if head_byte == 105 {
        if idx + 1 >= len {
            return -1;
        };
        let second: i32 = peek_byte(base, len, idx + 1);
        if second == 102 {
            let after_keyword: i32 = idx + 2;
            if after_keyword == len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                return parse_if_expression(
                    base,
                    len,
                    idx,
                    instr_base,
                    instr_offset_ptr,
                    locals_base,
                    locals_count_ptr,
                    control_stack_base,
                    control_stack_count_ptr,
                    functions_base,
                    functions_count_ptr,
                    expr_type_ptr
                    );
            };
        };
    };

    if head_byte == 108 {
        if idx + 3 >= len {
            return -1;
        };
        let second: i32 = peek_byte(base, len, idx + 1);
        if second == 111 {
            let third: i32 = peek_byte(base, len, idx + 2);
            let fourth: i32 = peek_byte(base, len, idx + 3);
            if third == 111 && fourth == 112 {
                let after_keyword: i32 = idx + 4;
                if after_keyword == len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_loop_expression(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    if head_byte == 40 {
        idx = idx + 1;
        let inner_idx: i32 = parse_expression(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if inner_idx < 0 {
            return -1;
        };
        idx = skip_whitespace(base, len, inner_idx);
        idx = expect_char(base, len, idx, 41);
        return idx;
    };

    if idx + 4 <= len {
        let t: i32 = load_u8(base + idx);
        let r: i32 = load_u8(base + idx + 1);
        let u: i32 = load_u8(base + idx + 2);
        let e: i32 = load_u8(base + idx + 3);
        if t == 116 && r == 114 && u == 117 && e == 101 {
            let after: i32 = idx + 4;
            let mut valid_literal: bool = false;
            if after == len {
                valid_literal = true;
            } else {
                let next_byte: i32 = peek_byte(base, len, after);
                if !is_identifier_continue(next_byte) {
                    valid_literal = true;
                };
            };
            if valid_literal {
                let mut instr_offset: i32 = load_i32(instr_offset_ptr);
                instr_offset = emit_i32_const(instr_base, instr_offset, 1);
                store_i32(instr_offset_ptr, instr_offset);
                set_expr_type(expr_type_ptr, type_code_bool());
                return after;
            };
        };
    };

    if idx + 5 <= len {
        let f: i32 = load_u8(base + idx);
        let a: i32 = load_u8(base + idx + 1);
        let l: i32 = load_u8(base + idx + 2);
        let s: i32 = load_u8(base + idx + 3);
        let e: i32 = load_u8(base + idx + 4);
        if f == 102 && a == 97 && l == 108 && s == 115 && e == 101 {
            let after: i32 = idx + 5;
            let mut valid_literal: bool = false;
            if after == len {
                valid_literal = true;
            } else {
                let next_byte: i32 = peek_byte(base, len, after);
                if !is_identifier_continue(next_byte) {
                    valid_literal = true;
                };
            };
            if valid_literal {
                let mut instr_offset: i32 = load_i32(instr_offset_ptr);
                instr_offset = emit_i32_const(instr_base, instr_offset, 0);
                store_i32(instr_offset_ptr, instr_offset);
                set_expr_type(expr_type_ptr, type_code_bool());
                return after;
            };
        };
    };

    if is_identifier_start(head_byte) {
        let ident_start: i32 = idx;
        let mut ident_len: i32 = 0;
        loop {
            if idx >= len {
                break;
            };
            let ch: i32 = peek_byte(base, len, idx);
            if ident_len == 0 {
                if !is_identifier_start(ch) {
                    break;
                };
            } else if !is_identifier_continue(ch) {
                break;
            };
            ident_len = ident_len + 1;
            idx = idx + 1;
        };
        if ident_len == 0 {
            return -1;
        };
        if idx < len {
            let next_non_ws: i32 = idx;
            if next_non_ws < len {
                let next_char: i32 = peek_byte(base, len, next_non_ws);
                if next_char == 40 {
                    let intrinsic_kind: i32 =
                        identify_intrinsic(base, len, ident_start, ident_len);
                    let mut expected_params: i32 = 0;
                    let mut return_type: i32 = type_code_i32();
                    let mut func_index: i32 = -1;
                    let mut func_entry: i32 = 0;
                    let is_intrinsic: bool = intrinsic_kind != intrinsic_kind_none();
                    if is_intrinsic {
                        if intrinsic_kind == intrinsic_kind_load_u8()
                            || intrinsic_kind == intrinsic_kind_load_u16()
                            || intrinsic_kind == intrinsic_kind_load_i32()
                        {
                            expected_params = 1;
                            return_type = type_code_i32();
                        } else {
                            expected_params = 2;
                            return_type = type_code_unit();
                        };
                    } else {
                        func_index = functions_find(
                            base,
                            len,
                            functions_base,
                            functions_count_ptr,
                            ident_start,
                            ident_len
                        );
                        if func_index < 0 {
                            return -1;
                        };
                        func_entry = functions_entry(functions_base, func_index);
                        expected_params = load_i32(func_entry + 8);
                        return_type = load_i32(func_entry + 24);
                    };
                    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
                    let mut call_idx: i32 = next_non_ws + 1;
                    let mut arg_count: i32 = 0;
                    let mut parse_error: bool = false;
                    loop {
                        call_idx = skip_whitespace(base, len, call_idx);
                        if call_idx >= len {
                            parse_error = true;
                            break;
                        };
                        let next_byte: i32 = peek_byte(base, len, call_idx);
                        if next_byte == 41 {
                            call_idx = call_idx + 1;
                            break;
                        };
                        if arg_count >= expected_params {
                            parse_error = true;
                            break;
                        };
                        let expr_idx: i32 = parse_expression(
                            base,
                            len,
                            call_idx,
                            instr_base,
                            instr_offset_ptr,
                            locals_base,
                            locals_count_ptr,
                            control_stack_base,
                            control_stack_count_ptr,
                            functions_base,
                            functions_count_ptr,
                            expr_type_ptr
                        );
                        if expr_idx < 0 {
                            parse_error = true;
                            break;
                        };
                        let arg_type: i32 = get_expr_type(expr_type_ptr);
                        if is_intrinsic {
                            if intrinsic_kind == intrinsic_kind_load_u8()
                                || intrinsic_kind == intrinsic_kind_load_u16()
                                || intrinsic_kind == intrinsic_kind_load_i32()
                            {
                                if arg_type != type_code_i32() {
                                    parse_error = true;
                                    break;
                                };
                            } else if intrinsic_kind == intrinsic_kind_store_u8()
                                || intrinsic_kind == intrinsic_kind_store_u16()
                                || intrinsic_kind == intrinsic_kind_store_i32()
                            {
                                if arg_count == 0 {
                                    if arg_type != type_code_i32() {
                                        parse_error = true;
                                        break;
                                    };
                                } else if arg_type != type_code_i32() {
                                    parse_error = true;
                                    break;
                                };
                            };
                        };
                        arg_count = arg_count + 1;
                        call_idx = skip_whitespace(base, len, expr_idx);
                        if call_idx >= len {
                            parse_error = true;
                            break;
                        };
                        let after_expr: i32 = peek_byte(base, len, call_idx);
                        if after_expr == 44 {
                            call_idx = skip_whitespace(base, len, call_idx + 1);
                            continue;
                        };
                        if after_expr == 41 {
                            call_idx = call_idx + 1;
                            break;
                        };
                        parse_error = true;
                        break;
                    };
                    if parse_error || arg_count != expected_params {
                        store_i32(instr_offset_ptr, saved_instr_offset);
                        return -1;
                    };
                    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
                    if is_intrinsic {
                        if intrinsic_kind == intrinsic_kind_load_u8() {
                            instr_offset = emit_load_u8(instr_base, instr_offset);
                        } else if intrinsic_kind == intrinsic_kind_store_u8() {
                            instr_offset = emit_store_u8(instr_base, instr_offset);
                        } else if intrinsic_kind == intrinsic_kind_load_u16() {
                            instr_offset = emit_load_u16(instr_base, instr_offset);
                        } else if intrinsic_kind == intrinsic_kind_store_u16() {
                            instr_offset = emit_store_u16(instr_base, instr_offset);
                        } else if intrinsic_kind == intrinsic_kind_load_i32() {
                            instr_offset = emit_load_i32(instr_base, instr_offset);
                        } else if intrinsic_kind == intrinsic_kind_store_i32() {
                            instr_offset = emit_store_i32(instr_base, instr_offset);
                        };
                        store_i32(instr_offset_ptr, instr_offset);
                        set_expr_type(expr_type_ptr, return_type);
                        return call_idx;
                    };
                    instr_offset = emit_call(instr_base, instr_offset, func_index);
                    store_i32(instr_offset_ptr, instr_offset);
                    set_expr_type(expr_type_ptr, return_type);
                    return call_idx;
                };
            };
        };
        let entry_index: i32 = locals_find(
            base,
            len,
            locals_base,
            locals_count_ptr,
            ident_start,
            ident_len
        );
        if entry_index < 0 {
            return -1;
        };
        let wasm_index: i32 = locals_entry_wasm_index(locals_base, entry_index);
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_local_get(instr_base, instr_offset, wasm_index);
        store_i32(instr_offset_ptr, instr_offset);
        let var_type: i32 = locals_entry_type(locals_base, entry_index);
        set_expr_type(expr_type_ptr, var_type);
        return idx;
    };

    if head_byte < 48 || head_byte > 57 {
        return -1;
    };

    let mut value: i32 = 0;
    let mut has_digit: bool = false;
    loop {
        if idx >= len {
            break;
        };
        let digit_byte: i32 = peek_byte(base, len, idx);
        if digit_byte < 48 || digit_byte > 57 {
            break;
        };
        let digit: i32 = digit_byte - 48;
        value = value * 10 + digit;
        has_digit = true;
        idx = idx + 1;
    };

    if !has_digit {
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_i32_const(instr_base, instr_offset, value);
    store_i32(instr_offset_ptr, instr_offset);
    set_expr_type(expr_type_ptr, type_code_i32());

    idx
}

fn expect_keyword_if(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 102);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_return(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 114);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 116);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 117);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 114);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx
}

fn parse_return_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_return(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if is_identifier_continue(after_byte) {
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);
    if idx >= len {
        return -1;
    };
    let expected_return: i32 = load_i32(functions_base - 4);
    let next_byte: i32 = peek_byte(base, len, idx);
    if next_byte == 59 {
        if expected_return != type_code_unit() {
            return -1;
        };
        idx = idx + 1;
    } else {
        let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
        idx = parse_expression(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        if get_expr_type(expr_type_ptr) != expected_return {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
        idx = skip_whitespace(base, len, idx);
        idx = expect_char(base, len, idx, 59);
        if idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_return(instr_base, instr_offset);
    store_i32(instr_offset_ptr, instr_offset);

    idx
}

fn parse_expression_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_expression(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        return -1;
    };
    idx
}

fn parse_loop_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let saved_locals_count: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = expect_keyword_loop(base, len, offset);
    if idx < 0 {
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 123 && !is_whitespace(after_byte) {
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 123);
    if idx < 0 {
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };

    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
    let saved_control_len: i32 = load_i32(control_stack_count_ptr);

    let mut instr_offset: i32 = saved_instr_offset;
    instr_offset = emit_block(instr_base, instr_offset, 64);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_break(),
        control_type_none()
    );
    instr_offset = emit_loop_header(instr_base, instr_offset, 64);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_continue(),
        control_type_none()
    );

    let mut current_offset: i32 = idx;
    loop {
        current_offset = skip_whitespace(base, len, current_offset);
        if current_offset >= len {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
        let current_byte: i32 = peek_byte(base, len, current_offset);
        if current_byte == 125 {
            current_offset = current_offset + 1;
            break;
        };
        let stmt_offset: i32 = parse_statement(
            base,
            len,
            current_offset,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr,
            saved_locals_count
            );
        if stmt_offset < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
        current_offset = stmt_offset;
    };

    let mut instr_offset_finish: i32 = load_i32(instr_offset_ptr);
    instr_offset_finish = emit_br(instr_base, instr_offset_finish, 0);
    instr_offset_finish = emit_end(instr_base, instr_offset_finish);
    instr_offset_finish = emit_end(instr_base, instr_offset_finish);
    store_i32(instr_offset_ptr, instr_offset_finish);

    let popped_continue: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped_continue != control_kind_loop_continue() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    let popped_break: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped_break != control_kind_loop_break() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };

    let mut after_loop: i32 = skip_whitespace(base, len, current_offset);
    if after_loop < len {
        let next_byte: i32 = peek_byte(base, len, after_loop);
        if next_byte == 59 {
            after_loop = after_loop + 1;
        };
    };

    store_i32(locals_count_ptr, saved_locals_count);

    after_loop
}

fn parse_loop_expression(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let saved_locals_count: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = expect_keyword_loop(base, len, offset);
    if idx < 0 {
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 123 && !is_whitespace(after_byte) {
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 123);
    if idx < 0 {
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };

    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
    let saved_control_len: i32 = load_i32(control_stack_count_ptr);

    let mut instr_offset: i32 = saved_instr_offset;
    instr_offset = emit_block(instr_base, instr_offset, 127);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_break_value(),
        control_type_none()
    );
    instr_offset = emit_loop_header(instr_base, instr_offset, 64);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_continue(),
        control_type_none()
    );

    let mut current_offset: i32 = idx;
    loop {
        current_offset = skip_whitespace(base, len, current_offset);
        if current_offset >= len {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
        let current_byte: i32 = peek_byte(base, len, current_offset);
        if current_byte == 125 {
            current_offset = current_offset + 1;
            break;
        };
        let stmt_offset: i32 = parse_statement(
            base,
            len,
            current_offset,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr,
            saved_locals_count
            );
        if stmt_offset < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            store_i32(locals_count_ptr, saved_locals_count);
            return -1;
        };
        current_offset = stmt_offset;
    };

    let mut instr_offset_finish: i32 = load_i32(instr_offset_ptr);
    instr_offset_finish = emit_br(instr_base, instr_offset_finish, 0);
    instr_offset_finish = emit_end(instr_base, instr_offset_finish);
    instr_offset_finish = emit_end(instr_base, instr_offset_finish);
    store_i32(instr_offset_ptr, instr_offset_finish);

    let break_depth: i32 = control_stack_find_depth(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_break_value()
    );
    if break_depth < 0 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    let result_type: i32 = control_stack_type_at_depth(
        control_stack_base,
        control_stack_count_ptr,
        break_depth
    );
    if result_type == control_type_none() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    set_expr_type(expr_type_ptr, result_type);

    let popped_continue: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped_continue != control_kind_loop_continue() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };
    let popped_break: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped_break != control_kind_loop_break_value() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        store_i32(locals_count_ptr, saved_locals_count);
        return -1;
    };

    let after_loop: i32 = skip_whitespace(base, len, current_offset);

    store_i32(locals_count_ptr, saved_locals_count);

    after_loop
}

fn parse_break_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_break(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 59 && !is_whitespace(after_byte) {
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);

    if idx >= len {
        return -1;
    };
    let next_byte: i32 = peek_byte(base, len, idx);
    if next_byte == 59 {
        let depth: i32 = control_stack_find_depth(
            control_stack_base,
            control_stack_count_ptr,
            control_kind_loop_break()
        );
        if depth < 0 {
            return -1;
        };
        idx = expect_char(base, len, idx, 59);
        if idx < 0 {
            return -1;
        };
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_br(instr_base, instr_offset, depth);
        store_i32(instr_offset_ptr, instr_offset);
        return idx;
    };

    let mut depth_value: i32 = control_stack_find_depth(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_break_value()
    );
    let mut should_record_type: bool = true;
    let mut should_drop_value: bool = false;
    if depth_value < 0 {
        depth_value = control_stack_find_depth(
            control_stack_base,
            control_stack_count_ptr,
            control_kind_loop_break()
        );
        if depth_value < 0 {
            return -1;
        };
        should_record_type = false;
        should_drop_value = true;
    };

    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
    let expr_end: i32 = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if expr_end < 0 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        return -1;
    };

    if should_record_type {
        let value_type: i32 = get_expr_type(expr_type_ptr);
        let stored_type: i32 = control_stack_type_at_depth(
            control_stack_base,
            control_stack_count_ptr,
            depth_value
        );
        if stored_type == control_type_none() {
            control_stack_set_type_at_depth(
                control_stack_base,
                control_stack_count_ptr,
                depth_value,
                value_type
            );
        } else if stored_type != value_type {
            store_i32(instr_offset_ptr, saved_instr_offset);
            return -1;
        };
    };

    idx = skip_whitespace(base, len, expr_end);
    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    if should_drop_value {
        instr_offset = emit_drop(instr_base, instr_offset);
    };
    instr_offset = emit_br(instr_base, instr_offset, depth_value);
    store_i32(instr_offset_ptr, instr_offset);

    idx
}

fn parse_continue_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_continue(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 59 && !is_whitespace(after_byte) {
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);

    let depth: i32 = control_stack_find_depth(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_loop_continue()
    );
    if depth < 0 {
        return -1;
    };

    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_br(instr_base, instr_offset, depth);
    store_i32(instr_offset_ptr, instr_offset);

    idx
}

fn parse_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32,
    scope_base: i32
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, offset);
    if idx >= len {
        return -1;
    };

    if idx + 3 <= len {
        let l: i32 = peek_byte(base, len, idx);
        if l == 108 {
            let e: i32 = peek_byte(base, len, idx + 1);
            let t: i32 = peek_byte(base, len, idx + 2);
            if e == 101 && t == 116 {
                let after_keyword: i32 = idx + 3;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_let_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr,
                        scope_base
                        );
                };
            };
        };
    };

    if idx + 6 <= len {
        let r: i32 = peek_byte(base, len, idx);
        if r == 114 {
            let e: i32 = peek_byte(base, len, idx + 1);
            let t: i32 = peek_byte(base, len, idx + 2);
            let u: i32 = peek_byte(base, len, idx + 3);
            let rn: i32 = peek_byte(base, len, idx + 4);
            let n: i32 = peek_byte(base, len, idx + 5);
            if e == 101 && t == 116 && u == 117 && rn == 114 && n == 110 {
                let after_keyword: i32 = idx + 6;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_return_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    if idx + 4 <= len {
        let l_char: i32 = peek_byte(base, len, idx);
        if l_char == 108 {
            let o_char: i32 = peek_byte(base, len, idx + 1);
            let o2_char: i32 = peek_byte(base, len, idx + 2);
            let p_char: i32 = peek_byte(base, len, idx + 3);
            if o_char == 111 && o2_char == 111 && p_char == 112 {
                let after_keyword: i32 = idx + 4;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_loop_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    if idx + 5 <= len {
        let b_char: i32 = peek_byte(base, len, idx);
        if b_char == 98 {
            let r_char: i32 = peek_byte(base, len, idx + 1);
            let e_char: i32 = peek_byte(base, len, idx + 2);
            let a_char: i32 = peek_byte(base, len, idx + 3);
            let k_char: i32 = peek_byte(base, len, idx + 4);
            if r_char == 114 && e_char == 101 && a_char == 97 && k_char == 107 {
                let after_keyword: i32 = idx + 5;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_break_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    if idx + 8 <= len {
        let c_char: i32 = peek_byte(base, len, idx);
        if c_char == 99 {
            let o_char: i32 = peek_byte(base, len, idx + 1);
            let n_char: i32 = peek_byte(base, len, idx + 2);
            let t_char: i32 = peek_byte(base, len, idx + 3);
            let i_char: i32 = peek_byte(base, len, idx + 4);
            let n2_char: i32 = peek_byte(base, len, idx + 5);
            let u_char: i32 = peek_byte(base, len, idx + 6);
            let e_char: i32 = peek_byte(base, len, idx + 7);
            if o_char == 111
                && n_char == 110
                && t_char == 116
                && i_char == 105
                && n2_char == 110
                && u_char == 117
                && e_char == 101
            {
                let after_keyword: i32 = idx + 8;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_continue_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    if idx + 2 <= len {
        let i_char: i32 = peek_byte(base, len, idx);
        if i_char == 105 {
            let f_char: i32 = peek_byte(base, len, idx + 1);
            if f_char == 102 {
                let after_keyword: i32 = idx + 2;
                if after_keyword >= len || !is_identifier_continue(peek_byte(base, len, after_keyword)) {
                    return parse_if_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                };
            };
        };
    };

    let assignment_offset: i32 = parse_assignment_statement(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if assignment_offset == -1 {
        return -1;
    };
    if assignment_offset >= 0 {
        return assignment_offset;
    };

    parse_expression_statement(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        )
}

fn parse_block_statements(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let saved_locals: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = offset;
    let mut result: i32 = -1;
    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };
        let byte: i32 = peek_byte(base, len, idx);
        if byte == 125 {
            result = idx + 1;
            break;
        };
        let next_idx: i32 = parse_statement(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr,
            saved_locals
            );
        if next_idx < 0 {
            break;
        };
        idx = next_idx;
    };
    store_i32(locals_count_ptr, saved_locals);
    result
}

fn parse_block_expression(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let saved_locals: i32 = load_i32(locals_count_ptr);
    let mut current_offset: i32 = offset;
    let mut result_offset: i32 = -1;
    loop {
        current_offset = skip_whitespace(base, len, current_offset);
        if current_offset >= len {
            break;
        };
        let current_byte: i32 = peek_byte(base, len, current_offset);
        if current_byte == 125 {
            break;
        };
        let prev_instr_offset: i32 = load_i32(instr_offset_ptr);
        let stmt_offset: i32 = parse_statement(
            base,
            len,
            current_offset,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr,
            saved_locals
            );
        if stmt_offset >= 0 {
            current_offset = stmt_offset;
            continue;
        };
        if stmt_offset != -1 {
            break;
        };
        store_i32(instr_offset_ptr, prev_instr_offset);
        let expr_offset: i32 = parse_expression(
            base,
            len,
            current_offset,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr,
            control_stack_base,
            control_stack_count_ptr,
            functions_base,
            functions_count_ptr,
            expr_type_ptr
            );
        if expr_offset < 0 {
            break;
        };
        let mut after_expr: i32 = skip_whitespace(base, len, expr_offset);
        after_expr = expect_char(base, len, after_expr, 125);
        if after_expr < 0 {
            break;
        };
        result_offset = after_expr;
        break;
    };
    store_i32(locals_count_ptr, saved_locals);
    result_offset
}

fn parse_if_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_if(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 123 && !is_whitespace(after_byte) {
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);
    let saved_condition_instr: i32 = load_i32(instr_offset_ptr);
    idx = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };
    if get_expr_type(expr_type_ptr) != type_code_bool() {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 123);
    if idx < 0 {
        return -1;
    };

    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
    let saved_control_len: i32 = load_i32(control_stack_count_ptr);

    let mut instr_offset: i32 = saved_instr_offset;
    instr_offset = emit_if(instr_base, instr_offset, 64);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_if(),
        control_type_none()
    );

    let mut after_block: i32 = parse_block_statements(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if after_block < 0 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };

    let then_type: i32 = get_expr_type(expr_type_ptr);

    idx = skip_whitespace(base, len, after_block);

    if idx + 4 <= len {
        let e_char: i32 = peek_byte(base, len, idx);
        if e_char == 101 {
            let l_char: i32 = peek_byte(base, len, idx + 1);
            let s_char: i32 = peek_byte(base, len, idx + 2);
            let e2_char: i32 = peek_byte(base, len, idx + 3);
            if l_char == 108 && s_char == 115 && e2_char == 101 {
                let after_else: i32 = idx + 4;
                if after_else < len && is_identifier_continue(peek_byte(base, len, after_else)) {
                    store_i32(instr_offset_ptr, saved_instr_offset);
                    store_i32(control_stack_count_ptr, saved_control_len);
                    return -1;
                };
                idx = skip_whitespace(base, len, after_else);
                let mut instr_offset_else: i32 = load_i32(instr_offset_ptr);
                instr_offset_else = emit_else(instr_base, instr_offset_else);
                store_i32(instr_offset_ptr, instr_offset_else);
                if idx >= len {
                    store_i32(instr_offset_ptr, saved_instr_offset);
                    store_i32(control_stack_count_ptr, saved_control_len);
                    return -1;
                };
                let next_byte: i32 = peek_byte(base, len, idx);
                if next_byte == 123 {
                    idx = expect_char(base, len, idx, 123);
                    idx = parse_block_statements(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                    if idx < 0 {
                        store_i32(instr_offset_ptr, saved_instr_offset);
                        store_i32(control_stack_count_ptr, saved_control_len);
                        return -1;
                    };
                    if get_expr_type(expr_type_ptr) != then_type {
                        store_i32(instr_offset_ptr, saved_instr_offset);
                        store_i32(control_stack_count_ptr, saved_control_len);
                        return -1;
                    };
                    idx = skip_whitespace(base, len, idx);
                } else if next_byte == 105 {
                    idx = parse_if_statement(
                        base,
                        len,
                        idx,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr,
                        control_stack_base,
                        control_stack_count_ptr,
                        functions_base,
                        functions_count_ptr,
                        expr_type_ptr
                        );
                    if idx < 0 {
                        store_i32(instr_offset_ptr, saved_instr_offset);
                        store_i32(control_stack_count_ptr, saved_control_len);
                        return -1;
                    };
                    idx = skip_whitespace(base, len, idx);
                } else {
                    store_i32(instr_offset_ptr, saved_instr_offset);
                    store_i32(control_stack_count_ptr, saved_control_len);
                    return -1;
                };
            };
        };
    };

    set_expr_type(expr_type_ptr, then_type);

    let mut final_instr_offset: i32 = load_i32(instr_offset_ptr);
    final_instr_offset = emit_end(instr_base, final_instr_offset);
    store_i32(instr_offset_ptr, final_instr_offset);

    let popped: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped != control_kind_if() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };

    if idx < len {
        let maybe_semicolon: i32 = peek_byte(base, len, idx);
        if maybe_semicolon == 59 {
            idx = idx + 1;
        };
    };

    idx
}

fn parse_if_expression(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_if(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx < len {
        let after_byte: i32 = peek_byte(base, len, idx);
        if after_byte != 123 && !is_whitespace(after_byte) && after_byte != 40 {
            return -1;
        };
    };
    idx = skip_whitespace(base, len, idx);
    let saved_condition_instr: i32 = load_i32(instr_offset_ptr);
    idx = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        store_i32(instr_offset_ptr, saved_condition_instr);
        return -1;
    };
    if get_expr_type(expr_type_ptr) != type_code_bool() {
        store_i32(instr_offset_ptr, saved_condition_instr);
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 123);
    if idx < 0 {
        store_i32(instr_offset_ptr, saved_condition_instr);
        return -1;
    };

    let saved_instr_offset: i32 = load_i32(instr_offset_ptr);
    let saved_control_len: i32 = load_i32(control_stack_count_ptr);

    let mut instr_offset: i32 = saved_instr_offset;
    instr_offset = emit_if(instr_base, instr_offset, 127);
    store_i32(instr_offset_ptr, instr_offset);
    control_stack_push(
        control_stack_base,
        control_stack_count_ptr,
        control_kind_if(),
        control_type_none()
    );

    let mut after_block: i32 = parse_block_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if after_block < 0 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };

    let then_type: i32 = get_expr_type(expr_type_ptr);

    idx = skip_whitespace(base, len, after_block);

    if idx + 4 > len {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };
    let e_char: i32 = peek_byte(base, len, idx);
    let l_char: i32 = peek_byte(base, len, idx + 1);
    let s_char: i32 = peek_byte(base, len, idx + 2);
    let e2_char: i32 = peek_byte(base, len, idx + 3);
    if e_char != 101 || l_char != 108 || s_char != 115 || e2_char != 101 {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };
    let after_else: i32 = idx + 4;
    if after_else < len && is_identifier_continue(peek_byte(base, len, after_else)) {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };
    idx = skip_whitespace(base, len, after_else);

    let mut instr_offset_else: i32 = load_i32(instr_offset_ptr);
    instr_offset_else = emit_else(instr_base, instr_offset_else);
    store_i32(instr_offset_ptr, instr_offset_else);

    if idx >= len {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };
    let next_byte: i32 = peek_byte(base, len, idx);
    if next_byte == 123 {
        idx = expect_char(base, len, idx, 123);
        idx = parse_block_expression(
                    base,
                    len,
                    idx,
                    instr_base,
                    instr_offset_ptr,
                    locals_base,
                    locals_count_ptr,
                    control_stack_base,
                    control_stack_count_ptr,
                    functions_base,
                    functions_count_ptr,
                    expr_type_ptr
                    );
        if idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            return -1;
        };
        if get_expr_type(expr_type_ptr) != then_type {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            return -1;
        };
        idx = skip_whitespace(base, len, idx);
    } else if next_byte == 105 {
        idx = parse_if_expression(
                    base,
                    len,
                    idx,
                    instr_base,
                    instr_offset_ptr,
                    locals_base,
                    locals_count_ptr,
                    control_stack_base,
                    control_stack_count_ptr,
                    functions_base,
                    functions_count_ptr,
                    expr_type_ptr
                    );
        if idx < 0 {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            return -1;
        };
        if get_expr_type(expr_type_ptr) != then_type {
            store_i32(instr_offset_ptr, saved_instr_offset);
            store_i32(control_stack_count_ptr, saved_control_len);
            return -1;
        };
        idx = skip_whitespace(base, len, idx);
    } else {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };

    set_expr_type(expr_type_ptr, then_type);

    let mut final_instr_offset: i32 = load_i32(instr_offset_ptr);
    final_instr_offset = emit_end(instr_base, final_instr_offset);
    store_i32(instr_offset_ptr, final_instr_offset);

    let popped: i32 = control_stack_pop(control_stack_base, control_stack_count_ptr);
    if popped != control_kind_if() {
        store_i32(instr_offset_ptr, saved_instr_offset);
        store_i32(control_stack_count_ptr, saved_control_len);
        return -1;
    };

    idx
}

fn parse_let_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32,
    scope_base: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_let(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx >= len {
        return -1;
    };
    let after_keyword: i32 = peek_byte(base, len, idx);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    if idx >= len {
        return -1;
    };

    let mut is_mut: bool = false;
    if idx + 3 <= len {
        let m: i32 = peek_byte(base, len, idx);
        if m == 109 {
            let u: i32 = peek_byte(base, len, idx + 1);
            let t: i32 = peek_byte(base, len, idx + 2);
            if u == 117 && t == 116 {
                let after_mut: i32 = idx + 3;
                if after_mut >= len {
                    return -1;
                };
                let after_mut_byte: i32 = peek_byte(base, len, after_mut);
                if is_whitespace(after_mut_byte) {
                    is_mut = true;
                    idx = skip_whitespace(base, len, after_mut);
                };
            };
        };
    };

    let name_start: i32 = idx;
    let mut name_len: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let ch: i32 = peek_byte(base, len, idx);
        if name_len == 0 {
            if !is_identifier_start(ch) {
                break;
            };
        } else if !is_identifier_continue(ch) {
            break;
        };
        name_len = name_len + 1;
        idx = idx + 1;
    };
    if name_len == 0 {
        return -1;
    };

    let existing: i32 = locals_find_in_scope(
        base,
        len,
        locals_base,
        locals_count_ptr,
        scope_base,
        name_start,
        name_len
    );
    if existing >= 0 {
        return -1;
    };

    let wasm_index: i32 = load_i32(locals_count_ptr);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 58);
    if idx < 0 {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    if idx >= len {
        return -1;
    };

    let mut declared_type: i32 = type_code_i32();
    let mut matched_bool: bool = false;
    if idx + 4 <= len {
        let b_char: i32 = peek_byte(base, len, idx);
        if b_char == 98 {
            let o_char: i32 = peek_byte(base, len, idx + 1);
            let o2_char: i32 = peek_byte(base, len, idx + 2);
            let l_char: i32 = peek_byte(base, len, idx + 3);
            if o_char == 111 && o2_char == 111 && l_char == 108 {
                let after_bool: i32 = idx + 4;
                if after_bool == len || !is_identifier_continue(peek_byte(base, len, after_bool)) {
                    idx = after_bool;
                    matched_bool = true;
                    declared_type = type_code_bool();
                };
            };
        };
    };

    if !matched_bool {
        idx = expect_keyword_i32(base, len, idx);
        if idx < 0 {
            return -1;
        };
        declared_type = type_code_i32();
    };

    if idx < len {
        let after_type: i32 = peek_byte(base, len, idx);
        if after_type != 61 && !is_whitespace(after_type) {
            return -1;
        };
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 61);
    if idx < 0 {
        return -1;
    };

    idx = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };
    if get_expr_type(expr_type_ptr) != declared_type {
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_local_set(instr_base, instr_offset, wasm_index);
    store_i32(instr_offset_ptr, instr_offset);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        return -1;
    };

    locals_store_entry(
        locals_base,
        locals_count_ptr,
        name_start,
        name_len,
        wasm_index,
        is_mut,
        declared_type
    );

    idx
}

fn parse_assignment_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    expr_type_ptr: i32
) -> i32 {
    let mut idx: i32 = offset;
    if idx >= len {
        return -2;
    };
    let first: i32 = peek_byte(base, len, idx);
    if !is_identifier_start(first) {
        return -2;
    };

    let name_start: i32 = idx;
    let mut name_len: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let ch: i32 = peek_byte(base, len, idx);
        if name_len == 0 {
            if !is_identifier_start(ch) {
                break;
            };
        } else if !is_identifier_continue(ch) {
            break;
        };
        name_len = name_len + 1;
        idx = idx + 1;
    };
    if name_len == 0 {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    if idx >= len {
        return -1;
    };
    let eq_byte: i32 = peek_byte(base, len, idx);
    if eq_byte != 61 {
        return -2;
    };
    idx = idx + 1;

    idx = skip_whitespace(base, len, idx);

    let entry_index: i32 = locals_find(
        base,
        len,
        locals_base,
        locals_count_ptr,
        name_start,
        name_len
    );
    if entry_index < 0 {
        return -1;
    };
    if !locals_is_mutable(locals_base, entry_index) {
        return -1;
    };
    let wasm_index: i32 = locals_entry_wasm_index(locals_base, entry_index);
    let target_type: i32 = locals_entry_type(locals_base, entry_index);

    idx = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr,
        control_stack_base,
        control_stack_count_ptr,
        functions_base,
        functions_count_ptr,
        expr_type_ptr
        );
    if idx < 0 {
        return -1;
    };
    if get_expr_type(expr_type_ptr) != target_type {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_local_set(instr_base, instr_offset, wasm_index);
    store_i32(instr_offset_ptr, instr_offset);

    idx = skip_whitespace(base, len, idx);

    idx
}

fn register_function_signatures(
    input_ptr: i32,
    input_len: i32,
    functions_base: i32,
    functions_count_ptr: i32,
    types_base: i32,
    types_count_ptr: i32,
) -> i32 {
    store_i32(functions_count_ptr, 0);
    store_i32(types_count_ptr, 0);
    let mut offset: i32 = 0;
    let mut main_index: i32 = -1;

    loop {
        offset = skip_whitespace(input_ptr, input_len, offset);
        if offset >= input_len {
            break;
        };

        if keyword_matches(
            input_ptr,
            input_len,
            offset,
            4,
            116,
            121,
            112,
            101,
            0,
            0,
            0,
            0,
        ) {
            offset = expect_keyword_type(input_ptr, input_len, offset);
            if offset < 0 {
                return -1;
            };

            if offset >= input_len {
                return -1;
            };
            let after_type_byte: i32 = peek_byte(input_ptr, input_len, offset);
            if after_type_byte < 0 || !is_whitespace(after_type_byte) {
                return -1;
            };
            offset = skip_whitespace(input_ptr, input_len, offset);
            if offset >= input_len {
                return -1;
            };

            let name_start: i32 = offset;
            let mut name_len: i32 = 0;
            loop {
                if offset >= input_len {
                    break;
                };
                let ch: i32 = peek_byte(input_ptr, input_len, offset);
                if name_len == 0 {
                    if !is_identifier_start(ch) {
                        break;
                    };
                } else if !is_identifier_continue(ch) {
                    break;
                };
                name_len = name_len + 1;
                offset = offset + 1;
            };
            if name_len == 0 {
                return -1;
            };

            if types_find(
                input_ptr,
                input_len,
                types_base,
                types_count_ptr,
                name_start,
                name_len,
            ) >= 0
            {
                return -1;
            };

            offset = skip_whitespace(input_ptr, input_len, offset);
            offset = expect_char(input_ptr, input_len, offset, 61);
            if offset < 0 {
                return -1;
            };

            offset = skip_whitespace(input_ptr, input_len, offset);
            if offset >= input_len {
                return -1;
            };

            let value_start: i32 = offset;
            let mut value_end: i32 = value_start;
            loop {
                if value_end >= input_len {
                    return -1;
                };
                let value_byte: i32 = peek_byte(input_ptr, input_len, value_end);
                if value_byte == 59 {
                    break;
                };
                value_end = value_end + 1;
            };

            let mut trimmed_end: i32 = value_end;
            loop {
                if trimmed_end <= value_start {
                    break;
                };
                let last_byte: i32 = peek_byte(input_ptr, input_len, trimmed_end - 1);
                if last_byte < 0 {
                    return -1;
                };
                if !is_whitespace(last_byte) {
                    break;
                };
                trimmed_end = trimmed_end - 1;
            };
            if trimmed_end <= value_start {
                return -1;
            };

            let value_len: i32 = trimmed_end - value_start;

            let type_index: i32 = load_i32(types_count_ptr);
            let entry: i32 = types_entry(types_base, type_index);
            store_i32(entry, name_start);
            store_i32(entry + 4, name_len);
            store_i32(entry + 8, value_start);
            store_i32(entry + 12, value_len);
            store_i32(types_count_ptr, type_index + 1);

            offset = value_end + 1;
            continue;
        };

        offset = expect_keyword_fn(input_ptr, input_len, offset);
        if offset < 0 {
            return -1;
        };

        if offset >= input_len {
            return -1;
        };
        let after_fn_byte: i32 = peek_byte(input_ptr, input_len, offset);
        if after_fn_byte < 0 || !is_whitespace(after_fn_byte) {
            return -1;
        };
        offset = skip_whitespace(input_ptr, input_len, offset);
        if offset >= input_len {
            return -1;
        };

        let name_start: i32 = offset;
        let mut name_len: i32 = 0;
        loop {
            if offset >= input_len {
                break;
            };
            let ch: i32 = peek_byte(input_ptr, input_len, offset);
            if name_len == 0 {
                if !is_identifier_start(ch) {
                    break;
                };
            } else if !is_identifier_continue(ch) {
                break;
            };
            name_len = name_len + 1;
            offset = offset + 1;
        };
        if name_len == 0 {
            return -1;
        };

        if functions_find(
            input_ptr,
            input_len,
            functions_base,
            functions_count_ptr,
            name_start,
            name_len,
        ) >= 0 {
            return -1;
        };

        let func_index: i32 = load_i32(functions_count_ptr);
        let entry: i32 = functions_entry(functions_base, func_index);
        store_i32(entry, name_start);
        store_i32(entry + 4, name_len);
        store_i32(entry + 8, 0);
        store_i32(entry + 12, 0);
        store_i32(entry + 16, 0);
        store_i32(entry + 20, 0);
        store_i32(entry + 24, 0);
        store_i32(entry + 28, 0);
        store_i32(functions_count_ptr, func_index + 1);

        let mut is_main: bool = false;
        if name_len == 4 {
            let m: i32 = load_u8(input_ptr + name_start);
            let a: i32 = load_u8(input_ptr + name_start + 1);
            let i_char: i32 = load_u8(input_ptr + name_start + 2);
            let n_char: i32 = load_u8(input_ptr + name_start + 3);
            if m == 109 && a == 97 && i_char == 105 && n_char == 110 {
                is_main = true;
            };
        };
        if is_main {
            if main_index >= 0 {
                return -1;
            };
            main_index = func_index;
        };

        offset = skip_whitespace(input_ptr, input_len, offset);
        offset = expect_char(input_ptr, input_len, offset, 40);
        if offset < 0 {
            return -1;
        };

        let mut param_parse_idx: i32 = skip_whitespace(input_ptr, input_len, offset);
        let mut param_count: i32 = 0;
        loop {
            if param_parse_idx >= input_len {
                return -1;
            };
            let next_byte: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
            if next_byte == 41 {
                param_parse_idx = param_parse_idx + 1;
                break;
            };

            let mut name_len: i32 = 0;
            let name_start: i32 = param_parse_idx;
            loop {
                if param_parse_idx >= input_len {
                    break;
                };
                let ch: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
                if name_len == 0 {
                    if !is_identifier_start(ch) {
                        break;
                    };
                } else if !is_identifier_continue(ch) {
                    break;
                };
                name_len = name_len + 1;
                param_parse_idx = param_parse_idx + 1;
            };
            if name_len == 0 {
                return -1;
            };

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            param_parse_idx = expect_char(input_ptr, input_len, param_parse_idx, 58);
            if param_parse_idx < 0 {
                return -1;
            };

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            if param_parse_idx >= input_len {
                return -1;
            };

            let mut matched_bool: bool = false;
            if param_parse_idx + 4 <= input_len {
                let b_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
                if b_char == 98 {
                    let o_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 1);
                    let o2_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 2);
                    let l_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 3);
                    let after_bool: i32 = param_parse_idx + 4;
                    if o_char == 111 && o2_char == 111 && l_char == 108 {
                        if after_bool == input_len
                            || !is_identifier_continue(peek_byte(input_ptr, input_len, after_bool))
                        {
                            param_parse_idx = after_bool;
                            matched_bool = true;
                        };
                    };
                };
            };
            if !matched_bool {
                param_parse_idx = expect_keyword_i32(input_ptr, input_len, param_parse_idx);
                if param_parse_idx < 0 {
                    return -1;
                };
            };

            param_count = param_count + 1;

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            if param_parse_idx >= input_len {
                return -1;
            };
            let delimiter: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
            if delimiter == 44 {
                param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx + 1);
                continue;
            };
            if delimiter == 41 {
                param_parse_idx = param_parse_idx + 1;
                break;
            };
            return -1;
        };

        store_i32(entry + 8, param_count);
        offset = param_parse_idx;

        offset = skip_whitespace(input_ptr, input_len, offset);

        let mut return_type: i32 = type_code_unit();
        let mut has_arrow: bool = false;
        if offset < input_len {
            let maybe_arrow: i32 = peek_byte(input_ptr, input_len, offset);
            if maybe_arrow == 45 {
                has_arrow = true;
                offset = expect_char(input_ptr, input_len, offset, 45);
                if offset < 0 {
                    return -1;
                };
                offset = expect_char(input_ptr, input_len, offset, 62);
                if offset < 0 {
                    return -1;
                };
                offset = skip_whitespace(input_ptr, input_len, offset);

                let mut matched_return: bool = false;
                if offset + 4 <= input_len {
                    let b_char: i32 = peek_byte(input_ptr, input_len, offset);
                    if b_char == 98 {
                        let o_char: i32 = peek_byte(input_ptr, input_len, offset + 1);
                        let o2_char: i32 = peek_byte(input_ptr, input_len, offset + 2);
                        let l_char: i32 = peek_byte(input_ptr, input_len, offset + 3);
                        let after_bool: i32 = offset + 4;
                        if o_char == 111 && o2_char == 111 && l_char == 108 {
                            if after_bool == input_len
                                || !is_identifier_continue(peek_byte(input_ptr, input_len, after_bool))
                            {
                                offset = after_bool;
                                matched_return = true;
                                return_type = type_code_bool();
                            };
                        };
                    };
                };
                if !matched_return {
                    offset = expect_keyword_i32(input_ptr, input_len, offset);
                    if offset < 0 {
                        return -1;
                    };
                    return_type = type_code_i32();
                };
            };
        };
        if !has_arrow {
            return_type = type_code_unit();
        };
        store_i32(entry + 24, return_type);
        if is_main {
            if return_type != type_code_i32() {
                return -1;
            };
        };

        offset = skip_whitespace(input_ptr, input_len, offset);
        offset = expect_char(input_ptr, input_len, offset, 123);
        if offset < 0 {
            return -1;
        };
        store_i32(entry + 28, offset);

        let mut depth: i32 = 1;
        let mut scan_offset: i32 = offset;
        loop {
            if scan_offset >= input_len {
                return -1;
            };
            let ch: i32 = peek_byte(input_ptr, input_len, scan_offset);
            scan_offset = scan_offset + 1;
            if ch == 123 {
                depth = depth + 1;
                continue;
            };
            if ch == 125 {
                depth = depth - 1;
                if depth == 0 {
                    break;
                };
                continue;
            };
        };
        offset = scan_offset;
    };

    main_index
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    if input_len == 0 {
        return -1;
    };

    let instr_offset_ptr: i32 = scratch_instr_offset_ptr(out_ptr);
    store_i32(instr_offset_ptr, 0);
    let instr_base: i32 = scratch_instr_base(out_ptr);
    let expr_type_ptr: i32 = scratch_expr_type_ptr(out_ptr);
    store_i32(expr_type_ptr, -1);
    let instr_capacity: i32 = scratch_instr_capacity();
    let locals_capacity: i32 = scratch_locals_capacity();
    let locals_max_ptr: i32 = scratch_locals_max_ptr(instr_base);
    store_i32(locals_max_ptr, 0);
    let locals_count_ptr: i32 = scratch_locals_count_ptr(instr_base);
    let locals_base: i32 = scratch_locals_base(instr_base);
    let control_stack_count_ptr: i32 = scratch_control_stack_count_ptr(instr_base);
    let control_stack_base: i32 = scratch_control_stack_base(instr_base);
    let functions_count_ptr: i32 = scratch_functions_count_ptr(out_ptr);
    let functions_base: i32 = scratch_functions_base(out_ptr);
    let types_count_ptr: i32 = scratch_types_count_ptr(out_ptr);
    let types_base: i32 = scratch_types_base(out_ptr);
    let current_return_type_ptr: i32 = scratch_current_return_type_ptr(out_ptr);
    store_i32(current_return_type_ptr, type_code_unit());
    store_i32(functions_count_ptr, 0);

    let main_index: i32 = register_function_signatures(
        input_ptr,
        input_len,
        functions_base,
        functions_count_ptr,
        types_base,
        types_count_ptr,
    );
    if main_index < 0 {
        return -1;
    };

    let func_count: i32 = load_i32(functions_count_ptr);
    if func_count <= 0 {
        return -1;
    };

    let mut offset: i32 = 0;
    let mut compiled_index: i32 = 0;
    let mut compiled_type_index: i32 = 0;
    let types_total: i32 = load_i32(types_count_ptr);

    loop {
        offset = skip_whitespace(input_ptr, input_len, offset);
        if offset >= input_len {
            break;
        };

        if keyword_matches(
            input_ptr,
            input_len,
            offset,
            4,
            116,
            121,
            112,
            101,
            0,
            0,
            0,
            0,
        ) {
            if compiled_type_index >= types_total {
                return -1;
            };
            offset = expect_keyword_type(input_ptr, input_len, offset);
            if offset < 0 {
                return -1;
            };

            if offset >= input_len {
                return -1;
            };
            let after_type_byte: i32 = peek_byte(input_ptr, input_len, offset);
            if after_type_byte < 0 || !is_whitespace(after_type_byte) {
                return -1;
            };
            offset = skip_whitespace(input_ptr, input_len, offset);
            if offset >= input_len {
                return -1;
            };

            let name_start: i32 = offset;
            let mut name_len: i32 = 0;
            loop {
                if offset >= input_len {
                    break;
                };
                let ch: i32 = peek_byte(input_ptr, input_len, offset);
                if name_len == 0 {
                    if !is_identifier_start(ch) {
                        break;
                    };
                } else if !is_identifier_continue(ch) {
                    break;
                };
                name_len = name_len + 1;
                offset = offset + 1;
            };
            if name_len == 0 {
                return -1;
            };

            let entry: i32 = types_entry(types_base, compiled_type_index);
            let stored_name_start: i32 = load_i32(entry);
            let stored_name_len: i32 = load_i32(entry + 4);
            if stored_name_start != name_start || stored_name_len != name_len {
                return -1;
            };

            offset = skip_whitespace(input_ptr, input_len, offset);
            offset = expect_char(input_ptr, input_len, offset, 61);
            if offset < 0 {
                return -1;
            };

            offset = skip_whitespace(input_ptr, input_len, offset);
            if offset >= input_len {
                return -1;
            };

            let value_start: i32 = offset;
            let mut value_end: i32 = value_start;
            loop {
                if value_end >= input_len {
                    return -1;
                };
                let value_byte: i32 = peek_byte(input_ptr, input_len, value_end);
                if value_byte == 59 {
                    break;
                };
                value_end = value_end + 1;
            };

            let mut trimmed_end: i32 = value_end;
            loop {
                if trimmed_end <= value_start {
                    break;
                };
                let last_byte: i32 = peek_byte(input_ptr, input_len, trimmed_end - 1);
                if last_byte < 0 {
                    return -1;
                };
                if !is_whitespace(last_byte) {
                    break;
                };
                trimmed_end = trimmed_end - 1;
            };
            if trimmed_end <= value_start {
                return -1;
            };

            let value_len: i32 = trimmed_end - value_start;
            let stored_value_start: i32 = load_i32(entry + 8);
            let stored_value_len: i32 = load_i32(entry + 12);
            if stored_value_start != value_start || stored_value_len != value_len {
                return -1;
            };

            offset = value_end + 1;
            compiled_type_index = compiled_type_index + 1;
            continue;
        };

        offset = expect_keyword_fn(input_ptr, input_len, offset);
        if offset < 0 {
            return -1;
        };

        if offset >= input_len {
            return -1;
        };
        let after_fn_byte: i32 = peek_byte(input_ptr, input_len, offset);
        if after_fn_byte < 0 || !is_whitespace(after_fn_byte) {
            return -1;
        };
        offset = skip_whitespace(input_ptr, input_len, offset);
        if offset >= input_len {
            return -1;
        };

        let name_start: i32 = offset;
        let mut name_len: i32 = 0;
        loop {
            if offset >= input_len {
                break;
            };
            let ch: i32 = peek_byte(input_ptr, input_len, offset);
            if name_len == 0 {
                if !is_identifier_start(ch) {
                    break;
                };
            } else if !is_identifier_continue(ch) {
                break;
            };
            name_len = name_len + 1;
            offset = offset + 1;
        };
        if name_len == 0 {
            return -1;
        };

        if compiled_index >= func_count {
            return -1;
        };
        let entry: i32 = functions_entry(functions_base, compiled_index);
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if stored_start != name_start || stored_len != name_len {
            return -1;
        };

        let is_main: bool = compiled_index == main_index;

        store_i32(locals_count_ptr, 0);
        store_i32(locals_max_ptr, 0);

        offset = skip_whitespace(input_ptr, input_len, offset);
        offset = expect_char(input_ptr, input_len, offset, 40);
        if offset < 0 {
            return -1;
        };

        let mut param_parse_idx: i32 = skip_whitespace(input_ptr, input_len, offset);
        let mut param_count: i32 = 0;
        let expected_param_count: i32 = load_i32(entry + 8);
        loop {
            if param_parse_idx >= input_len {
                return -1;
            };
            let next_byte: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
            if next_byte == 41 {
                param_parse_idx = param_parse_idx + 1;
                break;
            };

            let param_name_start: i32 = param_parse_idx;
            let mut param_name_len: i32 = 0;
            loop {
                if param_parse_idx >= input_len {
                    break;
                };
                let ch: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
                if param_name_len == 0 {
                    if !is_identifier_start(ch) {
                        break;
                    };
                } else if !is_identifier_continue(ch) {
                    break;
                };
                param_name_len = param_name_len + 1;
                param_parse_idx = param_parse_idx + 1;
            };
            if param_name_len == 0 {
                return -1;
            };

            let existing_param: i32 = locals_find(
                input_ptr,
                input_len,
                locals_base,
                locals_count_ptr,
                param_name_start,
                param_name_len,
            );
            if existing_param >= 0 {
                return -1;
            };

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            param_parse_idx = expect_char(input_ptr, input_len, param_parse_idx, 58);
            if param_parse_idx < 0 {
                return -1;
            };

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            if param_parse_idx >= input_len {
                return -1;
            };

            let mut param_type: i32 = type_code_i32();
            let mut matched_bool: bool = false;
            if param_parse_idx + 4 <= input_len {
                let b_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
                if b_char == 98 {
                    let o_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 1);
                    let o2_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 2);
                    let l_char: i32 = peek_byte(input_ptr, input_len, param_parse_idx + 3);
                    if o_char == 111 && o2_char == 111 && l_char == 108 {
                        let after_bool: i32 = param_parse_idx + 4;
                        if after_bool == input_len
                            || !is_identifier_continue(peek_byte(input_ptr, input_len, after_bool))
                        {
                            param_parse_idx = after_bool;
                            matched_bool = true;
                            param_type = type_code_bool();
                        };
                    };
                };
            };
            if !matched_bool {
                param_parse_idx = expect_keyword_i32(input_ptr, input_len, param_parse_idx);
                if param_parse_idx < 0 {
                    return -1;
                };
                param_type = type_code_i32();
            };

            locals_store_entry(
                locals_base,
                locals_count_ptr,
                param_name_start,
                param_name_len,
                param_count,
                false,
                param_type,
            );
            param_count = param_count + 1;

            param_parse_idx = skip_whitespace(input_ptr, input_len, param_parse_idx);
            if param_parse_idx >= input_len {
                return -1;
            };
            let delimiter: i32 = peek_byte(input_ptr, input_len, param_parse_idx);
            if delimiter == 44 {
                let mut after_comma: i32 =
                    skip_whitespace(input_ptr, input_len, param_parse_idx + 1);
                if after_comma >= input_len {
                    return -1;
                };
                let next_token: i32 = peek_byte(input_ptr, input_len, after_comma);
                if next_token == 41 {
                    param_parse_idx = after_comma + 1;
                    break;
                };
                param_parse_idx = after_comma;
                continue;
            };
            if delimiter == 41 {
                param_parse_idx = param_parse_idx + 1;
                break;
            };
            return -1;
        };

        store_i32(entry + 8, param_count);
        if param_count != expected_param_count {
            return -1;
        };
        offset = param_parse_idx;

        offset = skip_whitespace(input_ptr, input_len, offset);

        let expected_return: i32 = load_i32(entry + 24);
        let mut return_type: i32 = type_code_unit();
        let mut has_arrow: bool = false;
        if offset < input_len {
            let maybe_arrow: i32 = peek_byte(input_ptr, input_len, offset);
            if maybe_arrow == 45 {
                has_arrow = true;
                offset = expect_char(input_ptr, input_len, offset, 45);
                if offset < 0 {
                    return -1;
                };
                offset = expect_char(input_ptr, input_len, offset, 62);
                if offset < 0 {
                    return -1;
                };
                offset = skip_whitespace(input_ptr, input_len, offset);

                let mut matched_return: bool = false;
                if offset + 4 <= input_len {
                    let b_char: i32 = peek_byte(input_ptr, input_len, offset);
                    if b_char == 98 {
                        let o_char: i32 = peek_byte(input_ptr, input_len, offset + 1);
                        let o2_char: i32 = peek_byte(input_ptr, input_len, offset + 2);
                        let l_char: i32 = peek_byte(input_ptr, input_len, offset + 3);
                        if o_char == 111 && o2_char == 111 && l_char == 108 {
                            let after_bool: i32 = offset + 4;
                            if after_bool == input_len
                                || !is_identifier_continue(peek_byte(input_ptr, input_len, after_bool))
                            {
                                offset = after_bool;
                                matched_return = true;
                                return_type = type_code_bool();
                            };
                        };
                    };
                };
                if !matched_return {
                    offset = expect_keyword_i32(input_ptr, input_len, offset);
                    if offset < 0 {
                        return -1;
                    };
                    return_type = type_code_i32();
                };
            };
        };
        if !has_arrow {
            if expected_return != type_code_unit() {
                return -1;
            };
            return_type = type_code_unit();
        };
        if return_type != expected_return {
            return -1;
        };
        if is_main {
            if return_type != type_code_i32() {
                return -1;
            };
        };

        store_i32(current_return_type_ptr, expected_return);

        if offset < input_len {
            let after_type: i32 = peek_byte(input_ptr, input_len, offset);
            if after_type != 123 && !is_whitespace(after_type) {
                return -1;
            };
        };
        offset = skip_whitespace(input_ptr, input_len, offset);
        offset = expect_char(input_ptr, input_len, offset, 123);
        if offset < 0 {
            return -1;
        };

        store_i32(control_stack_count_ptr, 0);

        let start_instr: i32 = load_i32(instr_offset_ptr);
        let mut current_offset: i32 = offset;

        loop {
            current_offset = skip_whitespace(input_ptr, input_len, current_offset);
            if current_offset >= input_len {
                return -1;
            };

            let current_byte: i32 = peek_byte(input_ptr, input_len, current_offset);
            if current_byte == 125 {
                current_offset = current_offset + 1;
                break;
            };

            let prev_instr_offset: i32 = load_i32(instr_offset_ptr);
            let stmt_offset: i32 = parse_statement(
                input_ptr,
                input_len,
                current_offset,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr,
                0,
            );
            if stmt_offset >= 0 {
                current_offset = stmt_offset;
                continue;
            };

            if stmt_offset != -1 {
                return -1;
            };

            store_i32(instr_offset_ptr, prev_instr_offset);

            let expr_offset: i32 = parse_expression(
                input_ptr,
                input_len,
                current_offset,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr,
                control_stack_base,
                control_stack_count_ptr,
                functions_base,
                functions_count_ptr,
                expr_type_ptr,
            );
            if expr_offset < 0 {
                return -1;
            };
            let mut after_expr: i32 = skip_whitespace(input_ptr, input_len, expr_offset);
            after_expr = expect_char(input_ptr, input_len, after_expr, 125);
            if after_expr < 0 {
                return -1;
            };
            current_offset = after_expr;
            break;
        };

        offset = current_offset;

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_end(instr_base, instr_offset);
        store_i32(instr_offset_ptr, instr_offset);

        let end_instr: i32 = load_i32(instr_offset_ptr);
        let code_len: i32 = end_instr - start_instr;
        store_i32(entry + 12, start_instr);
        store_i32(entry + 16, code_len);

        let total_locals: i32 = load_i32(locals_max_ptr);
        if total_locals < param_count {
            return -1;
        };
        let local_count: i32 = total_locals - param_count;
        store_i32(entry + 20, local_count);

        compiled_index = compiled_index + 1;
    };

    offset = skip_whitespace(input_ptr, input_len, offset);
    if offset != input_len {
        return -1;
    };
    if compiled_index != func_count {
        return -1;
    };

    write_module(
        out_ptr,
        instr_base,
        functions_base,
        func_count,
        input_ptr,
        input_len,
    )
}

fn main() -> i32 {
    0
}
