use "./ast_compiler_base_lexing.bp";
use "./ast_compiler_base_state.bp";

fn unsigned_divide(dividend: i32, divisor: i32) -> i32 {
    let mut quotient: i32 = 0;
    let mut remainder: i32 = 0;
    let mut shift: i32 = 31;
    loop {
        if shift < 0 {
            break;
        }
        remainder = remainder << 1;
        let next_bit: i32 = logical_shr(dividend, shift) & 1;
        remainder = remainder | next_bit;
        if compare_unsigned(remainder, divisor) >= 0 {
            remainder = remainder - divisor;
            quotient = quotient | (1 << shift);
        }
        shift = shift - 1;
    };
    quotient
}

fn constant_value_requires_deep_copy(type_id: i32) -> bool {
    if type_id < 0 {
        return false;
    }
    if type_id_is_array(type_id) {
        return true;
    }
    if type_id_is_tuple(type_id) {
        return true;
    }
    false
}

fn clone_constant_value_elements(ast_base: i32, value: i32, element_count: i32) -> i32 {
    if element_count < 0 {
        return -1;
    }
    if element_count == 0 {
        return value;
    }
    if value <= 0 {
        return -1;
    }
    let clone_ptr: i32 = ast_call_data_alloc(ast_base, element_count * 2);
    if clone_ptr < 0 {
        return -1;
    }
    let mut idx: i32 = 0;
    while idx < element_count {
        let source_slot: i32 = value + idx * 2 * WORD_SIZE;
        let source_value: i32 = load_i32(source_slot);
        let source_type: i32 = load_i32(source_slot + WORD_SIZE);
        if source_type < 0 {
            return -1;
        }
        let stored_value: i32 = if constant_value_requires_deep_copy(source_type) {
            let nested_clone: i32 = clone_constant_value_deep(ast_base, source_value, source_type);
            if nested_clone < 0 {
                return -1;
            }
            nested_clone
        } else {
            source_value
        };
        store_i32(clone_ptr + idx * 2 * WORD_SIZE, stored_value);
        store_i32(clone_ptr + idx * 2 * WORD_SIZE + WORD_SIZE, source_type);
        idx = idx + 1;
    };
    clone_ptr
}

fn clone_constant_value_deep(ast_base: i32, value: i32, type_id: i32) -> i32 {
    if type_id < 0 {
        return -1;
    }
    if type_id_is_array(type_id) {
        let length: i32 = array_type_length(ast_base, type_id);
        return clone_constant_value_elements(ast_base, value, length);
    }
    if type_id_is_tuple(type_id) {
        let tuple_index: i32 = tuple_type_index(type_id);
        if tuple_index < 0 {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_index);
        return clone_constant_value_elements(ast_base, value, element_count);
    }
    value
}

fn evaluate_integer_binary_operation(
    ast_base: i32,
    expr_index: i32,
    kind: i32,
    entry_ptr: i32,
    scratch_base: i32,
    scratch_top_ptr: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
    param_values_ptr: i32,
    param_count: i32,
    env_values_count: i32,
    saved_top: i32,
) -> i32 {
    let left_index: i32 = load_i32(entry_ptr + 4);
    let right_index: i32 = load_i32(entry_ptr + 8);
    let left_offset: i32 = load_i32(scratch_top_ptr);
    let left_value_ptr: i32 = scratch_base + left_offset;
    let left_type_ptr: i32 = left_value_ptr + WORD_SIZE;
    store_i32(scratch_top_ptr, left_offset + 2 * WORD_SIZE);
    let left_status: i32 = interpret_constant_expression(
        ast_base,
        left_index,
        scratch_base,
        scratch_top_ptr,
        left_value_ptr,
        left_type_ptr,
        param_values_ptr,
        param_count,
        env_values_count,
    );
    if left_status < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if left_status != CONST_EVAL_STATUS_OK {
        store_i32(scratch_top_ptr, saved_top);
        return left_status;
    }
    let right_offset: i32 = load_i32(scratch_top_ptr);
    let right_value_ptr: i32 = scratch_base + right_offset;
    let right_type_ptr: i32 = right_value_ptr + WORD_SIZE;
    store_i32(scratch_top_ptr, right_offset + 2 * WORD_SIZE);
    let right_status: i32 = interpret_constant_expression(
        ast_base,
        right_index,
        scratch_base,
        scratch_top_ptr,
        right_value_ptr,
        right_type_ptr,
        param_values_ptr,
        param_count,
        env_values_count,
    );
    if right_status < 0 {
        store_i32(scratch_top_ptr, saved_top);
        return -1;
    }
    if right_status != CONST_EVAL_STATUS_OK {
        store_i32(scratch_top_ptr, saved_top);
        return right_status;
    }
    let left_type: i32 = load_i32(left_type_ptr);
    let right_type: i32 = load_i32(right_type_ptr);
    let is_comparison: bool = kind >= 14 && kind <= 19;
    let mut target_type: i32 = -1;
    if is_comparison {
        if ast_expr_type(ast_base, expr_index) != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
    } else {
        target_type = ast_expr_type(ast_base, expr_index);
    }
    if target_type >= 0 {
        if !constant_eval_integer_type_supported(target_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if left_type != target_type {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if right_type != target_type {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
    } else {
        if left_type != right_type {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if !constant_eval_integer_type_supported(left_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        target_type = left_type;
    }
    let left_value: i32 = normalize_integer_value(load_i32(left_value_ptr), target_type);
    let right_value: i32 = normalize_integer_value(load_i32(right_value_ptr), target_type);
    if is_comparison {
        let mut bool_result: i32 = 0;
        if kind == 14 {
            bool_result = if left_value == right_value { 1 } else { 0 };
        } else if kind == 15 {
            bool_result = if left_value != right_value { 1 } else { 0 };
        } else {
            let signed: bool = type_id_is_signed_integer(target_type);
            if kind == 16 {
                if signed {
                    bool_result = if left_value < right_value { 1 } else { 0 };
                } else {
                    let cmp: i32 = compare_unsigned(left_value, right_value);
                    bool_result = if cmp < 0 { 1 } else { 0 };
                }
            } else if kind == 17 {
                if signed {
                    bool_result = if left_value > right_value { 1 } else { 0 };
                } else {
                    let cmp: i32 = compare_unsigned(left_value, right_value);
                    bool_result = if cmp > 0 { 1 } else { 0 };
                }
            } else if kind == 18 {
                if signed {
                    bool_result = if left_value <= right_value { 1 } else { 0 };
                } else {
                    let cmp: i32 = compare_unsigned(left_value, right_value);
                    bool_result = if cmp <= 0 { 1 } else { 0 };
                }
            } else {
                if signed {
                    bool_result = if left_value >= right_value { 1 } else { 0 };
                } else {
                    let cmp: i32 = compare_unsigned(left_value, right_value);
                    bool_result = if cmp >= 0 { 1 } else { 0 };
                }
            }
        }
        store_i32(out_value_ptr, bool_result);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    let mut computed: i32 = 0;
    if kind == 2 {
        computed = left_value + right_value;
    } else if kind == 3 {
        computed = left_value - right_value;
    } else if kind == 4 {
        computed = left_value * right_value;
    } else if kind == 5 {
        if right_value == 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if type_id_is_signed_integer(target_type) {
            computed = left_value / right_value;
        } else {
            computed = unsigned_divide(left_value, right_value);
        }
    } else if kind == 25 {
        computed = left_value | right_value;
    } else if kind == 26 {
        computed = left_value & right_value;
    } else if kind == 27 {
        let shift_amount: i32 = right_value & 31;
        computed = left_value << shift_amount;
    } else {
        let shift_amount: i32 = right_value & 31;
        if type_id_is_signed_integer(target_type) {
            computed = left_value >> shift_amount;
        } else {
            computed = logical_shr(left_value, shift_amount);
        }
    }
    let normalized: i32 = normalize_integer_value(computed, target_type);
    store_i32(out_value_ptr, normalized);
    store_i32(out_type_ptr, target_type);
    store_i32(scratch_top_ptr, saved_top);
    CONST_EVAL_STATUS_OK
}

fn interpret_constant_expression(
    ast_base: i32,
    expr_index: i32,
    scratch_base: i32,
    scratch_top_ptr: i32,
    out_value_ptr: i32,
    out_type_ptr: i32,
    param_values_ptr: i32,
    param_count: i32,
    env_values_count: i32,
) -> i32 {
    if expr_index < 0 {
        return -1;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let mut kind: i32 = load_i32(entry_ptr);
    let saved_top: i32 = load_i32(scratch_top_ptr);
    if kind == 43 {
        if resolve_constant_reference(ast_base, expr_index) < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        kind = load_i32(entry_ptr);
    }
    store_i32(CONST_EVAL_DEBUG_EXPR_OFFSET, expr_index);
    store_i32(CONST_EVAL_DEBUG_KIND_OFFSET, kind);
    store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 0);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(out_value_ptr, value);
        store_i32(out_type_ptr, expr_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 6 {
        if param_count <= 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if param_values_ptr < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if param_index >= param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if param_index >= env_values_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let env_ptr: i32 = param_values_ptr + param_index * 8;
        let value: i32 = load_i32(env_ptr);
        let value_type: i32 = load_i32(env_ptr + 4);
        if value_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            ast_expr_set_type(ast_base, expr_index, value_type);
            expr_type = value_type;
        }
        if value_type != expr_type {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(out_value_ptr, value);
        store_i32(out_type_ptr, value_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if condition_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if then_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if else_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let cond_offset: i32 = load_i32(scratch_top_ptr);
        let cond_value_ptr: i32 = scratch_base + cond_offset;
        let cond_type_ptr: i32 = cond_value_ptr + 4;
        store_i32(scratch_top_ptr, cond_offset + 8);
        let cond_status: i32 = interpret_constant_expression(
            ast_base,
            condition_index,
            scratch_base,
            scratch_top_ptr,
            cond_value_ptr,
            cond_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if cond_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if cond_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if load_i32(cond_type_ptr) != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let cond_bool: i32 = if load_i32(cond_value_ptr) != 0 { 1 } else { 0 };
        store_i32(scratch_top_ptr, cond_offset);
        let branch_index: i32 = if cond_bool != 0 { then_index } else { else_index };
        let branch_status: i32 = interpret_constant_expression(
            ast_base,
            branch_index,
            scratch_base,
            scratch_top_ptr,
            out_value_ptr,
            out_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if branch_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if branch_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return branch_status;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        let branch_type: i32 = load_i32(out_type_ptr);
        if expr_type >= 0 && branch_type >= 0 {
            if expr_type != branch_type {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 8 {
        store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 800);
        if param_values_ptr < 0 {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 801);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if env_values_count <= 0 {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 802);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let local_index: i32 = load_i32(entry_ptr + 4);
        store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 803);
        store_i32(CONST_EVAL_DEBUG_LOCAL_OFFSET, local_index);
        if local_index < 0 {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 804);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if local_index < param_count {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 805);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if local_index >= env_values_count {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 806);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let slot_ptr: i32 = param_values_ptr + local_index * 8;
        let value_type_ptr: i32 = slot_ptr + 4;
        let mut value: i32 = load_i32(slot_ptr);
        let mut value_type: i32 = load_i32(value_type_ptr);
        store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 807);
        if value_type < 0 {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 808);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 809);
        let mut effective_expr_type: i32 = expr_type;
        if effective_expr_type < 0 {
            ast_expr_set_type(ast_base, expr_index, value_type);
            effective_expr_type = value_type;
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 810);
        }
        if value_type != effective_expr_type {
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 811);
            let converted_type: i32 =
                convert_constant_value(ast_base, slot_ptr, value_type, effective_expr_type);
            if converted_type < 0 {
                store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 812);
                ast_expr_set_type(ast_base, expr_index, value_type);
                store_i32(out_value_ptr, load_i32(slot_ptr));
                store_i32(out_type_ptr, value_type);
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
            value_type = converted_type;
            value = load_i32(slot_ptr);
            store_i32(value_type_ptr, value_type);
            store_i32(CONST_EVAL_DEBUG_STEP_OFFSET, 813);
        }
        store_i32(out_value_ptr, value);
        store_i32(out_type_ptr, value_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        if element_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let element_offset: i32 = load_i32(scratch_top_ptr);
        let element_value_ptr: i32 = scratch_base + element_offset;
        let element_type_ptr: i32 = element_value_ptr + 4;
        store_i32(scratch_top_ptr, element_offset + 8);
        let element_status: i32 = interpret_constant_expression(
            ast_base,
            element_index,
            scratch_base,
            scratch_top_ptr,
            element_value_ptr,
            element_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if element_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if element_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut element_type: i32 = load_i32(element_type_ptr);
        let mut element_value: i32 = load_i32(element_value_ptr);
        let mut length: i32 = ast_expr_array_repeat_length(ast_base, expr_index);
        if length < 0 {
            let length_expr_index: i32 =
                ast_expr_array_repeat_length_expr(ast_base, expr_index);
            if length_expr_index < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let length_offset: i32 = load_i32(scratch_top_ptr);
            let length_value_ptr: i32 = scratch_base + length_offset;
            let length_type_ptr: i32 = length_value_ptr + 4;
            store_i32(scratch_top_ptr, length_offset + 8);
            let length_status: i32 = interpret_constant_expression(
                ast_base,
                length_expr_index,
                scratch_base,
                scratch_top_ptr,
                length_value_ptr,
                length_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if length_status < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if length_status != CONST_EVAL_STATUS_OK {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let length_type: i32 = load_i32(length_type_ptr);
            if !constant_eval_integer_type_supported(length_type) {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let length_value: i32 = load_i32(length_value_ptr);
            let normalized_length: i32 =
                normalize_integer_value(length_value, length_type);
            if normalized_length < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            length = normalized_length;
        }
        if length < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(scratch_top_ptr, element_offset);
        let expr_result_type: i32 = ast_expr_type(ast_base, expr_index);
        store_i32(CONST_ARRAY_DEBUG_EXPR_TYPE_OFFSET, expr_result_type);
        store_i32(CONST_ARRAY_DEBUG_ELEMENT_TYPE_OFFSET, element_type);
        store_i32(CONST_ARRAY_DEBUG_ENV_COUNT_OFFSET, env_values_count);
        store_i32(CONST_ARRAY_DEBUG_PARAM_COUNT_OFFSET, param_count);
        if element_type == BUILTIN_TYPE_ID_TYPE {
            let mut treat_as_type_expr: bool = true;
            if env_values_count > param_count {
                treat_as_type_expr = false;
            } else if expr_result_type >= 0 {
                if expr_result_type == BUILTIN_TYPE_ID_TYPE {
                    treat_as_type_expr = true;
                } else if type_id_is_array(expr_result_type) {
                    let expected_element: i32 =
                        array_type_element_type(ast_base, expr_result_type);
                    if expected_element < 0 {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    if type_id_contains_only_type_values(ast_base, expected_element) {
                        treat_as_type_expr = true;
                    } else {
                        treat_as_type_expr = false;
                    }
                } else {
                    treat_as_type_expr = false;
                }
            }
            store_i32(
                CONST_ARRAY_DEBUG_TREAT_AS_TYPE_OFFSET,
                if treat_as_type_expr { 1 } else { 0 },
            );
            if treat_as_type_expr {
                if element_value < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                let array_type_id: i32 =
                    ast_register_array_type(ast_base, element_value, length);
                if array_type_id < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                store_i32(out_value_ptr, array_type_id);
                store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
        } else {
            store_i32(CONST_ARRAY_DEBUG_TREAT_AS_TYPE_OFFSET, 0);
        }
        let mut array_type_id: i32 = expr_result_type;
        if array_type_id < 0 || !type_id_is_array(array_type_id) {
            if element_type < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let registered: i32 =
                ast_register_array_type(ast_base, element_type, length);
            if registered < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            array_type_id = registered;
        }
        let expected_element: i32 =
            array_type_element_type(ast_base, array_type_id);
        if expected_element < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if element_type != expected_element {
            let converted_element: i32 = convert_constant_value(
                ast_base,
                element_value_ptr,
                element_type,
                expected_element,
            );
            if converted_element < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            element_type = converted_element;
            element_value = load_i32(element_value_ptr);
            store_i32(element_type_ptr, element_type);
        }
        let expected_length: i32 = array_type_length(ast_base, array_type_id);
        if expected_length < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if expected_length != length {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let pair_words: i32 = if length > 0 { length * 2 } else { 0 };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let pair_storage_ptr: i32 = if pair_words > 0 {
            ast_call_data_alloc(ast_base, pair_words)
        } else {
            0
        };
        if pair_words > 0 {
            if pair_storage_ptr < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let mut idx: i32 = 0;
        while idx < length {
            let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
            let mut stored_value: i32 = element_value;
            if constant_value_requires_deep_copy(element_type) {
                let cloned_value: i32 = clone_constant_value_deep(
                    ast_base,
                    element_value,
                    element_type,
                );
                if cloned_value < 0 {
                    store_i32(call_data_used_ptr, saved_used);
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                stored_value = cloned_value;
            }
            store_i32(slot_ptr, stored_value);
            store_i32(slot_ptr + WORD_SIZE, element_type);
            idx = idx + 1;
        };
        if pair_words == 0 {
            store_i32(out_value_ptr, 0);
        } else {
            store_i32(out_value_ptr, pair_storage_ptr);
        }
        ast_expr_set_type(ast_base, expr_index, array_type_id);
        store_i32(out_type_ptr, array_type_id);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let array_offset: i32 = load_i32(scratch_top_ptr);
        let array_value_ptr: i32 = scratch_base + array_offset;
        let array_type_ptr: i32 = array_value_ptr + 4;
        store_i32(scratch_top_ptr, array_offset + 8);
        let array_status: i32 = interpret_constant_expression(
            ast_base,
            array_index,
            scratch_base,
            scratch_top_ptr,
            array_value_ptr,
            array_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        store_i32(scratch_top_ptr, array_offset);
        if array_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if array_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return array_status;
        }
        let array_type: i32 = load_i32(array_type_ptr);
        if array_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if !type_id_is_array(array_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let array_length: i32 = array_type_length(ast_base, array_type);
        if array_length < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let array_data_ptr: i32 = load_i32(array_value_ptr);
        let index_offset: i32 = load_i32(scratch_top_ptr);
        let index_value_ptr: i32 = scratch_base + index_offset;
        let index_type_ptr: i32 = index_value_ptr + 4;
        store_i32(scratch_top_ptr, index_offset + 8);
        let index_status: i32 = interpret_constant_expression(
            ast_base,
            index_index,
            scratch_base,
            scratch_top_ptr,
            index_value_ptr,
            index_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        store_i32(scratch_top_ptr, index_offset);
        if index_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if index_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return index_status;
        }
        let index_type: i32 = load_i32(index_type_ptr);
        if index_type != BUILTIN_TYPE_ID_I32 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let raw_index: i32 = load_i32(index_value_ptr);
        let normalized_index: i32 = normalize_integer_value(raw_index, index_type);
        if normalized_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if normalized_index >= array_length {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if array_length > 0 {
            if array_data_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let slot_ptr: i32 = array_data_ptr + normalized_index * 2 * WORD_SIZE;
        let element_value: i32 = load_i32(slot_ptr);
        let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
        if element_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let expected_element: i32 = array_type_element_type(ast_base, array_type);
        if expected_element < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if element_type != expected_element {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(out_value_ptr, element_value);
        store_i32(out_type_ptr, element_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if array_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let index_index: i32 = load_i32(entry_ptr + 8);
        if index_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 12);
        if value_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let array_offset: i32 = load_i32(scratch_top_ptr);
        let array_value_ptr: i32 = scratch_base + array_offset;
        let array_type_ptr: i32 = array_value_ptr + 4;
        store_i32(scratch_top_ptr, array_offset + 8);
        let array_status: i32 = interpret_constant_expression(
            ast_base,
            array_index,
            scratch_base,
            scratch_top_ptr,
            array_value_ptr,
            array_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if array_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if array_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return array_status;
        }
        let array_type: i32 = load_i32(array_type_ptr);
        if array_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if !type_id_is_array(array_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let array_length: i32 = array_type_length(ast_base, array_type);
        if array_length < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let array_data_ptr: i32 = load_i32(array_value_ptr);
        if array_length > 0 {
            if array_data_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        store_i32(scratch_top_ptr, array_offset);
        let index_offset: i32 = load_i32(scratch_top_ptr);
        let index_value_ptr: i32 = scratch_base + index_offset;
        let index_type_ptr: i32 = index_value_ptr + 4;
        store_i32(scratch_top_ptr, index_offset + 8);
        let index_status: i32 = interpret_constant_expression(
            ast_base,
            index_index,
            scratch_base,
            scratch_top_ptr,
            index_value_ptr,
            index_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        store_i32(scratch_top_ptr, index_offset);
        if index_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if index_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return index_status;
        }
        let index_type: i32 = load_i32(index_type_ptr);
        if index_type != BUILTIN_TYPE_ID_I32 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let raw_index: i32 = load_i32(index_value_ptr);
        let normalized_index: i32 = normalize_integer_value(raw_index, index_type);
        if normalized_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if normalized_index >= array_length {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        let mut value_type: i32 = load_i32(value_type_ptr);
        let mut value_value: i32 = load_i32(value_ptr);
        store_i32(scratch_top_ptr, value_offset);
        let expected_element: i32 = array_type_element_type(ast_base, array_type);
        if expected_element < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_type != expected_element {
            let converted_type: i32 = convert_constant_value(
                ast_base,
                value_ptr,
                value_type,
                expected_element,
            );
            if converted_type < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            value_type = converted_type;
            value_value = load_i32(value_ptr);
            store_i32(value_type_ptr, value_type);
        }
        let slot_ptr: i32 = array_data_ptr + normalized_index * 2 * WORD_SIZE;
        store_i32(slot_ptr, value_value);
        store_i32(slot_ptr + WORD_SIZE, value_type);
        store_i32(out_value_ptr, value_value);
        store_i32(out_type_ptr, value_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if element_count > 0 && values_ptr <= 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let pair_words: i32 = if element_count > 0 { element_count * 2 } else { 0 };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let pair_storage_ptr: i32 = if pair_words > 0 {
            ast_call_data_alloc(ast_base, pair_words)
        } else {
            0
        };
        if pair_words > 0 {
            if pair_storage_ptr < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let mut idx: i32 = 0;
        let mut element_type: i32 = -1;
        while idx < element_count {
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_offset: i32 = load_i32(scratch_top_ptr);
            let element_value_ptr: i32 = scratch_base + element_offset;
            let element_type_ptr: i32 = element_value_ptr + 4;
            store_i32(scratch_top_ptr, element_offset + 8);
            let element_status: i32 = interpret_constant_expression(
                ast_base,
                value_index,
                scratch_base,
                scratch_top_ptr,
                element_value_ptr,
                element_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if element_status < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if element_status != CONST_EVAL_STATUS_OK {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return element_status;
            }
            let current_type: i32 = load_i32(element_type_ptr);
            if current_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let current_value: i32 = load_i32(element_value_ptr);
            if pair_storage_ptr > 0 {
                let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
                store_i32(slot_ptr, current_value);
                store_i32(slot_ptr + WORD_SIZE, current_type);
            }
            if element_type < 0 {
                element_type = current_type;
            } else if current_type != element_type {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            store_i32(scratch_top_ptr, element_offset);
            idx = idx + 1;
        };
        if element_type < 0 {
            let recorded_array: i32 = ast_expr_type(ast_base, expr_index);
            if recorded_array >= 0 && type_id_is_array(recorded_array) {
                element_type = array_type_element_type(ast_base, recorded_array);
            }
            if element_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let mut array_type_id: i32 = ast_expr_type(ast_base, expr_index);
        if array_type_id < 0 || !type_id_is_array(array_type_id) {
            if element_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let registered: i32 =
                ast_register_array_type(ast_base, element_type, element_count);
            if registered < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            array_type_id = registered;
        }
        let expected_element: i32 = array_type_element_type(ast_base, array_type_id);
        if expected_element < 0 {
            store_i32(call_data_used_ptr, saved_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if expected_element != element_type {
            let mut fix_idx: i32 = 0;
            while fix_idx < element_count {
                let slot_ptr: i32 = pair_storage_ptr + fix_idx * 2 * WORD_SIZE;
                let current_type: i32 = load_i32(slot_ptr + WORD_SIZE);
                let converted_element: i32 = convert_constant_value(
                    ast_base,
                    slot_ptr,
                    current_type,
                    expected_element,
                );
                if converted_element < 0 {
                    store_i32(call_data_used_ptr, saved_used);
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                store_i32(slot_ptr + WORD_SIZE, converted_element);
                fix_idx = fix_idx + 1;
            };
            element_type = expected_element;
        }
        let expected_length: i32 = array_type_length(ast_base, array_type_id);
        if expected_length < 0 {
            store_i32(call_data_used_ptr, saved_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if expected_length != element_count {
            store_i32(call_data_used_ptr, saved_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if pair_words == 0 {
            store_i32(out_value_ptr, 0);
        } else {
            store_i32(out_value_ptr, pair_storage_ptr);
        }
        store_i32(out_type_ptr, array_type_id);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_offset: i32 = load_i32(scratch_top_ptr);
        let tuple_value_ptr: i32 = scratch_base + tuple_offset;
        let tuple_type_ptr: i32 = tuple_value_ptr + 4;
        store_i32(scratch_top_ptr, tuple_offset + 8);
        let tuple_status: i32 = interpret_constant_expression(
            ast_base,
            tuple_index,
            scratch_base,
            scratch_top_ptr,
            tuple_value_ptr,
            tuple_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        store_i32(scratch_top_ptr, tuple_offset);
        if tuple_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if tuple_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return tuple_status;
        }
        let tuple_type: i32 = load_i32(tuple_type_ptr);
        if tuple_type == BUILTIN_TYPE_ID_TYPE {
            let tuple_type_id: i32 = load_i32(tuple_value_ptr);
            if tuple_type_id < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if !type_id_is_tuple(tuple_type_id) {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let tuple_idx: i32 = tuple_type_index(tuple_type_id);
            if tuple_idx < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if tuple_idx >= ast_tuple_types_count(ast_base) {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
            if field_index >= element_count {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
            if elements_ptr < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let element_type: i32 = load_i32(elements_ptr + field_index * WORD_SIZE);
            if element_type < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            store_i32(out_value_ptr, element_type);
            store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
            store_i32(scratch_top_ptr, saved_top);
            return CONST_EVAL_STATUS_OK;
        }
        if !type_id_is_tuple(tuple_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_idx: i32 = tuple_type_index(tuple_type);
        if tuple_idx < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if field_index >= element_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_data_ptr: i32 = load_i32(tuple_value_ptr);
        let slot_ptr: i32 = tuple_data_ptr + field_index * 2 * WORD_SIZE;
        let element_value: i32 = load_i32(slot_ptr);
        let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
        if element_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(out_value_ptr, element_value);
        store_i32(out_type_ptr, element_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        if tuple_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 12);
        if value_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_offset: i32 = load_i32(scratch_top_ptr);
        let tuple_value_ptr: i32 = scratch_base + tuple_offset;
        let tuple_type_ptr: i32 = tuple_value_ptr + 4;
        store_i32(scratch_top_ptr, tuple_offset + 8);
        let tuple_status: i32 = interpret_constant_expression(
            ast_base,
            tuple_index,
            scratch_base,
            scratch_top_ptr,
            tuple_value_ptr,
            tuple_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if tuple_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if tuple_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return tuple_status;
        }
        let tuple_type: i32 = load_i32(tuple_type_ptr);
        if !type_id_is_tuple(tuple_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_idx: i32 = tuple_type_index(tuple_type);
        if tuple_idx < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if field_index >= element_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let tuple_data_ptr: i32 = load_i32(tuple_value_ptr);
        if element_count > 0 {
            if tuple_data_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        store_i32(scratch_top_ptr, tuple_offset);
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        let mut value_type: i32 = load_i32(value_type_ptr);
        let mut value_value: i32 = load_i32(value_ptr);
        store_i32(scratch_top_ptr, value_offset);
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let expected_type: i32 = load_i32(elements_ptr + field_index * WORD_SIZE);
        if expected_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_type != expected_type {
            let converted_type: i32 = convert_constant_value(
                ast_base,
                value_ptr,
                value_type,
                expected_type,
            );
            if converted_type < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            value_type = converted_type;
            value_value = load_i32(value_ptr);
            store_i32(value_type_ptr, value_type);
        }
        let slot_ptr: i32 = tuple_data_ptr + field_index * 2 * WORD_SIZE;
        store_i32(slot_ptr, value_value);
        store_i32(slot_ptr + WORD_SIZE, value_type);
        store_i32(out_value_ptr, value_value);
        store_i32(out_type_ptr, value_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if array_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut length: i32 = -1;
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type >= 0 {
            length = array_type_length(ast_base, array_type);
        }
        if length < 0 {
            let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
            let array_kind: i32 = load_i32(array_entry_ptr);
            if array_kind == 35 {
                let stored_length: i32 = ast_expr_array_repeat_length(ast_base, array_index);
                if stored_length >= 0 {
                    length = stored_length;
                } else {
                    let length_expr_index: i32 =
                        ast_expr_array_repeat_length_expr(ast_base, array_index);
                    if length_expr_index < 0 {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    let length_offset: i32 = load_i32(scratch_top_ptr);
                    let length_value_ptr: i32 = scratch_base + length_offset;
                    let length_type_ptr: i32 = length_value_ptr + 4;
                    store_i32(scratch_top_ptr, length_offset + 8);
                    let length_status: i32 = interpret_constant_expression(
                        ast_base,
                        length_expr_index,
                        scratch_base,
                        scratch_top_ptr,
                        length_value_ptr,
                        length_type_ptr,
                        param_values_ptr,
                        param_count,
                        env_values_count,
                    );
                    store_i32(scratch_top_ptr, length_offset);
                    if length_status < 0 {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    if length_status != CONST_EVAL_STATUS_OK {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    let length_type: i32 = load_i32(length_type_ptr);
                    if !constant_eval_integer_type_supported(length_type) {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    let raw_length: i32 = load_i32(length_value_ptr);
                    let normalized_length: i32 =
                        normalize_integer_value(raw_length, length_type);
                    if normalized_length < 0 {
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    length = normalized_length;
                }
            } else if array_kind == 37 {
                length = load_i32(array_entry_ptr + 2 * WORD_SIZE);
            }
        }
        if length < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(out_value_ptr, length);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_I32);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index == CALL_METADATA_INTRINSIC_STRUCT {
            let intrinsic_status: i32 = evaluate_struct_intrinsic(
                ast_base,
                metadata_ptr,
                scratch_base,
                scratch_top_ptr,
                saved_top,
                out_value_ptr,
                out_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            return intrinsic_status;
        }
        if callee_index < 0 {
            let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
            let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
            let mut struct_match: bool = false;
            if call_name_len == 6 {
                let literal: [u8; 6] = "struct";
                let mut match_idx: i32 = 0;
                loop {
                    if match_idx >= 6 {
                        break;
                    }
                    let stored: i32 = if call_name_ptr > 0 {
                        load_u8(call_name_ptr + match_idx)
                    } else {
                        literal[match_idx] as i32
                    };
                    let expected: i32 = literal[match_idx] as i32;
                    if stored != expected {
                        match_idx = -1;
                        break;
                    }
                    match_idx = match_idx + 1;
                };
                if match_idx == 6 {
                    struct_match = true;
                }
            }
            if struct_match {
                let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
                if arg_count != 3 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                store_i32(
                    call_metadata_callee_index_ptr(metadata_ptr),
                    CALL_METADATA_INTRINSIC_STRUCT,
                );
                let intrinsic_status: i32 = evaluate_struct_intrinsic(
                    ast_base,
                    metadata_ptr,
                    scratch_base,
                    scratch_top_ptr,
                    saved_top,
                    out_value_ptr,
                    out_type_ptr,
                    param_values_ptr,
                    param_count,
                    env_values_count,
                );
                return intrinsic_status;
            }
            if call_name_ptr < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let total_functions: i32 = load_i32(ast_functions_count_ptr(ast_base));
            let mut search_idx: i32 = 0;
            let mut found_index: i32 = -1;
            while search_idx < total_functions {
                let search_entry_ptr: i32 = ast_function_entry_ptr(ast_base, search_idx);
                let search_name_ptr: i32 = load_i32(search_entry_ptr);
                let search_name_len: i32 = load_i32(search_entry_ptr + 4);
                if identifiers_match(call_name_ptr, call_name_len, search_name_ptr, search_name_len) {
                    found_index = search_idx;
                    break;
                }
                search_idx = search_idx + 1;
            };
            if found_index < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            callee_index = found_index;
        }
        if callee_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let template_index: i32 = callee_index;
        if !ast_function_is_const(ast_base, template_index) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        if arg_count < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        if arg_count > 0 {
            if args_base < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let has_const_params: bool = ast_function_has_const_params(ast_base, template_index);
        if has_const_params {
            if collect_call_const_arguments(
                0,
                ast_base,
                metadata_ptr,
                template_index,
                arg_count,
                -1,
                -1,
            ) < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let env_ptr: i32 = call_metadata_const_env_ptr(metadata_ptr);
            if env_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let mut resolved_index: i32 = template_index;
        if has_const_params {
            let key_ptr: i32 = call_metadata_const_key_ptr(metadata_ptr);
            if key_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let existing_specialization: i32 = ast_function_find_const_specialization(
                ast_base,
                template_index,
                key_ptr,
            );
            if existing_specialization >= 0 {
                resolved_index = existing_specialization;
            } else {
                let new_specialization: i32 = ast_function_clone_const_template(
                    ast_base,
                    template_index,
                    key_ptr,
                    0,
                    -1,
                    -1,
                );
                if new_specialization < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                if ast_function_register_const_specialization(
                    ast_base,
                    template_index,
                    key_ptr,
                    new_specialization,
                ) < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                resolved_index = new_specialization;
            }
        }
        if !ast_function_is_const(ast_base, resolved_index) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(call_metadata_callee_index_ptr(metadata_ptr), resolved_index);
        let mut runtime_param_count: i32 = arg_count;
        if has_const_params {
            runtime_param_count = ast_function_param_count(ast_base, resolved_index);
            if runtime_param_count < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            let specialized_types_ptr: i32 = load_i32(
                ast_function_entry_ptr(ast_base, resolved_index) + 24,
            );
            if runtime_param_count > 0 {
                if specialized_types_ptr < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
            }
            let mut scan_idx: i32 = 0;
            let mut runtime_slot: i32 = 0;
            while scan_idx < arg_count {
                if ast_function_param_is_const(ast_base, template_index, scan_idx) {
                    scan_idx = scan_idx + 1;
                    continue;
                }
                if runtime_slot >= runtime_param_count {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                let arg_expr_index: i32 = load_i32(args_base + scan_idx * 4);
                if specialized_types_ptr >= 0 {
                    let specialized_type: i32 =
                        load_i32(specialized_types_ptr + runtime_slot * WORD_SIZE);
                    if specialized_type >= 0 {
                        ast_expr_set_type(ast_base, arg_expr_index, specialized_type);
                    }
                }
                runtime_slot = runtime_slot + 1;
                scan_idx = scan_idx + 1;
            };
        }
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let current_offset: i32 = load_i32(scratch_top_ptr);
            let arg_value_ptr: i32 = scratch_base + current_offset;
            let arg_type_ptr: i32 = arg_value_ptr + 4;
            store_i32(scratch_top_ptr, current_offset + 8);
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            let arg_status: i32 = interpret_constant_expression(
                ast_base,
                arg_expr_index,
                scratch_base,
                scratch_top_ptr,
                arg_value_ptr,
                arg_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if arg_status < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if arg_status != CONST_EVAL_STATUS_OK {
                store_i32(scratch_top_ptr, saved_top);
                return arg_status;
            }
            arg_idx = arg_idx + 1;
        };
        let mut const_env_ptr: i32 = 0;
        let mut total_param_count: i32 = runtime_param_count;
        if has_const_params {
            const_env_ptr = call_metadata_const_env_ptr(metadata_ptr);
            if const_env_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            total_param_count = load_i32(const_env_ptr);
            if total_param_count < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        if total_param_count != arg_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let env_args_ptr: i32 = scratch_base + saved_top;
        let mut runtime_found: i32 = 0;
        let mut scan_idx: i32 = 0;
        while scan_idx < arg_count {
            let is_const_param: bool = ast_function_param_is_const(
                ast_base,
                template_index,
                scan_idx,
            );
            if !is_const_param {
                runtime_found = runtime_found + 1;
            } else if const_env_ptr > 0 {
                let recorded_value: i32 =
                    load_i32(const_env_ptr + WORD_SIZE + scan_idx * 8);
                let recorded_type: i32 =
                    load_i32(const_env_ptr + WORD_SIZE + scan_idx * 8 + 4);
                if recorded_type < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                let slot_ptr: i32 = env_args_ptr + scan_idx * 8;
                store_i32(slot_ptr, recorded_value);
                store_i32(slot_ptr + 4, recorded_type);
            }
            scan_idx = scan_idx + 1;
        };
        if runtime_found != runtime_param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(scratch_top_ptr, saved_top + total_param_count * 8);
        let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, resolved_index);
        let callee_param_count: i32 = load_i32(callee_entry_ptr + 8);
        if callee_param_count != runtime_param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut eval_index: i32 = resolved_index;
        if has_const_params {
            eval_index = template_index;
        }
        let eval_entry_ptr: i32 = ast_function_entry_ptr(ast_base, eval_index);
        let eval_param_count: i32 = load_i32(eval_entry_ptr + 8);
        if eval_param_count != total_param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let body_kind: i32 = load_i32(eval_entry_ptr + 12);
        if body_kind != 2 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let body_expr_index: i32 = load_i32(eval_entry_ptr + 16);
        if body_expr_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let locals_count: i32 = load_i32(eval_entry_ptr + 20);
        if locals_count < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let env_total: i32 = total_param_count + locals_count;
        let env_ptr: i32 = if env_total > 0 {
            scratch_base + saved_top
        } else {
            0
        };
        if locals_count > 0 {
            let after_args_offset: i32 = load_i32(scratch_top_ptr);
            store_i32(scratch_top_ptr, after_args_offset + locals_count * 8);
            let mut local_fill_idx: i32 = 0;
            while local_fill_idx < locals_count {
                let slot_ptr: i32 = env_ptr + (total_param_count + local_fill_idx) * 8;
                store_i32(slot_ptr, 0);
                store_i32(slot_ptr + 4, -1);
                local_fill_idx = local_fill_idx + 1;
            };
        }
        let body_status: i32 = interpret_constant_expression(
            ast_base,
            body_expr_index,
            scratch_base,
            scratch_top_ptr,
            out_value_ptr,
            out_type_ptr,
            env_ptr,
            total_param_count,
            env_total,
        );
        if body_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if body_status == CONST_EVAL_STATUS_BREAK
            || body_status == CONST_EVAL_STATUS_CONTINUE
        {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let call_type: i32 = ast_expr_type(ast_base, expr_index);
        let result_type: i32 = load_i32(out_type_ptr);
        if call_type >= 0 && result_type >= 0 {
            if call_type != result_type {
                if has_const_params {
                    ast_expr_set_type(ast_base, expr_index, result_type);
                } else {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
            }
        }
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if local_index < param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        if init_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if body_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut has_env_slot: bool = true;
        if param_values_ptr < 0 {
            has_env_slot = false;
        } else if env_values_count <= 0 {
            has_env_slot = false;
        } else if local_index >= env_values_count {
            has_env_slot = false;
        }
        let mut init_offset: i32 = -1;
        let mut local_ptr: i32 = 0;
        let mut local_type_ptr: i32 = 0;
        if has_env_slot {
            local_ptr = param_values_ptr + local_index * 8;
            local_type_ptr = local_ptr + 4;
        } else {
            init_offset = load_i32(scratch_top_ptr);
            local_ptr = scratch_base + init_offset;
            local_type_ptr = local_ptr + 4;
            store_i32(scratch_top_ptr, init_offset + 8);
        }
        let init_status: i32 = interpret_constant_expression(
            ast_base,
            init_index,
            scratch_base,
            scratch_top_ptr,
            local_ptr,
            local_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if !has_env_slot {
            store_i32(scratch_top_ptr, init_offset);
        }
        if init_status < 0 {
            if has_env_slot {
                store_i32(local_type_ptr, -1);
            }
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if init_status != CONST_EVAL_STATUS_OK {
            if has_env_slot {
                store_i32(local_type_ptr, -1);
            }
            store_i32(scratch_top_ptr, saved_top);
            return init_status;
        }
        let body_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, body_index);
        let body_kind: i32 = load_i32(body_entry_ptr);
        if body_kind == 8 {
            let body_local_index: i32 = load_i32(body_entry_ptr + 4);
            if body_local_index == local_index {
                let stored_type: i32 = load_i32(local_type_ptr);
                if stored_type < 0 {
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                store_i32(out_value_ptr, load_i32(local_ptr));
                store_i32(out_type_ptr, stored_type);
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
        }
        let body_status: i32 = interpret_constant_expression(
            ast_base,
            body_index,
            scratch_base,
            scratch_top_ptr,
            out_value_ptr,
            out_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if body_status < 0 {
            if has_env_slot {
                let stored_type: i32 = load_i32(local_type_ptr);
                if stored_type >= 0 {
                    store_i32(out_value_ptr, load_i32(local_ptr));
                    store_i32(out_type_ptr, stored_type);
                    store_i32(scratch_top_ptr, saved_top);
                    return CONST_EVAL_STATUS_OK;
                }
            }
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if body_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return body_status;
        }
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 10 {
        if param_values_ptr < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if env_values_count <= 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if local_index < param_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if local_index >= env_values_count {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let local_ptr: i32 = param_values_ptr + local_index * 8;
        let local_type_ptr: i32 = local_ptr + 4;
        let existing_type: i32 = load_i32(local_type_ptr);
        if existing_type < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        let new_type: i32 = load_i32(value_type_ptr);
        if new_type != existing_type {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let new_value: i32 = load_i32(value_ptr);
        store_i32(local_ptr, new_value);
        store_i32(local_type_ptr, new_type);
        store_i32(out_value_ptr, new_value);
        store_i32(out_type_ptr, new_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if first_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if then_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let first_offset: i32 = load_i32(scratch_top_ptr);
        let first_value_ptr: i32 = scratch_base + first_offset;
        let first_type_ptr: i32 = first_value_ptr + 4;
        store_i32(scratch_top_ptr, first_offset + 8);
        let first_status: i32 = interpret_constant_expression(
            ast_base,
            first_index,
            scratch_base,
            scratch_top_ptr,
            first_value_ptr,
            first_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if first_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        store_i32(scratch_top_ptr, first_offset);
        if first_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return first_status;
        }
        let then_status: i32 = interpret_constant_expression(
            ast_base,
            then_index,
            scratch_base,
            scratch_top_ptr,
            out_value_ptr,
            out_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if then_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if then_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return then_status;
        }
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        if body_index < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let mut iterations: i32 = 0;
        loop {
            if iterations >= CONST_EVAL_LOOP_LIMIT {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            iterations = iterations + 1;
            let body_offset: i32 = load_i32(scratch_top_ptr);
            let body_value_ptr: i32 = scratch_base + body_offset;
            let body_type_ptr: i32 = body_value_ptr + 4;
            store_i32(scratch_top_ptr, body_offset + 8);
            let body_status: i32 = interpret_constant_expression(
                ast_base,
                body_index,
                scratch_base,
                scratch_top_ptr,
                body_value_ptr,
                body_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if body_status < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            store_i32(scratch_top_ptr, body_offset);
            if body_status == CONST_EVAL_STATUS_OK {
                continue;
            }
            if body_status == CONST_EVAL_STATUS_CONTINUE {
                continue;
            }
            if body_status == CONST_EVAL_STATUS_BREAK {
                store_i32(out_value_ptr, load_i32(body_value_ptr));
                store_i32(out_type_ptr, load_i32(body_type_ptr));
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
            if body_status == CONST_EVAL_STATUS_RETURN {
                store_i32(out_value_ptr, load_i32(body_value_ptr));
                store_i32(out_type_ptr, load_i32(body_type_ptr));
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_RETURN;
            }
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        };
    }
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if element_count > 0 {
            if values_ptr <= 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        let mut produces_value_tuple: bool = false;
        if expr_type >= 0 {
            if type_id_is_tuple(expr_type) {
                produces_value_tuple = true;
            }
        }
        let pair_words: i32 = if element_count > 0 { element_count * 2 } else { 0 };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let pair_storage_ptr: i32 = if pair_words > 0 {
            ast_call_data_alloc(ast_base, pair_words)
        } else {
            0
        };
        if pair_words > 0 {
            if pair_storage_ptr < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
        }
        let mut idx: i32 = 0;
        let mut has_non_type_element: bool = false;
        while idx < element_count {
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_offset: i32 = load_i32(scratch_top_ptr);
            let element_value_ptr: i32 = scratch_base + element_offset;
            let element_type_ptr: i32 = element_value_ptr + 4;
            store_i32(scratch_top_ptr, element_offset + 8);
            let element_status: i32 = interpret_constant_expression(
                ast_base,
                value_index,
                scratch_base,
                scratch_top_ptr,
                element_value_ptr,
                element_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if element_status < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if element_status != CONST_EVAL_STATUS_OK {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return element_status;
            }
            let element_type: i32 = load_i32(element_type_ptr);
            let element_value: i32 = load_i32(element_value_ptr);
            if pair_storage_ptr > 0 {
                let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
                store_i32(slot_ptr, element_value);
                store_i32(slot_ptr + WORD_SIZE, element_type);
            }
            if element_type != BUILTIN_TYPE_ID_TYPE {
                has_non_type_element = true;
            }
            store_i32(scratch_top_ptr, element_offset);
            idx = idx + 1;
        };
        if !produces_value_tuple {
            if has_non_type_element {
                produces_value_tuple = true;
            }
        }
        if produces_value_tuple {
            let mut tuple_type_id: i32 = expr_type;
            if tuple_type_id < 0 || !type_id_is_tuple(tuple_type_id) {
                let type_words: i32 = if element_count > 0 { element_count } else { 0 };
                let type_elements_ptr: i32 = if type_words > 0 {
                    ast_call_data_alloc(ast_base, type_words)
                } else {
                    0
                };
                if type_words > 0 {
                    if type_elements_ptr < 0 {
                        store_i32(call_data_used_ptr, saved_used);
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                }
                idx = 0;
                while idx < element_count {
                    let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
                    let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
                    if element_type < 0 {
                        store_i32(call_data_used_ptr, saved_used);
                        store_i32(scratch_top_ptr, saved_top);
                        return -1;
                    }
                    store_i32(type_elements_ptr + idx * WORD_SIZE, element_type);
                    idx = idx + 1;
                };
                let new_tuple_type: i32 =
                    ast_register_tuple_type(ast_base, type_elements_ptr, element_count);
                if new_tuple_type < 0 {
                    store_i32(call_data_used_ptr, saved_used);
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                }
                tuple_type_id = new_tuple_type;
                let resolved_tuple: i32 = resolve_type_id(0, ast_base, tuple_type_id);
                if resolved_tuple < 0 {
                    store_i32(call_data_used_ptr, saved_used);
                    store_i32(scratch_top_ptr, saved_top);
                    return -1;
                };
                tuple_type_id = resolved_tuple;
            }
            if element_count == 0 {
                store_i32(out_value_ptr, 0);
            } else {
                store_i32(out_value_ptr, pair_storage_ptr);
            }
            ast_expr_set_type(ast_base, expr_index, tuple_type_id);
            store_i32(out_type_ptr, tuple_type_id);
            store_i32(scratch_top_ptr, saved_top);
            return CONST_EVAL_STATUS_OK;
        }
        if has_non_type_element {
            store_i32(call_data_used_ptr, saved_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        idx = 0;
        while idx < element_count {
            let slot_ptr: i32 = pair_storage_ptr + idx * 2 * WORD_SIZE;
            let element_value: i32 = load_i32(slot_ptr);
            if element_value < 0 {
                store_i32(call_data_used_ptr, saved_used);
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            store_i32(pair_storage_ptr + idx * WORD_SIZE, element_value);
            idx = idx + 1;
        };
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let tuple_type_id: i32 =
            ast_register_tuple_type(ast_base, pair_storage_ptr, element_count);
        if tuple_type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if element_count > 0 && after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        }
        store_i32(out_value_ptr, tuple_type_id);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_TYPE);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let status: i32 = evaluate_integer_binary_operation(
            ast_base,
            expr_index,
            kind,
            entry_ptr,
            scratch_base,
            scratch_top_ptr,
            out_value_ptr,
            out_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
            saved_top,
        );
        return status;
    }
    if kind == 20 || kind == 21 {
        let result_type: i32 = ast_expr_type(ast_base, expr_index);
        if result_type != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_offset: i32 = load_i32(scratch_top_ptr);
        let left_value_ptr: i32 = scratch_base + left_offset;
        let left_type_ptr: i32 = left_value_ptr + 4;
        store_i32(scratch_top_ptr, left_offset + 8);
        let left_status: i32 = interpret_constant_expression(
            ast_base,
            left_index,
            scratch_base,
            scratch_top_ptr,
            left_value_ptr,
            left_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if left_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if left_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return left_status;
        }
        if load_i32(left_type_ptr) != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let left_bool: i32 = if load_i32(left_value_ptr) != 0 { 1 } else { 0 };
        if kind == 20 {
            if left_bool != 0 {
                store_i32(out_value_ptr, 1);
                store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
        } else {
            if left_bool == 0 {
                store_i32(out_value_ptr, 0);
                store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
                store_i32(scratch_top_ptr, saved_top);
                return CONST_EVAL_STATUS_OK;
            }
        }
        let right_offset: i32 = load_i32(scratch_top_ptr);
        let right_value_ptr: i32 = scratch_base + right_offset;
        let right_type_ptr: i32 = right_value_ptr + 4;
        store_i32(scratch_top_ptr, right_offset + 8);
        let right_status: i32 = interpret_constant_expression(
            ast_base,
            right_index,
            scratch_base,
            scratch_top_ptr,
            right_value_ptr,
            right_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if right_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if right_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return right_status;
        }
        if load_i32(right_type_ptr) != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let right_bool: i32 = if load_i32(right_value_ptr) != 0 { 1 } else { 0 };
        store_i32(out_value_ptr, right_bool);
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 22 {
        let result_type: i32 = ast_expr_type(ast_base, expr_index);
        if result_type != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        if load_i32(value_type_ptr) != BUILTIN_TYPE_ID_BOOL {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_bool: i32 = if load_i32(value_ptr) != 0 { 1 } else { 0 };
        store_i32(out_value_ptr, if value_bool == 0 { 1 } else { 0 });
        store_i32(out_type_ptr, BUILTIN_TYPE_ID_BOOL);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 39 {
        let target_type: i32 = load_i32(entry_ptr + 8);
        if !constant_eval_integer_type_supported(target_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        let source_type: i32 = load_i32(value_type_ptr);
        if !constant_eval_integer_type_supported(source_type) {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        let value: i32 = normalize_integer_value(load_i32(value_ptr), source_type);
        let cast_value: i32 = normalize_integer_value(value, target_type);
        store_i32(out_value_ptr, cast_value);
        store_i32(out_type_ptr, target_type);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_OK;
    }
    if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            let value_offset: i32 = load_i32(scratch_top_ptr);
            let value_ptr: i32 = scratch_base + value_offset;
            let value_type_ptr: i32 = value_ptr + 4;
            store_i32(scratch_top_ptr, value_offset + 8);
            let value_status: i32 = interpret_constant_expression(
                ast_base,
                value_index,
                scratch_base,
                scratch_top_ptr,
                value_ptr,
                value_type_ptr,
                param_values_ptr,
                param_count,
                env_values_count,
            );
            if value_status < 0 {
                store_i32(scratch_top_ptr, saved_top);
                return -1;
            }
            if value_status != CONST_EVAL_STATUS_OK {
                store_i32(scratch_top_ptr, saved_top);
                return value_status;
            }
            store_i32(out_value_ptr, load_i32(value_ptr));
            store_i32(out_type_ptr, load_i32(value_type_ptr));
        } else {
            store_i32(out_value_ptr, 0);
            store_i32(out_type_ptr, -1);
        }
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_BREAK;
    }
    if kind == 24 {
        store_i32(out_value_ptr, 0);
        store_i32(out_type_ptr, -1);
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_CONTINUE;
    }
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_offset: i32 = load_i32(scratch_top_ptr);
        let value_ptr: i32 = scratch_base + value_offset;
        let value_type_ptr: i32 = value_ptr + 4;
        store_i32(scratch_top_ptr, value_offset + 8);
        let value_status: i32 = interpret_constant_expression(
            ast_base,
            value_index,
            scratch_base,
            scratch_top_ptr,
            value_ptr,
            value_type_ptr,
            param_values_ptr,
            param_count,
            env_values_count,
        );
        if value_status < 0 {
            store_i32(scratch_top_ptr, saved_top);
            return -1;
        }
        if value_status != CONST_EVAL_STATUS_OK {
            store_i32(scratch_top_ptr, saved_top);
            return value_status;
        }
        store_i32(out_value_ptr, load_i32(value_ptr));
        store_i32(out_type_ptr, load_i32(value_type_ptr));
        store_i32(scratch_top_ptr, saved_top);
        return CONST_EVAL_STATUS_RETURN;
    }
    store_i32(scratch_top_ptr, saved_top);
    -1
}

fn collect_expression_const_params_visit(
    ast_base: i32,
    expr_index: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    usage_mask_low_ptr: i32,
    usage_mask_high_ptr: i32,
    usage_list_ptr: i32,
    usage_count_ptr: i32,
) -> i32 {
    if expr_index < 0 {
        return 0;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        return 0;
    }
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr <= 0 {
            return -1;
        }
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        if arg_count < 0 {
            return -1;
        }
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        if arg_count > 0 {
            if args_base <= 0 {
                return -1;
            }
        }
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * WORD_SIZE);
            if collect_expression_const_params_visit(
                ast_base,
                arg_expr_index,
                params_count,
                const_mask_table_ptr,
                usage_mask_low_ptr,
                usage_mask_high_ptr,
                usage_list_ptr,
                usage_count_ptr,
            ) < 0 {
                return -1;
            }
            arg_idx = arg_idx + 1;
        };
        return 0;
    }
    if kind == 7 {
        let cond_index: i32 = load_i32(entry_ptr + 4);
        if collect_expression_const_params_visit(
            ast_base,
            cond_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let then_index: i32 = load_i32(entry_ptr + 8);
        if collect_expression_const_params_visit(
            ast_base,
            then_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let else_index: i32 = load_i32(entry_ptr + 12);
        if collect_expression_const_params_visit(
            ast_base,
            else_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        return 0;
    }
    if kind == 9 {
        let init_index: i32 = load_i32(entry_ptr + 8);
        if collect_expression_const_params_visit(
            ast_base,
            init_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let body_index: i32 = load_i32(entry_ptr + 12);
        if collect_expression_const_params_visit(
            ast_base,
            body_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let else_index: i32 = load_i32(entry_ptr + 16);
        if collect_expression_const_params_visit(
            ast_base,
            else_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        return 0;
    }
    if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        return collect_expression_const_params_visit(
            ast_base,
            value_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        if collect_expression_const_params_visit(
            ast_base,
            first_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let then_index: i32 = load_i32(entry_ptr + 8);
        return collect_expression_const_params_visit(
            ast_base,
            then_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        return collect_expression_const_params_visit(
            ast_base,
            body_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        return collect_expression_const_params_visit(
            ast_base,
            value_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return collect_expression_const_params_visit(
            ast_base,
            value_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 24 {
        return 0;
    }
    if kind == 25 || kind == 26 || kind == 27 || kind == 28 || kind == 32 || kind == 33 || kind == 34 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        if collect_expression_const_params_visit(
            ast_base,
            left_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let right_index: i32 = load_i32(entry_ptr + 8);
        return collect_expression_const_params_visit(
            ast_base,
            right_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 29 || kind == 30 || kind == 31 || kind == 38 {
        let child_index: i32 = load_i32(entry_ptr + 4);
        return collect_expression_const_params_visit(
            ast_base,
            child_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if collect_expression_const_params_visit(
            ast_base,
            array_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let index_index: i32 = load_i32(entry_ptr + 8);
        if collect_expression_const_params_visit(
            ast_base,
            index_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 12);
        return collect_expression_const_params_visit(
            ast_base,
            value_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        if collect_expression_const_params_visit(
            ast_base,
            tuple_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let value_index: i32 = load_i32(entry_ptr + 12);
        return collect_expression_const_params_visit(
            ast_base,
            value_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        );
    }
    if kind == 47 {
        let type_expr_index: i32 = ast_expr_struct_literal_type_expr(ast_base, expr_index);
        if collect_expression_const_params_visit(
            ast_base,
            type_expr_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_expr_struct_literal_metadata(ast_base, expr_index);
        let field_count: i32 = ast_expr_struct_literal_field_count(ast_base, expr_index);
        if field_count < 0 {
            return -1;
        }
        let mut field_idx: i32 = 0;
        while field_idx < field_count {
            let field_ptr: i32 = struct_literal_field_entry_ptr(metadata_ptr, field_idx);
            if field_ptr <= 0 {
                return -1;
            }
            let label_kind: i32 = struct_literal_field_label_kind(field_ptr);
            if label_kind == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
                let label_expr: i32 = struct_literal_field_label_data(field_ptr);
                if collect_expression_const_params_visit(
                    ast_base,
                    label_expr,
                    params_count,
                    const_mask_table_ptr,
                    usage_mask_low_ptr,
                    usage_mask_high_ptr,
                    usage_list_ptr,
                    usage_count_ptr,
                ) < 0 {
                    return -1;
                }
            }
            let value_index: i32 = struct_literal_field_value_index(field_ptr);
            if collect_expression_const_params_visit(
                ast_base,
                value_index,
                params_count,
                const_mask_table_ptr,
                usage_mask_low_ptr,
                usage_mask_high_ptr,
                usage_list_ptr,
                usage_count_ptr,
            ) < 0 {
                return -1;
            }
            field_idx = field_idx + 1;
        };
        return 0;
    }
    if kind == 48 {
        let struct_index: i32 = ast_expr_struct_get_base(ast_base, expr_index);
        if collect_expression_const_params_visit(
            ast_base,
            struct_index,
            params_count,
            const_mask_table_ptr,
            usage_mask_low_ptr,
            usage_mask_high_ptr,
            usage_list_ptr,
            usage_count_ptr,
        ) < 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_expr_struct_get_metadata(ast_base, expr_index);
        if metadata_ptr <= 0 {
            return 0;
        }
        if struct_get_label_kind(metadata_ptr) == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
            let label_expr: i32 = struct_get_label_data(metadata_ptr);
            return collect_expression_const_params_visit(
                ast_base,
                label_expr,
                params_count,
                const_mask_table_ptr,
                usage_mask_low_ptr,
                usage_mask_high_ptr,
                usage_list_ptr,
                usage_count_ptr,
            );
        }
        return 0;
    }
    if kind == 42 || kind == 43 || kind == 8 {
        return 0;
    }
    type_template_collect_const_params(
        ast_base,
        expr_index,
        params_count,
        const_mask_table_ptr,
        usage_mask_low_ptr,
        usage_mask_high_ptr,
        usage_list_ptr,
        usage_count_ptr,
    )
}


fn collect_expression_const_params(
    ast_base: i32,
    expr_index: i32,
    params_count: i32,
    const_mask_table_ptr: i32,
    temp_base: i32,
    out_list_ptr_ptr: i32,
    out_count_ptr: i32,
) -> i32 {
    if out_list_ptr_ptr <= 0 {
        return -1;
    }
    if out_count_ptr <= 0 {
        return -1;
    }
    store_i32(out_list_ptr_ptr, 0);
    store_i32(out_count_ptr, 0);
    if expr_index < 0 {
        return 0;
    }
    if params_count <= 0 {
        return 0;
    }
    if const_mask_table_ptr <= 0 {
        return -1;
    }
    if temp_base <= 0 {
        return -1;
    }
    let usage_mask_low_ptr: i32 = temp_base;
    let usage_mask_high_ptr: i32 = usage_mask_low_ptr + WORD_SIZE;
    let usage_count_ptr: i32 = usage_mask_high_ptr + WORD_SIZE;
    let usage_list_ptr: i32 = usage_count_ptr + WORD_SIZE;
    store_i32(usage_mask_low_ptr, 0);
    store_i32(usage_mask_high_ptr, 0);
    store_i32(usage_count_ptr, 0);
    if collect_expression_const_params_visit(
        ast_base,
        expr_index,
        params_count,
        const_mask_table_ptr,
        usage_mask_low_ptr,
        usage_mask_high_ptr,
        usage_list_ptr,
        usage_count_ptr,
    ) < 0 {
        return -1;
    }
    let usage_count: i32 = load_i32(usage_count_ptr);
    if usage_count <= 0 {
        return 0;
    }
    let params_ptr: i32 = ast_call_data_alloc(ast_base, usage_count);
    if params_ptr < 0 {
        return -1;
    }
    let mut copy_idx: i32 = 0;
    while copy_idx < usage_count {
        let param_index: i32 = load_i32(usage_list_ptr + copy_idx * WORD_SIZE);
        store_i32(params_ptr + copy_idx * WORD_SIZE, param_index);
        copy_idx = copy_idx + 1;
    };
    store_i32(out_list_ptr_ptr, params_ptr);
    store_i32(out_count_ptr, usage_count);
    0
}

