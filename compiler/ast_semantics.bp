fn identifiers_match(ptr_a: i32, len_a: i32, ptr_b: i32, len_b: i32) -> bool {
    if len_a != len_b {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        };
        let a_byte: i32 = load_u8(ptr_a + idx);
        let b_byte: i32 = load_u8(ptr_b + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

const FAILURE_DETAIL_CAPACITY: i32 = 64;

fn record_failure_detail(
    out_ptr: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) {
    if out_ptr > 0 {
        if load_u8(out_ptr) == 0 {
            write_failure_detail(out_ptr, MESSAGE_LEN, message);
        };
    };
}

fn validate_function_type_template(
    ast_base: i32,
    func_index: i32,
    template_handle: i32,
) -> i32 {
    if template_handle <= 0 {
        return -1;
    };
    let expr_index: i32 = type_template_entry_expr_index(template_handle);
    if expr_index < 0 {
        return -1;
    };
    let required_count: i32 = type_template_entry_param_count(template_handle);
    if required_count < 0 {
        return -1;
    };
    if required_count == 0 {
        return 0;
    };
    if !ast_function_has_const_params(ast_base, func_index) {
        return -1;
    };
    let params_ptr: i32 = type_template_entry_params_ptr(template_handle);
    if params_ptr <= 0 {
        return -1;
    };
    let func_param_count: i32 = ast_function_param_count(ast_base, func_index);
    let mut idx: i32 = 0;
    loop {
        if idx >= required_count {
            break;
        };
        let required_param: i32 = type_template_entry_param_index(template_handle, idx);
        if required_param < 0 {
            return -1;
        };
        if required_param >= func_param_count {
            return -1;
        };
        if !ast_function_param_is_const(ast_base, func_index, required_param) {
            return -1;
        };
        idx = idx + 1;
    };
    0
}

fn collect_call_const_arguments(
    out_ptr: i32,
    ast_base: i32,
    metadata_ptr: i32,
    func_index: i32,
    param_count: i32,
) -> i32 {
    if param_count <= 0 {
        return 0;
    };
    if !ast_function_has_const_params(ast_base, func_index) {
        return 0;
    };
    let const_count: i32 = ast_function_const_params_count(ast_base, func_index);
    if const_count <= 0 {
        return 0;
    };
    let env_slot_ptr: i32 = call_metadata_const_env_ptr_ptr(metadata_ptr);
    if env_slot_ptr <= 0 {
        return -1;
    };
    let existing_env_ptr: i32 = load_i32(env_slot_ptr);
    if existing_env_ptr > 0 {
        return existing_env_ptr;
    };
    if call_metadata_const_usage_count(metadata_ptr) > 0 {
        return 0;
    };
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    if args_base < 0 {
        return -1;
    };
    let temp_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
    let env_ptr: i32 = temp_base;
    let eval_value_ptr: i32 = env_ptr + MAX_PARAMS * 8;
    let eval_type_ptr: i32 = eval_value_ptr + 4;
    let eval_stack_top_ptr: i32 = eval_type_ptr + 4;
    let eval_stack_base: i32 = eval_stack_top_ptr + 4;
    let mut init_idx: i32 = 0;
    loop {
        if init_idx >= param_count {
            break;
        };
        let slot_ptr: i32 = env_ptr + init_idx * 8;
        store_i32(slot_ptr, 0);
        store_i32(slot_ptr + 4, -1);
        init_idx = init_idx + 1;
    };
    let mut param_idx: i32 = 0;
    loop {
        if param_idx >= param_count {
            break;
        };
        if ast_function_param_is_const(ast_base, func_index, param_idx) {
            let arg_expr_index: i32 = load_i32(args_base + param_idx * WORD_SIZE);
            if arg_expr_index < 0 {
                return -1;
            };
            let saved_top: i32 = load_i32(eval_stack_top_ptr);
            store_i32(eval_stack_top_ptr, 0);
            let status: i32 = interpret_constant_expression(
                ast_base,
                arg_expr_index,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                0,
                0,
                0,
            );
            store_i32(eval_stack_top_ptr, saved_top);
            if status < 0 {
                if out_ptr > 0 {
                    if load_u8(out_ptr) == 0 {
                        write_failure_detail(
                            out_ptr,
                            56,
                            "const parameter arguments must be compile-time constants",
                        );
                    };
                };
                return -1;
            };
            if status != CONST_EVAL_STATUS_OK {
                if out_ptr > 0 {
                    if load_u8(out_ptr) == 0 {
                        write_failure_detail(
                            out_ptr,
                            56,
                            "const parameter arguments must be compile-time constants",
                        );
                    };
                };
                return -1;
            };
            let const_type: i32 = load_i32(eval_type_ptr);
            if const_type < 0 {
                if out_ptr > 0 {
                    if load_u8(out_ptr) == 0 {
                        write_failure_detail(
                            out_ptr,
                            56,
                            "const parameter arguments must be compile-time constants",
                        );
                    };
                };
                return -1;
            };
            let mut const_value: i32 = load_i32(eval_value_ptr);
            if const_type == BUILTIN_TYPE_ID_TYPE {
                if const_value < 0 {
                    return -1;
                };
                let resolved_type: i32 = resolve_type_id(0, ast_base, const_value);
                if resolved_type < 0 {
                    return -1;
                };
                const_value = resolved_type;
            };
            let slot_ptr: i32 = env_ptr + param_idx * 8;
            store_i32(slot_ptr, const_value);
            store_i32(slot_ptr + 4, const_type);
        };
        param_idx = param_idx + 1;
    };
    let env_words: i32 = param_count * 2 + 1;
    if env_words <= 0 {
        return -1;
    };
    let env_copy_ptr: i32 = ast_call_data_alloc(ast_base, env_words);
    if env_copy_ptr < 0 {
        return -1;
    };
    store_i32(env_copy_ptr, param_count);
    let mut copy_idx: i32 = 0;
    loop {
        if copy_idx >= param_count {
            break;
        };
        let src_ptr: i32 = env_ptr + copy_idx * 8;
        let dst_ptr: i32 = env_copy_ptr + WORD_SIZE + copy_idx * 8;
        store_i32(dst_ptr, load_i32(src_ptr));
        store_i32(dst_ptr + WORD_SIZE, load_i32(src_ptr + 4));
        copy_idx = copy_idx + 1;
    };
    store_i32(env_slot_ptr, env_copy_ptr);
    let key_slot_ptr: i32 = call_metadata_const_key_ptr_ptr(metadata_ptr);
    if key_slot_ptr <= 0 {
        return -1;
    };
    let key_ptr: i32 =
        ast_function_canonicalize_const_env(ast_base, func_index, env_copy_ptr);
    if key_ptr < 0 {
        return -1;
    };
    store_i32(key_slot_ptr, key_ptr);
    env_copy_ptr
}

fn resolve_call_metadata(
    out_ptr: i32,
    ast_base: i32,
    metadata_ptr: i32,
    func_count: i32,
    caller_is_const: bool,
    caller_func_index: i32,
) -> i32 {
    let mut current_metadata: i32 = metadata_ptr;
    if current_metadata < 0 {
        return -1;
    };
    let mut arg_count: i32 = call_metadata_arg_count(current_metadata);
    if arg_count < 0 {
        return -1;
    };
    let args_base: i32 = call_metadata_args_base(current_metadata);
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        };
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
        if resolve_expression(
            out_ptr,
            ast_base,
            arg_expr_index,
            func_count,
            caller_is_const,
            caller_func_index,
        ) < 0 {
            return -1;
        };
        arg_idx = arg_idx + 1;
    };

    let call_name_ptr: i32 = call_metadata_name_ptr(current_metadata);
    let call_name_len: i32 = call_metadata_name_len(current_metadata);
    let mut target_idx: i32 = 0;
    let mut found_idx: i32 = -1;
    loop {
        if target_idx >= func_count {
            break;
        };
        let target_entry_ptr: i32 = ast_function_entry_ptr(ast_base, target_idx);
        let target_name_ptr: i32 = load_i32(target_entry_ptr);
        let target_name_len: i32 = load_i32(target_entry_ptr + 4);
        if call_name_len == target_name_len {
            if identifiers_match(call_name_ptr, call_name_len, target_name_ptr, target_name_len) {
                let expected_params: i32 = load_i32(target_entry_ptr + 8);
                if expected_params != arg_count {
                    record_failure_detail(
                        out_ptr,
                        28,
                        "call argument count mismatch",
                    );
                    return -1;
                };
                let param_types_ptr: i32 = load_i32(target_entry_ptr + 24);
                if arg_count > 0 {
                    if param_types_ptr < 0 {
                        return -1;
                    };
                };
                let template_slot_ptr: i32 = call_metadata_template_payload_ptr(current_metadata);
                if template_slot_ptr > 0 {
                    let template_payload: i32 =
                        ast_function_type_template_payload_ptr(ast_base, target_idx);
                    store_i32(template_slot_ptr, template_payload);
                };
                if caller_is_const {
                    if !ast_function_is_const(ast_base, target_idx) {
                        record_failure_detail(
                            out_ptr,
                            45,
                            "const functions may only call const functions",
                        );
                        return -1;
                    };
                };
                let usage_slot_ptr: i32 = call_metadata_const_usage_list_slot(current_metadata);
                let usage_count_slot_ptr: i32 =
                    call_metadata_const_usage_count_ptr(current_metadata);
                if usage_slot_ptr <= 0 {
                    return -1;
                };
                if usage_count_slot_ptr <= 0 {
                    return -1;
                };
                store_i32(usage_slot_ptr, 0);
                store_i32(usage_count_slot_ptr, 0);
                let mut usage_collect_enabled: bool = false;
                let mut usage_mask_low_ptr: i32 = 0;
                let mut usage_mask_high_ptr: i32 = 0;
                let mut usage_count_ptr: i32 = 0;
                let mut usage_list_ptr: i32 = 0;
                let mut caller_param_count: i32 = 0;
                let mut caller_const_mask_ptr: i32 = 0;
                let specialization_temp_base: i32 =
                    ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET + 12288;
                let mut specialization_count: i32 = 0;
                if caller_func_index >= 0 {
                    caller_param_count = ast_function_param_count(ast_base, caller_func_index);
                    if caller_param_count > 0 {
                        caller_const_mask_ptr =
                            ast_function_const_params_mask_ptr(ast_base, caller_func_index);
                        if caller_const_mask_ptr > 0 {
                            usage_collect_enabled = true;
                            let usage_temp_base: i32 =
                                ast_temp_base(ast_base)
                                + CONSTANT_EVAL_SCRATCH_OFFSET
                                + 16384;
                            usage_mask_low_ptr = usage_temp_base;
                            usage_mask_high_ptr = usage_mask_low_ptr + WORD_SIZE;
                            usage_count_ptr = usage_mask_high_ptr + WORD_SIZE;
                            usage_list_ptr = usage_count_ptr + WORD_SIZE;
                            store_i32(usage_mask_low_ptr, 0);
                            store_i32(usage_mask_high_ptr, 0);
                            store_i32(usage_count_ptr, 0);
                        };
                    };
                };
                let mut verify_idx: i32 = 0;
                loop {
                    if verify_idx >= arg_count {
                        break;
                    };
                    let requires_specialization: bool =
                        ast_function_param_requires_specialization(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                    let expected_type: i32 = if param_types_ptr >= 0 {
                        load_i32(param_types_ptr + verify_idx * 4)
                    } else {
                        -1
                    };
                    let mut resolved_expected: i32 = -1;
                    if expected_type >= 0 {
                        resolved_expected =
                            resolve_type_id(out_ptr, ast_base, expected_type);
                        if resolved_expected < 0 {
                            return -1;
                        };
                        if param_types_ptr >= 0 {
                            store_i32(param_types_ptr + verify_idx * 4, resolved_expected);
                        };
                    } else if !requires_specialization {
                        return -1;
                    };
                    let arg_expr_index: i32 = load_i32(args_base + verify_idx * 4);
                    let arg_type: i32 = ast_expr_type(ast_base, arg_expr_index);
                    if arg_type < 0 {
                        if requires_specialization {
                            store_i32(
                                call_metadata_callee_index_ptr(current_metadata),
                                target_idx,
                            );
                            return current_metadata;
                        };
                        return -1;
                    };
                    let resolved_arg: i32 =
                        resolve_type_id(out_ptr, ast_base, arg_type);
                    if resolved_arg < 0 {
                        return -1;
                    };
                    ast_expr_set_type(ast_base, arg_expr_index, resolved_arg);
                    if usage_collect_enabled {
                        if ast_function_param_is_const(ast_base, target_idx, verify_idx) {
                            if collect_expression_const_params_visit(
                                ast_base,
                                arg_expr_index,
                                caller_param_count,
                                caller_const_mask_ptr,
                                usage_mask_low_ptr,
                                usage_mask_high_ptr,
                                usage_list_ptr,
                                usage_count_ptr,
                            ) < 0 {
                                return -1;
                            };
                        };
                    };
                    if !requires_specialization {
                        if resolved_expected < 0 {
                            return -1;
                        };
                        if resolved_expected != resolved_arg {
                            record_failure_detail(
                                out_ptr,
                                27,
                                "call argument type mismatch",
                            );
                            return -1;
                        };
                    } else {
                        let template_handle: i32 = ast_function_param_template_payload(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                        if template_handle <= 0 {
                            return -1;
                        };
                        let template_kind: i32 = ast_function_param_template_kind(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                        if template_kind == TYPE_TEMPLATE_KIND_NONE {
                            return -1;
                        };
                        if template_kind != TYPE_TEMPLATE_KIND_ARRAY_LENGTH
                            && template_kind != TYPE_TEMPLATE_KIND_TYPE_EXPR
                        {
                            return -1;
                        };
                        if validate_function_type_template(
                            ast_base,
                            target_idx,
                            template_handle,
                        ) < 0 {
                            return -1;
                        };
                        if specialization_count >= MAX_PARAMS {
                            return -1;
                        };
                        store_i32(
                            specialization_temp_base + specialization_count * 8,
                            verify_idx,
                        );
                        store_i32(
                            specialization_temp_base + specialization_count * 8 + 4,
                            resolved_arg,
                        );
                        specialization_count = specialization_count + 1;
                    };
                    verify_idx = verify_idx + 1;
                };
                if usage_collect_enabled {
                    let usage_total: i32 = load_i32(usage_count_ptr);
                    if usage_total > 0 {
                        let params_ptr: i32 = ast_call_data_alloc(ast_base, usage_total);
                        if params_ptr < 0 {
                            return -1;
                        };
                        let mut copy_idx: i32 = 0;
                        loop {
                            if copy_idx >= usage_total {
                                break;
                            };
                            let value: i32 = load_i32(usage_list_ptr + copy_idx * WORD_SIZE);
                            store_i32(params_ptr + copy_idx * WORD_SIZE, value);
                            copy_idx = copy_idx + 1;
                        };
                        store_i32(usage_slot_ptr, params_ptr);
                        store_i32(usage_count_slot_ptr, usage_total);
                    };
                };
                let const_status: i32 = collect_call_const_arguments(
                    out_ptr,
                    ast_base,
                    current_metadata,
                    target_idx,
                    expected_params,
                );
                if const_status < 0 {
                    return -1;
                };
                if specialization_count > 0 {
                    let env_ptr: i32 = call_metadata_const_env_ptr(current_metadata);
                    if env_ptr <= 0 {
                        if call_metadata_const_usage_count(current_metadata) > 0 {
                            store_i32(
                                call_metadata_callee_index_ptr(current_metadata),
                                target_idx,
                            );
                            return current_metadata;
                        };
                        return -1;
                    };
                    let env_param_count: i32 = load_i32(env_ptr);
                    if env_param_count < 0 {
                        return -1;
                    };
                    if env_param_count != expected_params {
                        return -1;
                    };
                    let env_values_ptr: i32 = env_ptr + WORD_SIZE;
                    let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                    let eval_value_ptr: i32 = eval_base + MAX_PARAMS * 8;
                    let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                    let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                    let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                    store_i32(eval_stack_top_ptr, 0);
                    let mut spec_idx: i32 = 0;
                    loop {
                        if spec_idx >= specialization_count {
                            break;
                        };
                        let param_index: i32 =
                            load_i32(specialization_temp_base + spec_idx * 8);
                        let expected_arg_type: i32 =
                            load_i32(specialization_temp_base + spec_idx * 8 + 4);
                        let template_handle: i32 = ast_function_param_template_payload(
                            ast_base,
                            target_idx,
                            param_index,
                        );
                        if template_handle <= 0 {
                            return -1;
                        };
                        let specialized_type: i32 = type_template_resolve_type(
                            ast_base,
                            template_handle,
                            env_values_ptr,
                            env_param_count,
                            eval_stack_base,
                            eval_stack_top_ptr,
                            eval_value_ptr,
                            eval_type_ptr,
                        );
                        if specialized_type < 0 {
                            if out_ptr > 0 {
                                if load_u8(out_ptr) == 0 {
                                    write_failure_detail(
                                        out_ptr,
                                        42,
                                        "const parameter template resolution failed",
                                    );
                                };
                            };
                            return -1;
                        };
                        let resolved_specialized: i32 =
                            resolve_type_id(out_ptr, ast_base, specialized_type);
                        if resolved_specialized < 0 {
                            return -1;
                        };
                        if resolved_specialized != expected_arg_type {
                            if out_ptr > 0 {
                                if load_u8(out_ptr) == 0 {
                                    write_failure_detail(
                                        out_ptr,
                                        47,
                                        "const parameter template expected type mismatch",
                                    );
                                };
                            };
                            return -1;
                        };
                        spec_idx = spec_idx + 1;
                    };
                };
                let mut resolved_target_idx: i32 = target_idx;
                if ast_function_has_const_params(ast_base, target_idx) {
                    let key_ptr: i32 = call_metadata_const_key_ptr(current_metadata);
                    if key_ptr > 0 {
                        let existing_specialization: i32 =
                            ast_function_find_const_specialization(
                                ast_base,
                                target_idx,
                                key_ptr,
                            );
                        if existing_specialization >= 0 {
                            resolved_target_idx = existing_specialization;
                        } else {
                            let new_specialization: i32 = ast_function_clone_const_template(
                                ast_base,
                                target_idx,
                                key_ptr,
                            );
                            if new_specialization < 0 {
                                if out_ptr > 0 {
                                    if load_u8(out_ptr) == 0 {
                                        let message: [u8; 64] =
                                            "const specialization cloning failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                                        let detail_capacity: i32 = len(message);
                                        let mut detail_idx: i32 = 0;
                                        loop {
                                            if detail_idx >= detail_capacity {
                                                break;
                                            };
                                            store_u8(out_ptr + detail_idx, message[detail_idx] as i32);
                                            detail_idx = detail_idx + 1;
                                        };
                                    };
                                };
                                return -1;
                            };
                            if ast_function_register_const_specialization(
                                ast_base,
                                target_idx,
                                key_ptr,
                                new_specialization,
                            ) < 0
                            {
                                return -1;
                            };
                            resolved_target_idx = new_specialization;
                        };
                    };
                };
                found_idx = resolved_target_idx;
                break;
            };
        };
        target_idx = target_idx + 1;
    };
    if found_idx < 0 {
        record_failure_detail(
            out_ptr,
            34,
            "call references undefined function",
        );
        return -1;
    };
    let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, found_idx);
    let runtime_param_count: i32 = load_i32(callee_entry_ptr + 8);
    if runtime_param_count < 0 {
        return -1;
    };
    if arg_count != runtime_param_count {
        if arg_count < runtime_param_count {
            record_failure_detail(
                out_ptr,
                28,
                "call argument count mismatch",
            );
            return -1;
        };
        if !ast_function_has_const_params(ast_base, found_idx) {
            let compacted: i32 = call_metadata_compact_runtime_args(
                ast_base,
                current_metadata,
                found_idx,
                runtime_param_count,
            );
            if compacted < 0 {
                return -1;
            };
            current_metadata = compacted;
            arg_count = runtime_param_count;
        } else {
            record_failure_detail(
                out_ptr,
                28,
                "call argument count mismatch",
            );
            return -1;
        };
    };
    store_i32(call_metadata_callee_index_ptr(current_metadata), found_idx);
    current_metadata
}

// Performs semantic validation on the parsed AST.  This pass ensures each
// expression has a resolved type, that control-flow constructs are well-formed,
// and that call sites match the signatures they reference.  The output is still
// an AST, but with all metadata filled in so the emitter can assume invariants
// hold.
fn interpret_constants_visit_expression(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return 0;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    0
}

fn interpret_constants_visit_call_metadata(ast_base: i32, metadata_ptr: i32) -> i32 {
    if metadata_ptr < 0 {
        return 0;
    };
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    if arg_count <= 0 {
        return 0;
    };
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    if args_base < 0 {
        return -1;
    };
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        };
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * WORD_SIZE);
        if interpret_constants_visit_expression(ast_base, arg_expr_index) < 0 {
            return -1;
        };
        arg_idx = arg_idx + 1;
    };
    0
}

fn interpret_constant_entry(ast_base: i32, const_entry_ptr: i32) -> i32 {
    if const_entry_ptr < 0 {
        return -1;
    };
    let eval_state: i32 = ast_constant_entry_eval_state(const_entry_ptr);
    if eval_state == AST_CONSTANT_EVAL_STATE_EVALUATED {
        return 0;
    };
    if eval_state == AST_CONSTANT_EVAL_STATE_EVALUATING {
        return -1;
    };
    let expr_index: i32 = ast_constant_entry_expr_index(const_entry_ptr);
    if expr_index < 0 {
        ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATED);
        return 0;
    };
    ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATING);
    let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
    let eval_value_ptr: i32 = eval_base;
    let eval_type_ptr: i32 = eval_value_ptr + 4;
    let eval_stack_top_ptr: i32 = eval_type_ptr + 4;
    let eval_stack_base: i32 = eval_stack_top_ptr + 4;
    store_i32(eval_stack_top_ptr, 0);
    if interpret_constant_expression(
        ast_base,
        expr_index,
        eval_stack_base,
        eval_stack_top_ptr,
        eval_value_ptr,
        eval_type_ptr,
        0,
        0,
        0,
    ) < 0 {
        ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_UNEVALUATED);
        return -1;
    };
    let mut literal_value: i32 = load_i32(eval_value_ptr);
    let literal_type: i32 = load_i32(eval_type_ptr);
    let const_type_ptr: i32 = ast_constant_entry_type_ptr(const_entry_ptr);
    let target_type: i32 = load_i32(const_type_ptr);
    if literal_type == target_type {
        if type_id_is_integer(target_type) {
            literal_value = normalize_integer_value(literal_value, target_type);
        } else if target_type == BUILTIN_TYPE_ID_BOOL {
            literal_value = if literal_value != 0 { 1 } else { 0 };
        } else if type_id_is_type(target_type) {
            // Type values already represent resolved type identifiers.
        };
    } else if type_id_is_integer(literal_type) && type_id_is_integer(target_type) {
        literal_value = normalize_integer_value(literal_value, target_type);
    } else {
        ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_UNEVALUATED);
        return -1;
    };
    store_i32(ast_constant_entry_value_ptr(const_entry_ptr), literal_value);
    store_i32(const_type_ptr, target_type);
    ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATED);
    0
}

fn interpret_program_constants(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        if interpret_constant_entry(ast_base, const_entry_ptr) < 0 {
            if out_ptr > 0 {
                if load_u8(out_ptr) == 0 {
                    write_failure_detail(
                        out_ptr,
                        51,
                        "constant initializer must be compile-time evaluable",
                    );
                };
            };
            return -1;
        };
        const_idx = const_idx + 1;
    };

    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if interpret_constants_visit_call_metadata(ast_base, metadata_ptr) < 0 {
                return -1;
            };
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if interpret_constants_visit_expression(ast_base, expr_index) < 0 {
                return -1;
            };
        };
        func_idx = func_idx + 1;
    };

    let expr_count: i32 = ast_expr_count(ast_base);
    let mut expr_idx: i32 = 0;
    loop {
        if expr_idx >= expr_count {
            break;
        };
        // Placeholder for future constant interpretation work that may require
        // inspecting each expression node in order.
        expr_idx = expr_idx + 1;
    };
    0
}

fn validate_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        };
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_type_ptr: i32 = ast_constant_entry_type_ptr(const_entry_ptr);
        let const_type_id: i32 = load_i32(const_type_ptr);
        let resolved_const_type: i32 = resolve_type_id(out_ptr, ast_base, const_type_id);
        if resolved_const_type < 0 {
            return -1;
        };
        if resolved_const_type != const_type_id {
            store_i32(const_type_ptr, resolved_const_type);
        };
        const_idx = const_idx + 1;
    };
    let mut idx: i32 = 0;
    loop {
        let total_funcs: i32 = ast_functions_count(ast_base);
        if total_funcs < 0 {
            return -1;
        };
        if idx >= total_funcs {
            break;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let caller_is_const: bool = ast_function_is_const(ast_base, idx);
        let mut other_idx: i32 = idx + 1;
        loop {
            if other_idx >= func_count {
                break;
            };
            let other_entry_ptr: i32 = ast_function_entry_ptr(ast_base, other_idx);
            let other_name_ptr: i32 = load_i32(other_entry_ptr);
            let other_name_len: i32 = load_i32(other_entry_ptr + 4);
            if name_len == other_name_len {
                if identifiers_match(name_ptr, name_len, other_name_ptr, other_name_len) {
                    record_failure_detail(
                        out_ptr,
                        30,
                        "duplicate function declaration",
                    );
                    return -1;
                };
            };
            other_idx = other_idx + 1;
        };

        if param_count > 0 {
            let param_types_ptr: i32 = load_i32(entry_ptr + 24);
            if param_types_ptr < 0 {
                return -1;
            };
            let mut param_idx: i32 = 0;
            loop {
                if param_idx >= param_count {
                    break;
                };
                let param_type_ptr: i32 = param_types_ptr + param_idx * 4;
                let param_type_id: i32 = load_i32(param_type_ptr);
                if param_type_id < 0 {
                    if !ast_function_param_requires_specialization(ast_base, idx, param_idx) {
                        return -1;
                    };
                    param_idx = param_idx + 1;
                    continue;
                };
                let resolved_param_type: i32 =
                    resolve_type_id(out_ptr, ast_base, param_type_id);
                if resolved_param_type < 0 {
                    return -1;
                };
                if resolved_param_type != param_type_id {
                    store_i32(param_type_ptr, resolved_param_type);
                };
                param_idx = param_idx + 1;
            };
        };
        let mut fn_return_type: i32 = load_i32(entry_ptr + 28);
        if fn_return_type >= 0 {
            let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, fn_return_type);
            if resolved_return < 0 {
                return -1;
            };
            if resolved_return != fn_return_type {
                store_i32(entry_ptr + 28, resolved_return);
                fn_return_type = resolved_return;
            };
        };

        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            let updated_metadata: i32 = resolve_call_metadata(
                out_ptr,
                ast_base,
                metadata_ptr,
                total_funcs,
                caller_is_const,
                idx,
            );
            if updated_metadata < 0 {
                return -1;
            };
            if updated_metadata != metadata_ptr {
                store_i32(entry_ptr + 16, updated_metadata);
            };
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if resolve_expression(
                out_ptr,
                ast_base,
                expr_index,
                total_funcs,
                caller_is_const,
                idx,
            ) < 0 {
                return -1;
            };
            if fn_return_type >= 0 {
                let expr_type: i32 = ast_expr_type(ast_base, expr_index);
                let expect_array: bool = type_id_is_array(fn_return_type);
                let expr_is_array: bool = expr_type >= 0 && type_id_is_array(expr_type);
                if expect_array || expr_is_array {
                    if expr_type >= 0 {
                        if expr_type != fn_return_type {
                            if out_ptr > 0 {
                                if load_u8(out_ptr) == 0 {
                                    write_failure_detail(
                                        out_ptr,
                                        56,
                                        "array expression type does not match expected array type",
                                    );
                                };
                            };
                            return -1;
                        };
                    } else if !expression_guaranteed_diverges(ast_base, expr_index) {
                        return -1;
                    };
                };
            };
        };
        idx = idx + 1;
    };
    0
}

const RESOLVE_CONTROL_STACK_CAPACITY: i32 = 128;

const RESOLVE_LOOP_STACK_CAPACITY: i32 = 64;

const RESOLVE_LOCAL_STACK_CAPACITY: i32 = 512;

const RESOLVE_LOCAL_STACK_ENTRY_SIZE: i32 = 12;

fn resolve_local_array_repeat_init_index(
    ast_base: i32,
    local_stack_base: i32,
    local_stack_count_ptr: i32,
    local_index: i32,
) -> i32 {
    if local_stack_base <= 0 {
        return -1;
    };
    if local_stack_count_ptr <= 0 {
        return -1;
    };
    if local_index < 0 {
        return -1;
    };
    let total_count: i32 = load_i32(local_stack_count_ptr);
    if total_count <= 0 {
        return -1;
    };
    let mut search_local: i32 = local_index;
    let mut depth: i32 = 0;
    loop {
        if depth >= total_count {
            return -1;
        };
        if search_local < 0 {
            return -1;
        };
        let stack_count: i32 = load_i32(local_stack_count_ptr);
        if stack_count <= 0 {
            return -1;
        };
        let mut stack_idx: i32 = stack_count - 1;
        let mut follow_alias: bool = false;
        let mut found_entry: bool = false;
        loop {
            if stack_idx < 0 {
                break;
            };
            let entry_offset: i32 =
                local_stack_base + stack_idx * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
            let recorded_index: i32 = load_i32(entry_offset);
            if recorded_index == search_local {
                found_entry = true;
                let init_expr_index: i32 = load_i32(entry_offset + 4);
                if init_expr_index < 0 {
                    return -1;
                };
                let init_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, init_expr_index);
                let init_kind: i32 = load_i32(init_entry_ptr);
                if init_kind == 35 {
                    return init_expr_index;
                };
                if init_kind == 8 {
                    search_local = load_i32(init_entry_ptr + 4);
                    follow_alias = true;
                    break;
                };
                return -1;
            };
            stack_idx = stack_idx - 1;
        };
        if !found_entry {
            return -1;
        };
        if follow_alias {
            depth = depth + 1;
            continue;
        };
        return -1;
    };
}

fn resolve_expression_internal(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    loop_stack_base: i32,
    loop_stack_count_ptr: i32,
    local_stack_base: i32,
    local_stack_count_ptr: i32,
    caller_func_index: i32,
    caller_is_const: bool,
) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let mut kind: i32 = load_i32(entry_ptr);
    if kind == 43 {
        if resolve_constant_reference(ast_base, expr_index) < 0 {
            record_failure_detail(
                out_ptr,
                20,
                "identifier not found",
            );
            return -1;
        };
        kind = load_i32(entry_ptr);
    };
    if kind == 0 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let updated_metadata: i32 = resolve_call_metadata(
            out_ptr,
            ast_base,
            metadata_ptr,
            func_count,
            caller_is_const,
            caller_func_index,
        );
        if updated_metadata < 0 {
            return -1;
        };
        if updated_metadata != metadata_ptr {
            store_i32(entry_ptr + 4, updated_metadata);
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(updated_metadata));
        if callee_index < 0 {
            return -1;
        };
        let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, callee_index);
        let mut return_type_id: i32 = load_i32(callee_entry_ptr + 28);
        if return_type_id >= 0 {
            let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, return_type_id);
            if resolved_return < 0 {
                return -1;
            };
            return_type_id = resolved_return;
        } else if ast_function_return_requires_specialization(ast_base, callee_index) {
            let template_handle: i32 =
                ast_function_return_template_payload(ast_base, callee_index);
            if template_handle <= 0 {
                return -1;
            };
            let template_kind: i32 =
                ast_function_return_template_kind(ast_base, callee_index);
            if template_kind == TYPE_TEMPLATE_KIND_NONE {
                return -1;
            };
            if template_kind != TYPE_TEMPLATE_KIND_ARRAY_LENGTH
                && template_kind != TYPE_TEMPLATE_KIND_TYPE_EXPR
            {
                return -1;
            };
            if validate_function_type_template(ast_base, callee_index, template_handle) < 0 {
                return -1;
            };
            let base_type: i32 =
                ast_function_return_template_base_type(ast_base, callee_index);
            if base_type >= 0 {
                let resolved_base: i32 = resolve_type_id(out_ptr, ast_base, base_type);
                if resolved_base < 0 {
                    return -1;
                };
            };
            let env_ptr: i32 = call_metadata_const_env_ptr(metadata_ptr);
            if env_ptr <= 0 {
                if call_metadata_const_usage_count(metadata_ptr) > 0 {
                    return 0;
                };
                return -1;
            };
            let env_param_count: i32 = load_i32(env_ptr);
            if env_param_count < 0 {
                return -1;
            };
            let expected_params: i32 = call_metadata_arg_count(metadata_ptr);
            if env_param_count != expected_params {
                return -1;
            };
            let env_values_ptr: i32 = env_ptr + WORD_SIZE;
            let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
            let eval_value_ptr: i32 = eval_base + MAX_PARAMS * 8;
            let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
            let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
            let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
            store_i32(eval_stack_top_ptr, 0);
            let specialized_type: i32 = type_template_resolve_type(
                ast_base,
                template_handle,
                env_values_ptr,
                env_param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
            );
            if specialized_type < 0 {
                return -1;
            };
            let resolved_specialized: i32 =
                resolve_type_id(out_ptr, ast_base, specialized_type);
            if resolved_specialized < 0 {
                return -1;
            };
            return_type_id = resolved_specialized;
        };
        ast_expr_set_type(ast_base, expr_index, return_type_id);
        return 0;
    };
    if kind == 6 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            };
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
            };
        };
        return 0;
    };
    if kind == 8 {
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            if local_stack_base > 0 && local_stack_count_ptr > 0 {
                let local_index: i32 = load_i32(entry_ptr + 4);
                if local_index >= 0 {
                    let stack_count: i32 = load_i32(local_stack_count_ptr);
                    let mut stack_idx: i32 = stack_count - 1;
                    loop {
                        if stack_idx < 0 {
                            break;
                        };
                        let entry_offset: i32 =
                            local_stack_base + stack_idx * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
                        let recorded_index: i32 = load_i32(entry_offset);
                        if recorded_index == local_index {
                            let recorded_type: i32 = load_i32(entry_offset + 8);
                            if recorded_type >= 0 {
                                expr_type = recorded_type;
                                ast_expr_set_type(ast_base, expr_index, expr_type);
                            };
                            break;
                        };
                        stack_idx = stack_idx - 1;
                    };
                };
            };
        };
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            };
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
            };
        };
        return 0;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = ast_expr_array_repeat_length(ast_base, expr_index);
        let length_expr_index: i32 = ast_expr_array_repeat_length_expr(ast_base, expr_index);
        if length < 0 {
            if length_expr_index < 0 {
                        if out_ptr > 0 {
                            if load_u8(out_ptr) == 0 {
                                write_failure_detail(
                                    out_ptr,
                                    41,
                                    "array literal length must be non-negative",
                                );
                            };
                        };
                return -1;
            };
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            element_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let element_type: i32 = ast_expr_type(ast_base, element_index);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        if resolved_element != element_type {
            ast_expr_set_type(ast_base, element_index, resolved_element);
        };
        if length < 0 {
            ast_expr_set_type(ast_base, expr_index, -1);
            return 0;
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, resolved_element, length);
        if array_type_id < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut element_type: i32 = -1;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                element_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            };
            let current_type: i32 = ast_expr_type(ast_base, element_index);
            if current_type < 0 {
                return -1;
            };
            let resolved_current: i32 = resolve_type_id(out_ptr, ast_base, current_type);
            if resolved_current < 0 {
                return -1;
            };
            if resolved_current != current_type {
                ast_expr_set_type(ast_base, element_index, resolved_current);
            };
            if element_type < 0 {
                element_type = resolved_current;
            } else if resolved_current != element_type {
                if out_ptr > 0 {
                    if load_u8(out_ptr) == 0 {
                        write_failure_detail(
                            out_ptr,
                            45,
                            "array literal elements must have uniform type",
                        );
                    };
                };
                return -1;
            };
            idx = idx + 1;
        };
        if element_type < 0 {
            return -1;
        };
        let array_type_id: i32 = ast_register_array_type(ast_base, element_type, element_count);
        if array_type_id < 0 {
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            index_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            if caller_func_index >= 0 {
                let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
                let array_expr_kind: i32 = load_i32(array_entry_ptr);
                if array_expr_kind == 6 {
                    let param_index: i32 = load_i32(array_entry_ptr + 4);
                    if param_index >= 0 {
                        if ast_function_param_requires_specialization(
                            ast_base,
                            caller_func_index,
                            param_index,
                        ) {
                            let index_type: i32 = ast_expr_type(ast_base, index_index);
                            if index_type != BUILTIN_TYPE_ID_I32 {
                                record_failure_detail(
                                    out_ptr,
                                    36,
                                    "array index requires integer indices",
                                );
                                return -1;
                            };
                            let element_hint: i32 =
                                ast_function_param_template_base_type(
                                    ast_base,
                                    caller_func_index,
                                    param_index,
                                );
                            if element_hint >= 0 {
                                let resolved_hint: i32 =
                                    resolve_type_id(out_ptr, ast_base, element_hint);
                                if resolved_hint < 0 {
                                    return -1;
                                };
                                ast_expr_set_type(ast_base, expr_index, resolved_hint);
                                return 0;
                            };
                            ast_expr_set_type(ast_base, expr_index, -1);
                            return 0;
                        };
                    };
                } else if array_expr_kind == 35 {
                    let length_expr_index: i32 =
                        ast_expr_array_repeat_length_expr(ast_base, array_index);
                    if length_expr_index >= 0 {
                        let index_type: i32 = ast_expr_type(ast_base, index_index);
                        if index_type != BUILTIN_TYPE_ID_I32 {
                            record_failure_detail(
                                out_ptr,
                                36,
                                "array index requires integer indices",
                            );
                            return -1;
                        };
                        let element_index: i32 = load_i32(array_entry_ptr + WORD_SIZE);
                        if element_index < 0 {
                            return -1;
                        };
                        let element_type: i32 = ast_expr_type(ast_base, element_index);
                        if element_type < 0 {
                            return -1;
                        };
                        let resolved_element: i32 =
                            resolve_type_id(out_ptr, ast_base, element_type);
                        if resolved_element < 0 {
                            return -1;
                        };
                        if resolved_element != element_type {
                            ast_expr_set_type(ast_base, element_index, resolved_element);
                        };
                        ast_expr_set_type(ast_base, expr_index, resolved_element);
                        return 0;
                    };
                } else if array_expr_kind == 8 {
                    if local_stack_base > 0 && local_stack_count_ptr > 0 {
                        let local_index: i32 = load_i32(array_entry_ptr + 4);
                        if local_index >= 0 {
                            let repeat_init_index: i32 = resolve_local_array_repeat_init_index(
                                ast_base,
                                local_stack_base,
                                local_stack_count_ptr,
                                local_index,
                            );
                            if repeat_init_index >= 0 {
                                let index_type: i32 = ast_expr_type(ast_base, index_index);
                                if index_type != BUILTIN_TYPE_ID_I32 {
                                    record_failure_detail(
                                        out_ptr,
                                        36,
                                        "array index requires integer indices",
                                    );
                                    return -1;
                                };
                                let repeat_entry_ptr: i32 =
                                    ast_expr_entry_ptr(ast_base, repeat_init_index);
                                let element_index: i32 = load_i32(repeat_entry_ptr + WORD_SIZE);
                                if element_index < 0 {
                                    return -1;
                                };
                                let element_type: i32 = ast_expr_type(ast_base, element_index);
                                if element_type < 0 {
                                    return -1;
                                };
                                let resolved_element: i32 =
                                    resolve_type_id(out_ptr, ast_base, element_type);
                                if resolved_element < 0 {
                                    return -1;
                                };
                                if resolved_element != element_type {
                                    ast_expr_set_type(
                                        ast_base,
                                        element_index,
                                        resolved_element,
                                    );
                                };
                                ast_expr_set_type(ast_base, expr_index, resolved_element);
                                return 0;
                            };
                        };
                    };
                };
            };
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        };
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        };
        if !type_id_is_array(resolved_array_type) {
            return -1;
        };
        let index_type: i32 = ast_expr_type(ast_base, index_index);
        if index_type != BUILTIN_TYPE_ID_I32 {
            record_failure_detail(
                out_ptr,
                36,
                "array index requires integer indices",
            );
            return -1;
        };
        let element_type: i32 = array_type_element_type(ast_base, resolved_array_type);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            if caller_func_index >= 0 {
                let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
                let array_expr_kind: i32 = load_i32(array_entry_ptr);
                if array_expr_kind == 6 {
                    let param_index: i32 = load_i32(array_entry_ptr + 4);
                    if param_index >= 0 {
                        if ast_function_param_requires_specialization(
                            ast_base,
                            caller_func_index,
                            param_index,
                        ) {
                            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                            return 0;
                        };
                    };
                } else if array_expr_kind == 35 {
                    let length_expr_index: i32 =
                        ast_expr_array_repeat_length_expr(ast_base, array_index);
                    if length_expr_index >= 0 {
                        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                        return 0;
                    };
                } else if array_expr_kind == 8 {
                    if local_stack_base > 0 && local_stack_count_ptr > 0 {
                        let local_index: i32 = load_i32(array_entry_ptr + 4);
                        if local_index >= 0 {
                            let repeat_init_index: i32 = resolve_local_array_repeat_init_index(
                                ast_base,
                                local_stack_base,
                                local_stack_count_ptr,
                                local_index,
                            );
                            if repeat_init_index >= 0 {
                                let length_expr_index: i32 = ast_expr_array_repeat_length_expr(
                                    ast_base,
                                    repeat_init_index,
                                );
                                if length_expr_index >= 0 {
                                    ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                                    return 0;
                                };
                                let stored_length: i32 =
                                    ast_expr_array_repeat_length(ast_base, repeat_init_index);
                                if stored_length >= 0 {
                                    ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                                    return 0;
                                };
                            };
                        };
                    };
                };
            };
            return -1;
        };
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        };
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        };
        if !type_id_is_array(resolved_array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, resolved_array_type);
        if length < 0 {
                    if out_ptr > 0 {
                        if load_u8(out_ptr) == 0 {
                            write_failure_detail(
                                out_ptr,
                                41,
                                "array literal length must be non-negative",
                            );
                        };
                    };
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
        return 0;
    };
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            tuple_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if tuple_type < 0 {
            return -1;
        };
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type);
        if resolved_tuple < 0 {
            return -1;
        };
        if resolved_tuple != tuple_type {
            ast_expr_set_type(ast_base, tuple_index, resolved_tuple);
        };
        if !type_id_is_tuple(resolved_tuple) {
            return -1;
        };
        let tuple_idx: i32 = tuple_type_index(resolved_tuple);
        if tuple_idx < 0 {
            return -1;
        };
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            return -1;
        };
        if ensure_tuple_type_metadata(out_ptr, ast_base, tuple_idx, resolved_tuple) < 0 {
            return -1;
        };
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count <= field_index {
            record_failure_detail(
                out_ptr,
                31,
                "tuple field index out of bounds",
            );
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return -1;
        };
        let element_type_ptr: i32 = elements_ptr + field_index * WORD_SIZE;
        let element_type: i32 = load_i32(element_type_ptr);
        if element_type < 0 {
            return -1;
        };
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        };
        if resolved_element != element_type {
            store_i32(element_type_ptr, resolved_element);
        };
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    };
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        if element_count == 0 {
            let tuple_type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
            if tuple_type_id < 0 {
                return -1;
            };
            let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
            if resolved_tuple < 0 {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, resolved_tuple);
            return 0;
        };
        if values_ptr < 0 {
            return -1;
        };
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let elements_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if elements_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            };
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let element_type: i32 = ast_expr_type(ast_base, value_index);
            if element_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
            if resolved_element < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            };
            if resolved_element != element_type {
                ast_expr_set_type(ast_base, value_index, resolved_element);
            };
            store_i32(elements_ptr + idx * WORD_SIZE, resolved_element);
            idx = idx + 1;
        };
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let tuple_type_id: i32 =
            ast_register_tuple_type(ast_base, elements_ptr, element_count);
        if tuple_type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        };
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        };
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
        if resolved_tuple < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_tuple);
        return 0;
    };
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + 4);
        let byte_count: i32 = load_i32(entry_ptr + 8);
        if byte_count < 0 {
            return -1;
        };
        if byte_count > 0 && bytes_ptr < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        return 0;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if type_id_is_array(value_type) {
            return -1;
        };
        return 0;
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let resolved_target: i32 = resolve_type_id(out_ptr, ast_base, target_type);
        if resolved_target < 0 {
            return -1;
        };
        if !type_id_is_integer(resolved_target) {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type < 0 {
            return -1;
        };
        let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
        if resolved_value < 0 {
            return -1;
        };
        if !type_id_is_integer(resolved_value) {
            return -1;
        };
        if resolved_value != value_type {
            ast_expr_set_type(ast_base, value_index, resolved_value);
        };
        ast_expr_set_type(ast_base, expr_index, resolved_target);
        return 0;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            left_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            right_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let left_type: i32 = ast_expr_type(ast_base, left_index);
        let right_type: i32 = ast_expr_type(ast_base, right_index);
        if left_type < 0 {
            return -1;
        };
        if right_type < 0 {
            return -1;
        };
        let resolved_left: i32 = resolve_type_id(out_ptr, ast_base, left_type);
        if resolved_left < 0 {
            return -1;
        };
        if resolved_left != left_type {
            ast_expr_set_type(ast_base, left_index, resolved_left);
        };
        let resolved_right: i32 = resolve_type_id(out_ptr, ast_base, right_type);
        if resolved_right < 0 {
            return -1;
        };
        if resolved_right != right_type {
            ast_expr_set_type(ast_base, right_index, resolved_right);
        };
        if kind == 20 || kind == 21 {
            if !type_id_is_bool(resolved_left) {
                record_failure_detail(
                    out_ptr,
                    42,
                    "logical operators require boolean operands",
                );
                return -1;
            };
            if !type_id_is_bool(resolved_right) {
                record_failure_detail(
                    out_ptr,
                    42,
                    "logical operators require boolean operands",
                );
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if kind == 14
            || kind == 15
            || kind == 16
            || kind == 17
            || kind == 18
            || kind == 19
        {
            if !type_id_is_integer(resolved_left) {
                record_failure_detail(
                    out_ptr,
                    41,
                    "binary operator operands must be integers",
                );
                return -1;
            };
            if !type_id_is_integer(resolved_right) {
                record_failure_detail(
                    out_ptr,
                    41,
                    "binary operator operands must be integers",
                );
                return -1;
            };
            if resolved_left != resolved_right {
                record_failure_detail(
                    out_ptr,
                    48,
                    "binary operator operands must have matching type",
                );
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        };
        if !type_id_is_integer(resolved_left) {
            record_failure_detail(
                out_ptr,
                41,
                "binary operator operands must be integers",
            );
            return -1;
        };
        if !type_id_is_integer(resolved_right) {
            record_failure_detail(
                out_ptr,
                41,
                "binary operator operands must be integers",
            );
            return -1;
        };
        if resolved_left != resolved_right {
            record_failure_detail(
                out_ptr,
                48,
                "binary operator operands must have matching type",
            );
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_left);
        return 0;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if !type_id_is_bool(value_type) {
            record_failure_detail(
                out_ptr,
                35,
                "logical not operand must be boolean",
            );
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
        return 0;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if caller_func_index >= 0 {
            let caller_entry_ptr: i32 = ast_function_entry_ptr(ast_base, caller_func_index);
            let mut expected_return: i32 = load_i32(caller_entry_ptr + 28);
            if expected_return >= 0 {
                let resolved_expected: i32 = resolve_type_id(out_ptr, ast_base, expected_return);
                if resolved_expected < 0 {
                    return -1;
                };
                if resolved_expected != expected_return {
                    store_i32(caller_entry_ptr + 28, resolved_expected);
                    expected_return = resolved_expected;
                };
                if value_type >= 0 && value_type != expected_return {
                    if out_ptr > 0 {
                        if load_u8(out_ptr) == 0 {
                            write_failure_detail(
                                out_ptr,
                                58,
                                "return expression type does not match function return type",
                            );
                        };
                    };
                    return -1;
                };
            };
        };
        ast_expr_set_type(ast_base, expr_index, value_type);
        return 0;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            condition_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let control_count: i32 = load_i32(control_stack_count_ptr);
        if control_count >= RESOLVE_CONTROL_STACK_CAPACITY {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            else_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        };
        store_i32(control_stack_count_ptr, control_count);
        let condition_type: i32 = ast_expr_type(ast_base, condition_index);
        if !type_id_is_bool(condition_type) {
            if !type_id_is_integer(condition_type) {
                return -1;
            };
        };
        let then_type: i32 = ast_expr_type(ast_base, then_index);
        let else_type: i32 = ast_expr_type(ast_base, else_index);
        if then_type != else_type {
            let then_diverges: bool = expression_guaranteed_diverges(ast_base, then_index);
            let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
            if then_diverges && !else_diverges {
                ast_expr_set_type(ast_base, expr_index, else_type);
                return 0;
            };
            if else_diverges && !then_diverges {
                ast_expr_set_type(ast_base, expr_index, then_type);
                return 0;
            };
            if then_diverges && else_diverges {
                return 0;
            };
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, then_type);
        return 0;
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let declared_type: i32 = ast_expr_type(ast_base, init_index);
        let mut resolved_declared: i32 = -1;
        if declared_type >= 0 {
            resolved_declared = resolve_type_id(out_ptr, ast_base, declared_type);
            if resolved_declared < 0 {
                return -1;
            };
        };
        if resolve_expression_internal(out_ptr, ast_base,
            init_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        let mut init_type: i32 = ast_expr_type(ast_base, init_index);
        if init_type >= 0 {
            let resolved_init: i32 = resolve_type_id(out_ptr, ast_base, init_type);
            if resolved_init < 0 {
                return -1;
            };
            if resolved_init != init_type {
                ast_expr_set_type(ast_base, init_index, resolved_init);
                init_type = resolved_init;
            };
        };
        if resolved_declared >= 0 && init_type >= 0 && init_type != resolved_declared {
            if out_ptr > 0 {
                if load_u8(out_ptr) == 0 {
                    write_failure_detail(
                        out_ptr,
                        47,
                        "const parameter template expected type mismatch",
                    );
                };
            };
            return -1;
        };
        let mut pushed: bool = false;
        if local_stack_base > 0 && local_stack_count_ptr > 0 {
            let stack_count: i32 = load_i32(local_stack_count_ptr);
            if stack_count >= RESOLVE_LOCAL_STACK_CAPACITY {
                return -1;
            };
            let entry_offset: i32 =
                local_stack_base + stack_count * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
            store_i32(entry_offset, local_index);
            store_i32(entry_offset + 4, init_index);
            store_i32(entry_offset + 8, ast_expr_type(ast_base, init_index));
            store_i32(local_stack_count_ptr, stack_count + 1);
            pushed = true;
        };
        let body_status: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        );
        if pushed {
            let stack_count: i32 = load_i32(local_stack_count_ptr);
            if stack_count <= 0 {
                return -1;
            };
            store_i32(local_stack_count_ptr, stack_count - 1);
        };
        if body_status < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
        return 0;
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            first_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, then_index));
        return 0;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
        if control_count + 2 > control_capacity {
            return -1;
        };
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        let loop_capacity: i32 = RESOLVE_LOOP_STACK_CAPACITY;
        if loop_count >= loop_capacity {
            return -1;
        };
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        store_i32(control_stack_base + (control_count + 1) * 4, 1);
        store_i32(control_stack_count_ptr, control_count + 2);
        store_i32(loop_stack_base + loop_count * 4, control_count);
        store_i32(loop_stack_count_ptr, loop_count + 1);
        let body_result: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        );
        store_i32(loop_stack_count_ptr, loop_count);
        store_i32(control_stack_count_ptr, control_count);
        if body_result < 0 {
            return -1;
        };
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    };
    if kind == 13 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - target_index;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            if resolve_expression_internal(out_ptr, ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            };
            ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
            return 0;
        };
        ast_expr_set_type(ast_base, expr_index, -1);
        return 0;
    };
    if kind == 24 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        };
        let target_index: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let continue_target: i32 = target_index + 1;
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - continue_target;
        if branch_depth < 0 {
            return -1;
        };
        store_i32(entry_ptr + 4, branch_depth);
        return 0;
    };
    -1
}

fn resolve_expression(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    caller_is_const: bool,
    caller_func_index: i32,
) -> i32 {
    let temp_base: i32 = ast_temp_base(ast_base);
    let control_count_ptr: i32 = temp_base;
    let loop_count_ptr: i32 = temp_base + 4;
    let control_stack_base: i32 = temp_base + 8;
    let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
    let loop_stack_base: i32 = control_stack_base + control_capacity * 4;
    let local_stack_count_ptr: i32 = loop_stack_base + RESOLVE_LOOP_STACK_CAPACITY * 4;
    let local_stack_base: i32 = local_stack_count_ptr + 4;
    let saved_control_count: i32 = load_i32(control_count_ptr);
    let saved_loop_count: i32 = load_i32(loop_count_ptr);
    let saved_local_count: i32 = load_i32(local_stack_count_ptr);
    store_i32(control_count_ptr, 0);
    store_i32(loop_count_ptr, 0);
    store_i32(local_stack_count_ptr, 0);
    let result: i32 = resolve_expression_internal(
        out_ptr,
        ast_base,
        expr_index,
        func_count,
        control_stack_base,
        control_count_ptr,
        loop_stack_base,
        loop_count_ptr,
        local_stack_base,
        local_stack_count_ptr,
        caller_func_index,
        caller_is_const,
    );
    store_i32(control_count_ptr, saved_control_count);
    store_i32(loop_count_ptr, saved_loop_count);
    store_i32(local_stack_count_ptr, saved_local_count);
    result
}


const COMPILER_MEMORY_PAGES: i32 = 256;

fn initialize_layout(out_ptr: i32) {
    if out_ptr > 0 {
        let mut detail_idx: i32 = 0;
        loop {
            if detail_idx >= FAILURE_DETAIL_CAPACITY {
                break;
            };
            store_u8(out_ptr + detail_idx, 0);
            detail_idx = detail_idx + 1;
        };
    };
    store_i32(scratch_instr_offset_ptr(out_ptr), 0);
    store_i32(scratch_expr_type_ptr(out_ptr), -1);
    store_i32(scratch_fn_count_ptr(out_ptr), 0);
    store_i32(scratch_types_count_ptr(out_ptr), 0);
}

// Entry point for the compiler pipeline.  The function stages the linear-memory
// layout, parses modules (including recursive imports), validates the resulting
// AST, and finally hands the fully-resolved program to the WebAssembly emitter.
// On success it returns the number of bytes written into the output buffer.
