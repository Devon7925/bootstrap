use "./ast_compiler_base_lexing.bp";

fn identifiers_match(ptr_a: i32, len_a: i32, ptr_b: i32, len_b: i32) -> bool {
    if len_a != len_b {
        return false;
    }
    let mut idx: i32 = 0;
    loop {
        if idx >= len_a {
            break;
        }
        let a_byte: i32 = load_u8(ptr_a + idx);
        let b_byte: i32 = load_u8(ptr_b + idx);
        if a_byte != b_byte {
            return false;
        }
        idx = idx + 1;
    };
    true
}

const LOOP_STACK_FLAG_STRIDE: i32 = 65536;

const CONST_ENV_ENTRY_NAME_CAP: i32 = 5;

const ConstEnvEntry = struct(
    CONST_ENV_ENTRY_NAME_CAP,
    2,
    [
        ("value", i32),
        ("type\0", i32),
    ],
);

const CONST_PARAM_SPECIALIZATION_NAME_CAP: i32 = 5;

const ConstParamSpecialization = struct(
    CONST_PARAM_SPECIALIZATION_NAME_CAP,
    2,
    [
        ("param", i32),
        ("type\0", i32),
    ],
);

fn const_env_entry_store(ptr: i32, entry: ConstEnvEntry) {
    store_i32(ptr, entry.value);
    store_i32(ptr + WORD_SIZE, entry.type);
}

fn const_env_entry_load(ptr: i32) -> ConstEnvEntry {
    ConstEnvEntry {
        value: load_i32(ptr),
        type: load_i32(ptr + WORD_SIZE),
    }
}

fn record_failure_detail(
    out_ptr: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) {
    if out_ptr > 0 {
        if load_u8(out_ptr) == 0 {
            write_failure_detail(out_ptr, MESSAGE_LEN, message);
        }
    }
}

fn record_failure_with_location(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) -> i32 {
    if out_ptr <= 0 {
        return 0;
    }
    if load_u8(out_ptr) != 0 {
        return 0;
    }
    if location_offset < 0 {
        write_failure_detail(out_ptr, MESSAGE_LEN, message);
        return 0;
    }
    let mut module_index: i32 = scratch_module_index(out_ptr);
    let mut module_base: i32 = scratch_module_base(out_ptr);
    let mut module_len: i32 = scratch_module_len(out_ptr);
    if caller_func_index >= 0 {
        let func_base: i32 = ast_function_entry_module_base(ast_base, caller_func_index);
        let func_len: i32 = ast_function_entry_module_len(ast_base, caller_func_index);
        let func_index: i32 = ast_function_entry_module_index(ast_base, caller_func_index);
        if func_base > 0 {
            module_base = func_base;
        }
        if func_len > 0 {
            module_len = func_len;
        }
        if func_index >= 0 {
            module_index = func_index;
        }
    }
    write_failure_detail_with_location(
        out_ptr,
        module_index,
        module_base,
        module_len,
        location_offset,
        MESSAGE_LEN,
        message,
    );
    0
}

fn append_struct_field_name_to_failure(
    out_ptr: i32,
    ast_base: i32,
    struct_index: i32,
    field_index: i32,
) -> i32 {
    if out_ptr <= 0 {
        return 0;
    }
    let trimmed_len: i32 = struct_field_trimmed_length(ast_base, struct_index, field_index);
    if trimmed_len <= 0 {
        return 0;
    }
    let mut write_offset: i32 = 0;
    loop {
        if write_offset >= FAILURE_DETAIL_CAPACITY {
            return 0;
        }
        let existing: i32 = load_u8(out_ptr + write_offset);
        if existing == 0 {
            break;
        }
        write_offset = write_offset + 1;
    };
    let mut byte_idx: i32 = 0;
    while byte_idx < trimmed_len {
        if write_offset >= FAILURE_DETAIL_CAPACITY {
            return 0;
        }
        let canonical_byte: i32 = ast_struct_type_field_canonical_byte(
            ast_base,
            struct_index,
            field_index,
            byte_idx,
        );
        if canonical_byte < 0 {
            return 0;
        }
        store_u8(out_ptr + write_offset, canonical_byte);
        write_offset = write_offset + 1;
        byte_idx = byte_idx + 1;
    };
    if write_offset < FAILURE_DETAIL_CAPACITY {
        store_u8(out_ptr + write_offset, 0);
        write_offset = write_offset + 1;
    }
    while write_offset < FAILURE_DETAIL_CAPACITY {
        store_u8(out_ptr + write_offset, 0);
        write_offset = write_offset + 1;
    };
    0
}

fn resolve_constant_failure_module_context(
    out_ptr: i32,
    const_entry_ptr: i32,
) -> (i32, i32, i32) {
    let mut module_index: i32 = ast_constant_entry_module_index(const_entry_ptr);
    let mut module_base: i32 = 0;
    let mut module_len: i32 = 0;
    if module_index >= 0 {
        module_base = module_entry_content(module_index);
        module_len = module_entry_content_len(module_index);
    } else {
        module_index = scratch_module_index(out_ptr);
        module_base = scratch_module_base(out_ptr);
        module_len = scratch_module_len(out_ptr);
    }
    (module_index, module_base, module_len)
}

fn record_struct_literal_field_mismatch(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
    struct_index: i32,
    field_index: i32,
) {
    if out_ptr > 0 {
        let initial: i32 = load_u8(out_ptr);
        let message: [u8; 57] =
            "struct literal field name does not match canonical field ";
        record_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            location_offset,
            57,
            message,
        );
        if initial == 0 {
            append_struct_field_name_to_failure(out_ptr, ast_base, struct_index, field_index);
        }
    }
}

fn record_struct_literal_missing_field(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
    struct_index: i32,
    field_index: i32,
) {
    if out_ptr > 0 {
        let initial: i32 = load_u8(out_ptr);
        let message: [u8; 29] = "struct literal missing field ";
        record_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            location_offset,
            29,
            message,
        );
        if initial == 0 {
            append_struct_field_name_to_failure(out_ptr, ast_base, struct_index, field_index);
        }
    }
}

fn struct_label_expression_requires_const_specialization(
    ast_base: i32,
    expr_index: i32,
    caller_func_index: i32,
) -> bool {
    if expr_index < 0 {
        return false;
    }
    if caller_func_index < 0 {
        return false;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + WORD_SIZE);
        if param_index < 0 {
            return false;
        }
        return ast_function_param_is_const(ast_base, caller_func_index, param_index);
    }
    false
}

fn struct_label_expression_normalized_byte(value_ptr: i32, index: i32) -> i32 {
    if index < 0 {
        return -1;
    }
    if value_ptr <= 0 {
        return -1;
    }
    let slot_ptr: i32 = value_ptr + index * 2 * WORD_SIZE;
    let char_value: i32 = load_i32(slot_ptr);
    let char_type: i32 = load_i32(slot_ptr + WORD_SIZE);
    if !constant_eval_integer_type_supported(char_type) {
        return -1;
    }
    let normalized: i32 = normalize_integer_value(char_value, char_type);
    if normalized < 0 {
        return -1;
    }
    if normalized > 255 {
        return -1;
    }
    normalized
}

fn struct_label_expression_trimmed_length(value_ptr: i32, element_count: i32) -> i32 {
    if element_count <= 0 {
        return 0;
    }
    if value_ptr <= 0 {
        return -1;
    }
    let mut trimmed: i32 = element_count;
    loop {
        if trimmed <= 0 {
            break;
        }
        let normalized: i32 = struct_label_expression_normalized_byte(value_ptr, trimmed - 1);
        if normalized < 0 {
            return -1;
        }
        if normalized != 0 {
            break;
        }
        trimmed = trimmed - 1;
    };
    trimmed
}

fn resolve_struct_get_expression(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    struct_index_expr: i32,
    metadata_ptr: i32,
    func_count: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    loop_stack_base: i32,
    loop_stack_count_ptr: i32,
    local_stack_base: i32,
    local_stack_count_ptr: i32,
    caller_func_index: i32,
    caller_is_const: bool,
) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    let struct_type_id: i32 = ast_expr_type(ast_base, struct_index_expr);
    let resolved_struct: i32 = resolve_type_id(out_ptr, ast_base, struct_type_id);
    if resolved_struct < 0 {
        return -1;
    }
    if resolved_struct != struct_type_id {
        ast_expr_set_type(ast_base, struct_index_expr, resolved_struct);
    }
    if !type_id_is_struct(resolved_struct) {
        return -1;
    }
    let struct_index: i32 = struct_type_index(resolved_struct);
    if struct_index < 0 {
        return -1;
    }
    if ensure_struct_type_metadata(out_ptr, ast_base, struct_index, resolved_struct) < 0 {
        return -1;
    }
    let label_kind: i32 = struct_get_label_kind(metadata_ptr);
    if label_kind == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
        let label_expr: i32 = struct_get_label_data(metadata_ptr);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            label_expr,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let access_location: i32 = ast_expr_struct_get_location(ast_base, expr_index);
        let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
        let eval_value_ptr: i32 = eval_base;
        let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
        let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
        let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
        let saved_eval_top: i32 = load_i32(eval_stack_top_ptr);
        store_i32(eval_stack_top_ptr, 0);
        let eval_status: i32 = interpret_constant_expression(
            ast_base,
            label_expr,
            eval_stack_base,
            eval_stack_top_ptr,
            eval_value_ptr,
            eval_type_ptr,
            0,
            0,
            0,
        );
        store_i32(eval_stack_top_ptr, saved_eval_top);
        if eval_status < 0 {
            if struct_label_expression_requires_const_specialization(
                ast_base,
                label_expr,
                caller_func_index,
            ) {
                ast_expr_set_type(ast_base, expr_index, -1);
                return 0;
            }
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        if eval_status != CONST_EVAL_STATUS_OK {
            if struct_label_expression_requires_const_specialization(
                ast_base,
                label_expr,
                caller_func_index,
            ) {
                ast_expr_set_type(ast_base, expr_index, -1);
                return 0;
            }
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let mut label_type: i32 = load_i32(eval_type_ptr);
        let resolved_label_type: i32 = resolve_type_id(out_ptr, ast_base, label_type);
        if resolved_label_type < 0 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        label_type = resolved_label_type;
        ast_expr_set_type(ast_base, label_expr, label_type);
        if !type_id_is_array(label_type) {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let element_type: i32 = array_type_element_type(ast_base, label_type);
        if element_type < 0 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        if element_type != BUILTIN_TYPE_ID_U8 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let element_count: i32 = array_type_length(ast_base, label_type);
        if element_count < 0 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let label_value_ptr: i32 = load_i32(eval_value_ptr);
        if label_value_ptr <= 0 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let trimmed_length: i32 =
            struct_label_expression_trimmed_length(label_value_ptr, element_count);
        if trimmed_length < 0 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                33,
                "struct field identifier not found",
            );
            return -1;
        }
        let field_count: i32 = ast_struct_type_field_count(ast_base, struct_index);
        if field_count < 0 {
            return -1;
        }
        let mut field_idx: i32 = 0;
        while field_idx < field_count {
            let canonical_length: i32 =
                struct_field_trimmed_length(ast_base, struct_index, field_idx);
            if canonical_length < 0 {
                return -1;
            }
            if canonical_length == trimmed_length {
                let mut compare_idx: i32 = 0;
                let mut matches: bool = true;
                while compare_idx < canonical_length {
                    let normalized_char: i32 = struct_label_expression_normalized_byte(
                        label_value_ptr,
                        compare_idx,
                    );
                    if normalized_char < 0 {
                        matches = false;
                        break;
                    }
                    let canonical_char: i32 = ast_struct_type_field_canonical_byte(
                        ast_base,
                        struct_index,
                        field_idx,
                        compare_idx,
                    );
                    if canonical_char < 0 {
                        return -1;
                    }
                    if canonical_char != normalized_char {
                        matches = false;
                        break;
                    }
                    compare_idx = compare_idx + 1;
                };
                if matches {
                    let matched_type: i32 =
                        ast_struct_type_field_type(ast_base, struct_index, field_idx);
                    if matched_type < 0 {
                        return -1;
                    }
                    let resolved_field: i32 =
                        resolve_type_id(out_ptr, ast_base, matched_type);
                    if resolved_field < 0 {
                        return -1;
                    }
                    struct_get_label_set_extra(metadata_ptr, field_idx);
                    ast_expr_set_type(ast_base, expr_index, resolved_field);
                    return 0;
                }
            }
            field_idx = field_idx + 1;
        };
        record_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            access_location,
            33,
            "struct field identifier not found",
        );
        return -1;
    } else if label_kind == STRUCT_LITERAL_LABEL_KIND_IDENTIFIER {
        let ident_ptr: i32 = struct_get_label_data(metadata_ptr);
        let ident_len: i32 = struct_get_label_extra(metadata_ptr);
        if ident_ptr <= 0 {
            return -1;
        }
        if ident_len < 0 {
            return -1;
        }
        let field_count: i32 = ast_struct_type_field_count(ast_base, struct_index);
        if field_count < 0 {
            return -1;
        }
        let mut field_idx: i32 = 0;
        let mut matched_type: i32 = -1;
        while field_idx < field_count {
            if struct_field_identifier_matches(
                ast_base,
                struct_index,
                field_idx,
                ident_ptr,
                ident_len,
            ) {
                matched_type = ast_struct_type_field_type(ast_base, struct_index, field_idx);
                break;
            }
            field_idx = field_idx + 1;
        };
        if matched_type >= 0 {
            let resolved_field: i32 = resolve_type_id(out_ptr, ast_base, matched_type);
            if resolved_field < 0 {
                return -1;
            }
            struct_get_label_set_extra(metadata_ptr, field_idx);
            ast_expr_set_type(ast_base, expr_index, resolved_field);
            return 0;
        }
        let access_location: i32 = ast_expr_struct_get_location(ast_base, expr_index);
        record_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            access_location,
            33,
            "struct field identifier not found",
        );
        return -1;
    }
    -1
}

fn record_struct_literal_type_mismatch(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
    struct_index: i32,
    field_index: i32,
) {
    if out_ptr > 0 {
        let initial: i32 = load_u8(out_ptr);
        let message: [u8; 63] =
            "struct literal field value type does not match canonical field ";
        record_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            location_offset,
            63,
            message,
        );
        if initial == 0 {
            append_struct_field_name_to_failure(out_ptr, ast_base, struct_index, field_index);
        }
    }
}

fn store_call_failure_location(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
) -> bool {
    if out_ptr <= 0 {
        return false;
    }
    if location_offset < 0 {
        return false;
    }
    let mut module_base: i32 = scratch_module_base(out_ptr);
    let mut module_len: i32 = scratch_module_len(out_ptr);
    if caller_func_index >= 0 {
        let func_base: i32 = ast_function_entry_module_base(ast_base, caller_func_index);
        let func_len: i32 = ast_function_entry_module_len(ast_base, caller_func_index);
        if func_base > 0 {
            module_base = func_base;
        }
        if func_len > 0 {
            module_len = func_len;
        }
    }
    if module_base <= 0 {
        return false;
    }
    if module_len <= 0 {
        return false;
    }
    let effective_offset: i32 = if location_offset > module_len {
        module_len
    } else {
        location_offset
    };
    let mut line: i32 = 1;
    let mut column: i32 = 1;
    let mut offset_idx: i32 = 0;
    while offset_idx < effective_offset {
        let byte: i32 = load_u8(module_base + offset_idx);
        if byte == '\n' {
            line = line + 1;
            column = 1;
        } else {
            column = column + 1;
        }
        offset_idx = offset_idx + 1;
    };
    if line <= 0 {
        return false;
    }
    if column <= 0 {
        return false;
    }
    let mut path_ptr: i32 = scratch_failure_path_ptr(out_ptr);
    let mut path_len: i32 = scratch_failure_path_len(out_ptr);
    if path_ptr <= 0 || path_len <= 0 {
        let module_index: i32 = scratch_module_index(out_ptr);
        if module_index >= 0 {
            let entry_path_ptr: i32 = module_entry_path(module_index);
            let entry_path_len: i32 = module_entry_path_len(module_index);
            if entry_path_ptr > 0 && entry_path_len > 0 {
                path_ptr = entry_path_ptr;
                path_len = entry_path_len;
            }
        }
    }
    store_i32(scratch_failure_path_ptr_ptr(out_ptr), path_ptr);
    store_i32(scratch_failure_path_len_ptr(out_ptr), path_len);
    store_i32(scratch_failure_line_ptr(out_ptr), line);
    store_i32(scratch_failure_column_ptr(out_ptr), column);
    store_i32(scratch_failure_character_ptr(out_ptr), effective_offset + 1);
    store_i32(scratch_failure_offset_ptr(out_ptr), effective_offset);
    true
}

fn try_record_call_failure_with_location(
    out_ptr: i32,
    ast_base: i32,
    caller_func_index: i32,
    location_offset: i32,
    const MESSAGE_LEN: i32,
    message: [u8; MESSAGE_LEN],
) -> bool {
    if !store_call_failure_location(out_ptr, ast_base, caller_func_index, location_offset) {
        return false;
    }
    if load_u8(out_ptr) != 0 {
        return true;
    }
    write_failure_detail(out_ptr, MESSAGE_LEN, message);
    true
}

fn find_call_metadata_location(ast_base: i32, metadata_ptr: i32) -> i32 {
    if metadata_ptr <= 0 {
        return -1;
    }
    let expr_count: i32 = ast_expr_count(ast_base);
    let mut expr_index: i32 = 0;
    loop {
        if expr_index >= expr_count {
            break;
        }
        let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
        if load_i32(entry_ptr) == 1 {
            let entry_metadata: i32 = load_i32(entry_ptr + WORD_SIZE);
            if entry_metadata == metadata_ptr {
                return load_i32(entry_ptr + 3 * WORD_SIZE);
            }
        }
        expr_index = expr_index + 1;
    };
    -1
}

fn validate_function_type_template(
    ast_base: i32,
    func_index: i32,
    template_handle: i32,
) -> i32 {
    if template_handle <= 0 {
        return -1;
    }
    let expr_index: i32 = type_template_entry_expr_index(template_handle);
    if expr_index < 0 {
        return -1;
    }
    let required_count: i32 = type_template_entry_param_count(template_handle);
    if required_count < 0 {
        return -1;
    }
    if required_count == 0 {
        return 0;
    }
    if !ast_function_has_const_params(ast_base, func_index) {
        return -1;
    }
    let params_ptr: i32 = type_template_entry_params_ptr(template_handle);
    if params_ptr <= 0 {
        return -1;
    }
    let func_param_count: i32 = ast_function_param_count(ast_base, func_index);
    let mut idx: i32 = 0;
    loop {
        if idx >= required_count {
            break;
        }
        let required_param: i32 = type_template_entry_param_index(template_handle, idx);
        if required_param < 0 {
            return -1;
        }
        if required_param >= func_param_count {
            return -1;
        }
        if !ast_function_param_is_const(ast_base, func_index, required_param) {
            return -1;
        }
        idx = idx + 1;
    };
    0
}

fn collect_call_const_arguments(
    out_ptr: i32,
    ast_base: i32,
    metadata_ptr: i32,
    func_index: i32,
    param_count: i32,
    caller_func_index: i32,
    call_location_offset: i32,
) -> i32 {
    if param_count <= 0 {
        return 0;
    }
    if !ast_function_has_const_params(ast_base, func_index) {
        return 0;
    }
    let const_count: i32 = ast_function_const_params_count(ast_base, func_index);
    if const_count <= 0 {
        return 0;
    }
    let env_slot_ptr: i32 = call_metadata_const_env_ptr_ptr(metadata_ptr);
    if env_slot_ptr <= 0 {
        return -1;
    }
    let existing_env_ptr: i32 = load_i32(env_slot_ptr);
    if existing_env_ptr > 0 {
        return existing_env_ptr;
    }
    if call_metadata_const_usage_count(metadata_ptr) > 0 {
        return 0;
    }
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    if args_base < 0 {
        return -1;
    }
    let temp_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
    let eval_value_ptr: i32 = temp_base;
    let eval_type_ptr: i32 = eval_value_ptr + 4;
    let eval_stack_top_ptr: i32 = eval_type_ptr + 4;
    let eval_stack_base: i32 = eval_stack_top_ptr + 4;
    let mut env_entries: [ConstEnvEntry; MAX_PARAMS] =
        [ConstEnvEntry { value: 0, type: -1 }; MAX_PARAMS];
    let mut resolved_location_offset: i32 = call_location_offset;
    if resolved_location_offset < 0 {
        resolved_location_offset = find_call_metadata_location(ast_base, metadata_ptr);
    }
    let mut param_idx: i32 = 0;
    loop {
        if param_idx >= param_count {
            break;
        }
        if ast_function_param_is_const(ast_base, func_index, param_idx) {
            let arg_expr_index: i32 = load_i32(args_base + param_idx * WORD_SIZE);
            if arg_expr_index < 0 {
                return -1;
            }
            let saved_top: i32 = load_i32(eval_stack_top_ptr);
            store_i32(eval_stack_top_ptr, 0);
            let status: i32 = interpret_constant_expression(
                ast_base,
                arg_expr_index,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
                0,
                0,
                0,
            );
            store_i32(eval_stack_top_ptr, saved_top);
            if status < 0 {
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    resolved_location_offset,
                    56,
                    "const parameter arguments must be compile-time constants",
                );
                if !recorded {
                    record_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        resolved_location_offset,
                        56,
                        "const parameter arguments must be compile-time constants",
                    );
                }
                return -1;
            }
            if status != CONST_EVAL_STATUS_OK {
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    resolved_location_offset,
                    56,
                    "const parameter arguments must be compile-time constants",
                );
                if !recorded {
                    record_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        resolved_location_offset,
                        56,
                        "const parameter arguments must be compile-time constants",
                    );
                }
                return -1;
            }
            let const_type: i32 = load_i32(eval_type_ptr);
            if const_type < 0 {
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    resolved_location_offset,
                    56,
                    "const parameter arguments must be compile-time constants",
                );
                if !recorded {
                    record_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        resolved_location_offset,
                        56,
                        "const parameter arguments must be compile-time constants",
                    );
                }
                return -1;
            }
            let mut const_value: i32 = load_i32(eval_value_ptr);
            if const_type == BUILTIN_TYPE_ID_TYPE {
                if const_value < 0 {
                    return -1;
                }
                let resolved_type: i32 = resolve_type_id(0, ast_base, const_value);
                if resolved_type < 0 {
                    return -1;
                }
                const_value = resolved_type;
            }
            env_entries[param_idx] = ConstEnvEntry {
                value: const_value,
                type: const_type,
            };
        }
        param_idx = param_idx + 1;
    };
    let env_words: i32 = param_count * 2 + 1;
    if env_words <= 0 {
        return -1;
    }
    let env_copy_ptr: i32 = ast_call_data_alloc(ast_base, env_words);
    if env_copy_ptr < 0 {
        if out_ptr > 0 {
            if load_u8(out_ptr) == 0 {
                let location_offset: i32 =
                    find_call_metadata_location(ast_base, metadata_ptr);
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    func_index,
                    location_offset,
                    41,
                    "const argument metadata capacity exceeded",
                );
                if !recorded {
                    record_failure_detail(
                        out_ptr,
                        41,
                        "const argument metadata capacity exceeded",
                    );
                }
            }
        }
        return -1;
    }
    store_i32(env_copy_ptr, param_count);
    let mut copy_idx: i32 = 0;
    loop {
        if copy_idx >= param_count {
            break;
        }
        let dst_ptr: i32 = env_copy_ptr + WORD_SIZE + copy_idx * 2 * WORD_SIZE;
        let entry: ConstEnvEntry = env_entries[copy_idx];
        const_env_entry_store(dst_ptr, entry);
        copy_idx = copy_idx + 1;
    };
    store_i32(env_slot_ptr, env_copy_ptr);
    let key_slot_ptr: i32 = call_metadata_const_key_ptr_ptr(metadata_ptr);
    if key_slot_ptr <= 0 {
        return -1;
    }
    let key_ptr: i32 =
        ast_function_canonicalize_const_env(ast_base, func_index, env_copy_ptr);
    if key_ptr < 0 {
        return -1;
    }
    store_i32(key_slot_ptr, key_ptr);
    env_copy_ptr
}


fn resolve_call_metadata(
    out_ptr: i32,
    ast_base: i32,
    metadata_ptr: i32,
    func_count: i32,
    caller_is_const: bool,
    caller_func_index: i32,
    call_location_offset: i32,
) -> i32 {
    let mut current_metadata: i32 = metadata_ptr;
    if current_metadata < 0 {
        return -1;
    }
    let mut resolved_location_offset: i32 = call_location_offset;
    if resolved_location_offset < 0 {
        resolved_location_offset = find_call_metadata_location(ast_base, metadata_ptr);
    }
    let mut arg_count: i32 = call_metadata_arg_count(current_metadata);
    if arg_count < 0 {
        return -1;
    }
    let args_base: i32 = call_metadata_args_base(current_metadata);
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        }
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
        if resolve_expression(
            out_ptr,
            ast_base,
            arg_expr_index,
            func_count,
            caller_is_const,
            caller_func_index,
        ) < 0 {
            return -1;
        }
        arg_idx = arg_idx + 1;
    };

    let call_name_ptr: i32 = call_metadata_name_ptr(current_metadata);
    let call_name_len: i32 = call_metadata_name_len(current_metadata);
    if call_name_ptr <= 0 {
        return -1;
    }
    if call_name_len < 0 {
        return -1;
    }
    if call_name_len == 6 {
        let mut match_idx: i32 = 0;
        let literal: [u8; 6] = "struct";
        loop {
            if match_idx >= 6 {
                break;
            }
            let stored: i32 = load_u8(call_name_ptr + match_idx);
            let expected: i32 = literal[match_idx] as i32;
            if stored != expected {
                match_idx = -1;
                break;
            }
            match_idx = match_idx + 1;
        };
        if match_idx == 6 {
            if !caller_is_const {
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    resolved_location_offset,
                    51,
                    "struct intrinsic must be evaluated in const context",
                );
                if !recorded {
                    record_failure_detail(
                        out_ptr,
                        51,
                        "struct intrinsic must be evaluated in const context",
                    );
                }
                return -1;
            }
            if arg_count != 3 {
                let recorded: bool = try_record_call_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    resolved_location_offset,
                    40,
                    "struct intrinsic expects three arguments",
                );
                if !recorded {
                    record_failure_detail(
                        out_ptr,
                        40,
                        "struct intrinsic expects three arguments",
                    );
                }
                return -1;
            }
            store_i32(
                call_metadata_callee_index_ptr(current_metadata),
                CALL_METADATA_INTRINSIC_STRUCT,
            );
            return current_metadata;
        }
    }
    let mut target_idx: i32 = 0;
    let mut found_idx: i32 = -1;
    loop {
        if target_idx >= func_count {
            break;
        }
        let target_entry_ptr: i32 = ast_function_entry_ptr(ast_base, target_idx);
        let target_name_ptr: i32 = load_i32(target_entry_ptr);
        let target_name_len: i32 = load_i32(target_entry_ptr + 4);
        if call_name_len == target_name_len {
            if identifiers_match(call_name_ptr, call_name_len, target_name_ptr, target_name_len) {
                let expected_params: i32 = load_i32(target_entry_ptr + 8);
                if expected_params != arg_count {
                    let recorded: bool = try_record_call_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        resolved_location_offset,
                        28,
                        "call argument count mismatch",
                    );
                    if !recorded {
                        record_failure_detail(
                            out_ptr,
                            28,
                            "call argument count mismatch",
                        );
                    }
                    return -1;
                }
                let param_types_ptr: i32 = load_i32(target_entry_ptr + 24);
                if arg_count > 0 {
                    if param_types_ptr < 0 {
                        return -1;
                    }
                }
                let template_slot_ptr: i32 = call_metadata_template_payload_ptr(current_metadata);
                if template_slot_ptr > 0 {
                    let template_payload: i32 =
                        ast_function_type_template_payload_ptr(ast_base, target_idx);
                    store_i32(template_slot_ptr, template_payload);
                }
                if caller_is_const {
                    if !ast_function_is_const(ast_base, target_idx) {
                        let recorded: bool = try_record_call_failure_with_location(
                            out_ptr,
                            ast_base,
                            caller_func_index,
                            resolved_location_offset,
                            45,
                            "const functions may only call const functions",
                        );
                        if !recorded {
                            record_failure_detail(
                                out_ptr,
                                45,
                                "const functions may only call const functions",
                            );
                        }
                        return -1;
                    }
                }
                let usage_slot_ptr: i32 = call_metadata_const_usage_list_slot(current_metadata);
                let usage_count_slot_ptr: i32 =
                    call_metadata_const_usage_count_ptr(current_metadata);
                if usage_slot_ptr <= 0 {
                    return -1;
                }
                if usage_count_slot_ptr <= 0 {
                    return -1;
                }
                store_i32(usage_slot_ptr, 0);
                store_i32(usage_count_slot_ptr, 0);
                let mut usage_collect_enabled: bool = false;
                let mut usage_mask_low_ptr: i32 = 0;
                let mut usage_mask_high_ptr: i32 = 0;
                let mut usage_count_ptr: i32 = 0;
                let mut usage_list_ptr: i32 = 0;
                let mut caller_param_count: i32 = 0;
                let mut caller_const_mask_ptr: i32 = 0;
                let mut specializations: [ConstParamSpecialization; MAX_PARAMS] =
                    [ConstParamSpecialization { param: 0, type: -1 }; MAX_PARAMS];
                let mut specialization_count: i32 = 0;
                if caller_func_index >= 0 {
                    caller_param_count = ast_function_param_count(ast_base, caller_func_index);
                    if caller_param_count > 0 {
                        caller_const_mask_ptr =
                            ast_function_const_params_mask_ptr(ast_base, caller_func_index);
                        if caller_const_mask_ptr > 0 {
                            usage_collect_enabled = true;
                            let usage_temp_base: i32 =
                                ast_temp_base(ast_base)
                                + CONSTANT_EVAL_SCRATCH_OFFSET
                                + 16384;
                            usage_mask_low_ptr = usage_temp_base;
                            usage_mask_high_ptr = usage_mask_low_ptr + WORD_SIZE;
                            usage_count_ptr = usage_mask_high_ptr + WORD_SIZE;
                            usage_list_ptr = usage_count_ptr + WORD_SIZE;
                            store_i32(usage_mask_low_ptr, 0);
                            store_i32(usage_mask_high_ptr, 0);
                            store_i32(usage_count_ptr, 0);
                        }
                    }
                }
                let mut verify_idx: i32 = 0;
                loop {
                    if verify_idx >= arg_count {
                        break;
                    }
                    let requires_specialization: bool =
                        ast_function_param_requires_specialization(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                    let expected_type: i32 = if param_types_ptr >= 0 {
                        load_i32(param_types_ptr + verify_idx * 4)
                    } else {
                        -1
                    };
                    let mut resolved_expected: i32 = -1;
                    if expected_type >= 0 {
                        resolved_expected =
                            resolve_type_id(out_ptr, ast_base, expected_type);
                        if resolved_expected < 0 {
                            return -1;
                        }
                        if param_types_ptr >= 0 {
                            store_i32(param_types_ptr + verify_idx * 4, resolved_expected);
                        }
                    } else if !requires_specialization {
                        return -1;
                    }
                    let arg_expr_index: i32 = load_i32(args_base + verify_idx * 4);
                    let arg_type: i32 = ast_expr_type(ast_base, arg_expr_index);
                    if arg_type < 0 {
                        if requires_specialization {
                            store_i32(
                                call_metadata_callee_index_ptr(current_metadata),
                                target_idx,
                            );
                            return current_metadata;
                        }
                        return -1;
                    }
                    let resolved_arg: i32 =
                        resolve_type_id(out_ptr, ast_base, arg_type);
                    if resolved_arg < 0 {
                        return -1;
                    }
                    ast_expr_set_type(ast_base, arg_expr_index, resolved_arg);
                    if usage_collect_enabled {
                        if ast_function_param_is_const(ast_base, target_idx, verify_idx) {
                            if collect_expression_const_params_visit(
                                ast_base,
                                arg_expr_index,
                                caller_param_count,
                                caller_const_mask_ptr,
                                usage_mask_low_ptr,
                                usage_mask_high_ptr,
                                usage_list_ptr,
                                usage_count_ptr,
                            ) < 0 {
                                return -1;
                            }
                        }
                    }
                    if !requires_specialization {
                        if resolved_expected < 0 {
                            return -1;
                        }
                        if resolved_expected != resolved_arg {
                            let recorded: bool = try_record_call_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                resolved_location_offset,
                                27,
                                "call argument type mismatch",
                            );
                            if !recorded {
                                record_failure_detail(
                                    out_ptr,
                                    27,
                                    "call argument type mismatch",
                                );
                            }
                            return -1;
                        }
                    } else {
                        let template_handle: i32 = ast_function_param_template_payload(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                        if template_handle <= 0 {
                            return -1;
                        }
                        let template_kind: i32 = ast_function_param_template_kind(
                            ast_base,
                            target_idx,
                            verify_idx,
                        );
                        if template_kind == TYPE_TEMPLATE_KIND_NONE {
                            return -1;
                        }
                        if template_kind != TYPE_TEMPLATE_KIND_ARRAY_LENGTH
                            && template_kind != TYPE_TEMPLATE_KIND_TYPE_EXPR
                        {
                            return -1;
                        }
                        if validate_function_type_template(
                            ast_base,
                            target_idx,
                            template_handle,
                        ) < 0 {
                            return -1;
                        }
                        if specialization_count >= MAX_PARAMS {
                            return -1;
                        }
                        specializations[specialization_count] = ConstParamSpecialization {
                            param: verify_idx,
                            type: resolved_arg,
                        };
                        specialization_count = specialization_count + 1;
                    }
                    verify_idx = verify_idx + 1;
                };
                if usage_collect_enabled {
                    let usage_total: i32 = load_i32(usage_count_ptr);
                    if usage_total > 0 {
                        let params_ptr: i32 = ast_call_data_alloc(ast_base, usage_total);
                        if params_ptr < 0 {
                            if out_ptr > 0 {
                                if load_u8(out_ptr) == 0 {
                                    let location_offset: i32 =
                                        find_call_metadata_location(ast_base, current_metadata);
                                    let recorded: bool = try_record_call_failure_with_location(
                                        out_ptr,
                                        ast_base,
                                        caller_func_index,
                                        location_offset,
                                        41,
                                        "const argument metadata capacity exceeded",
                                    );
                                    if !recorded {
                                        record_failure_detail(
                                            out_ptr,
                                            41,
                                            "const argument metadata capacity exceeded",
                                        );
                                    }
                                }
                            }
                            return -1;
                        }
                        let mut copy_idx: i32 = 0;
                        loop {
                            if copy_idx >= usage_total {
                                break;
                            }
                            let value: i32 = load_i32(usage_list_ptr + copy_idx * WORD_SIZE);
                            store_i32(params_ptr + copy_idx * WORD_SIZE, value);
                            copy_idx = copy_idx + 1;
                        };
                        store_i32(usage_slot_ptr, params_ptr);
                        store_i32(usage_count_slot_ptr, usage_total);
                    }
                }
                let const_status: i32 = collect_call_const_arguments(
                    out_ptr,
                    ast_base,
                    current_metadata,
                    target_idx,
                    expected_params,
                    caller_func_index,
                    resolved_location_offset,
                );
                if const_status < 0 {
                    return -1;
                }
                if specialization_count > 0 {
                    let env_ptr: i32 = call_metadata_const_env_ptr(current_metadata);
                    if env_ptr <= 0 {
                        if call_metadata_const_usage_count(current_metadata) > 0 {
                            store_i32(
                                call_metadata_callee_index_ptr(current_metadata),
                                target_idx,
                            );
                            return current_metadata;
                        }
                        return -1;
                    }
                    let env_param_count: i32 = load_i32(env_ptr);
                    if env_param_count < 0 {
                        return -1;
                    }
                    if env_param_count != expected_params {
                        return -1;
                    }
                    let env_values_ptr: i32 = env_ptr + WORD_SIZE;
                    let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                    let eval_value_ptr: i32 = eval_base + MAX_PARAMS * 8;
                    let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                    let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                    let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                    store_i32(eval_stack_top_ptr, 0);
                    let mut spec_idx: i32 = 0;
                    loop {
                        if spec_idx >= specialization_count {
                            break;
                        }
                        let specialization: ConstParamSpecialization =
                            specializations[spec_idx];
                        let param_index: i32 = specialization.param;
                        let expected_arg_type: i32 = specialization.type;
                        let template_handle: i32 = ast_function_param_template_payload(
                            ast_base,
                            target_idx,
                            param_index,
                        );
                        if template_handle <= 0 {
                            return -1;
                        }
                        let specialized_type: i32 = type_template_resolve_type(
                            ast_base,
                            template_handle,
                            env_values_ptr,
                            env_param_count,
                            eval_stack_base,
                            eval_stack_top_ptr,
                            eval_value_ptr,
                            eval_type_ptr,
                        );
                        if specialized_type < 0 {
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                resolved_location_offset,
                                42,
                                "const parameter template resolution failed",
                            );
                            return -1;
                        }
                        let resolved_specialized: i32 =
                            resolve_type_id(out_ptr, ast_base, specialized_type);
                        if resolved_specialized < 0 {
                            return -1;
                        }
                        if resolved_specialized != expected_arg_type {
                            let is_const_param: bool = ast_function_param_is_const(
                                ast_base,
                                target_idx,
                                param_index,
                            );
                            if !is_const_param {
                                record_failure_with_location(
                                    out_ptr,
                                    ast_base,
                                    caller_func_index,
                                    resolved_location_offset,
                                    47,
                                    "const parameter template expected type mismatch",
                                );
                                return -1;
                            }
                            let arg_expr_index: i32 =
                                load_i32(args_base + param_index * WORD_SIZE);
                            if arg_expr_index >= 0 {
                                ast_expr_set_type(
                                    ast_base,
                                    arg_expr_index,
                                    resolved_specialized,
                                );
                            }
                            specializations[spec_idx] = ConstParamSpecialization {
                                param: specialization.param,
                                type: resolved_specialized,
                            };
                        }
                        spec_idx = spec_idx + 1;
                    };
                }
                let mut resolved_target_idx: i32 = target_idx;
                if ast_function_has_const_params(ast_base, target_idx) {
                    let key_ptr: i32 = call_metadata_const_key_ptr(current_metadata);
                    if key_ptr > 0 {
                        let existing_specialization: i32 =
                            ast_function_find_const_specialization(
                                ast_base,
                                target_idx,
                                key_ptr,
                            );
                        if existing_specialization >= 0 {
                            resolved_target_idx = existing_specialization;
                        } else {
                            let new_specialization: i32 = ast_function_clone_const_template(
                                ast_base,
                                target_idx,
                                key_ptr,
                                out_ptr,
                                caller_func_index,
                                resolved_location_offset,
                            );
                            if new_specialization < 0 {
                                if out_ptr > 0 {
                                    if load_u8(out_ptr) == 0 {
                                        let message: [u8; 64] =
                                            "const specialization cloning failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                                        let detail_capacity: i32 = len(message);
                                        let mut detail_idx: i32 = 0;
                                        loop {
                                            if detail_idx >= detail_capacity {
                                                break;
                                            }
                                            store_u8(out_ptr + detail_idx, message[detail_idx] as i32);
                                            detail_idx = detail_idx + 1;
                                        };
                                    }
                                }
                                return -1;
                            }
                            if ast_function_register_const_specialization(
                                ast_base,
                                target_idx,
                                key_ptr,
                                new_specialization,
                            ) < 0
                            {
                                return -1;
                            }
                            resolved_target_idx = new_specialization;
                        }
                    }
                }
                found_idx = resolved_target_idx;
                break;
            }
        }
        target_idx = target_idx + 1;
    };
    if found_idx < 0 {
        let recorded: bool = try_record_call_failure_with_location(
            out_ptr,
            ast_base,
            caller_func_index,
            resolved_location_offset,
            34,
            "call references undefined function",
        );
        if !recorded {
            record_failure_detail(
                out_ptr,
                34,
                "call references undefined function",
            );
        }
        return -1;
    }
    let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, found_idx);
    let runtime_param_count: i32 = load_i32(callee_entry_ptr + 8);
    if runtime_param_count < 0 {
        return -1;
    }
    if arg_count != runtime_param_count {
        if arg_count < runtime_param_count {
            let recorded: bool = try_record_call_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                resolved_location_offset,
                28,
                "call argument count mismatch",
            );
            if !recorded {
                record_failure_detail(
                    out_ptr,
                    28,
                    "call argument count mismatch",
                );
            }
            return -1;
        }
        if !ast_function_has_const_params(ast_base, found_idx) {
            let compacted: i32 = call_metadata_compact_runtime_args(
                ast_base,
                current_metadata,
                found_idx,
                runtime_param_count,
            );
            if compacted < 0 {
                return -1;
            }
            current_metadata = compacted;
            arg_count = runtime_param_count;
        } else {
            let recorded: bool = try_record_call_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                resolved_location_offset,
                28,
                "call argument count mismatch",
            );
            if !recorded {
                record_failure_detail(
                    out_ptr,
                    28,
                    "call argument count mismatch",
                );
            }
            return -1;
        }
    }
    store_i32(call_metadata_callee_index_ptr(current_metadata), found_idx);
    current_metadata
}

// Performs semantic validation on the parsed AST.  This pass ensures each
// expression has a resolved type, that control-flow constructs are well-formed,
// and that call sites match the signatures they reference.  The output is still
// an AST, but with all metadata filled in so the emitter can assume invariants
// hold.
fn interpret_constants_visit_expression(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return 0;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    0
}

fn interpret_constants_visit_call_metadata(ast_base: i32, metadata_ptr: i32) -> i32 {
    if metadata_ptr < 0 {
        return 0;
    }
    let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
    if arg_count <= 0 {
        return 0;
    }
    let args_base: i32 = call_metadata_args_base(metadata_ptr);
    if args_base < 0 {
        return -1;
    }
    let mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= arg_count {
            break;
        }
        let arg_expr_index: i32 = load_i32(args_base + arg_idx * WORD_SIZE);
        if interpret_constants_visit_expression(ast_base, arg_expr_index) < 0 {
            return -1;
        }
        arg_idx = arg_idx + 1;
    };
    0
}

fn try_convert_constant_value(
    ast_base: i32,
    value_ptr: i32,
    value_type: i32,
    target_type: i32,
) -> i32 {
    if target_type < 0 {
        return -1;
    }
    if value_type < 0 {
        return -1;
    }
    if value_type == target_type {
        if type_id_is_integer(target_type) {
            let normalized: i32 = normalize_integer_value(load_i32(value_ptr), target_type);
            store_i32(value_ptr, normalized);
            return 0;
        }
        if target_type == BUILTIN_TYPE_ID_BOOL {
            let normalized: i32 = if load_i32(value_ptr) != 0 { 1 } else { 0 };
            store_i32(value_ptr, normalized);
            return 0;
        }
        if type_id_is_array(target_type) {
            let length: i32 = array_type_length(ast_base, target_type);
            if length <= 0 {
                return 0;
            }
            let data_ptr: i32 = load_i32(value_ptr);
            if data_ptr <= 0 {
                return -1;
            }
            let element_type: i32 = array_type_element_type(ast_base, target_type);
            if element_type < 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < length {
                let slot_ptr: i32 = data_ptr + idx * 2 * WORD_SIZE;
                let element_value_ptr: i32 = slot_ptr;
                let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
                let current_type: i32 = load_i32(element_type_ptr);
                if try_convert_constant_value(
                    ast_base,
                    element_value_ptr,
                    current_type,
                    element_type,
                ) < 0 {
                    return -1;
                }
                store_i32(element_type_ptr, element_type);
                idx = idx + 1;
            };
            return 0;
        }
        if type_id_is_tuple(target_type) {
            let tuple_idx: i32 = tuple_type_index(target_type);
            if tuple_idx < 0 {
                return -1;
            }
            let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
            if element_count <= 0 {
                return 0;
            }
            let tuple_data_ptr: i32 = load_i32(value_ptr);
            if tuple_data_ptr <= 0 {
                return -1;
            }
            let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
            if elements_ptr < 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < element_count {
                let slot_ptr: i32 = tuple_data_ptr + idx * 2 * WORD_SIZE;
                let element_value_ptr: i32 = slot_ptr;
                let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
                let current_type: i32 = load_i32(element_type_ptr);
                let field_type: i32 = load_i32(elements_ptr + idx * WORD_SIZE);
                if try_convert_constant_value(
                    ast_base,
                    element_value_ptr,
                    current_type,
                    field_type,
                ) < 0 {
                    return -1;
                }
                store_i32(element_type_ptr, field_type);
                idx = idx + 1;
            };
            return 0;
        }
        return 0;
    }
    if value_type == BUILTIN_TYPE_ID_TYPE {
        let recorded_type_id: i32 = load_i32(value_ptr);
        if materialize_type_like_value_into(
            ast_base,
            recorded_type_id,
            target_type,
            value_ptr,
            0,
        ) < 0 {
            return -1;
        }
        return 0;
    }
    if type_id_is_integer(value_type) && type_id_is_integer(target_type) {
        let normalized: i32 = normalize_integer_value(load_i32(value_ptr), value_type);
        let cast_value: i32 = normalize_integer_value(normalized, target_type);
        store_i32(value_ptr, cast_value);
        return 0;
    }
    if value_type == BUILTIN_TYPE_ID_BOOL && target_type == BUILTIN_TYPE_ID_BOOL {
        let normalized: i32 = if load_i32(value_ptr) != 0 { 1 } else { 0 };
        store_i32(value_ptr, normalized);
        return 0;
    }
    if type_id_is_array(value_type) && type_id_is_array(target_type) {
        let value_length: i32 = array_type_length(ast_base, value_type);
        let target_length: i32 = array_type_length(ast_base, target_type);
        if value_length != target_length {
            return -1;
        }
        let data_ptr: i32 = load_i32(value_ptr);
        if value_length > 0 {
            if data_ptr <= 0 {
                return -1;
            }
        }
        let value_element_type: i32 = array_type_element_type(ast_base, value_type);
        let target_element_type: i32 = array_type_element_type(ast_base, target_type);
        if value_element_type < 0 || target_element_type < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < value_length {
            let slot_ptr: i32 = data_ptr + idx * 2 * WORD_SIZE;
            let element_value_ptr: i32 = slot_ptr;
            let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
            let current_type: i32 = load_i32(element_type_ptr);
            if try_convert_constant_value(
                ast_base,
                element_value_ptr,
                current_type,
                target_element_type,
            ) < 0 {
                return -1;
            }
            store_i32(element_type_ptr, target_element_type);
            idx = idx + 1;
        };
        store_i32(value_ptr, data_ptr);
        return 0;
    }
    if type_id_is_tuple(value_type) && type_id_is_tuple(target_type) {
        let value_idx: i32 = tuple_type_index(value_type);
        let target_idx: i32 = tuple_type_index(target_type);
        if value_idx < 0 || target_idx < 0 {
            return -1;
        }
        let value_count: i32 = ast_tuple_type_element_count(ast_base, value_idx);
        let target_count: i32 = ast_tuple_type_element_count(ast_base, target_idx);
        if value_count != target_count {
            return -1;
        }
        let tuple_data_ptr: i32 = load_i32(value_ptr);
        if value_count > 0 {
            if tuple_data_ptr <= 0 {
                return -1;
            }
        }
        let value_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, value_idx);
        let target_elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, target_idx);
        if value_elements_ptr < 0 || target_elements_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < value_count {
            let slot_ptr: i32 = tuple_data_ptr + idx * 2 * WORD_SIZE;
            let element_value_ptr: i32 = slot_ptr;
            let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
            let current_type: i32 = load_i32(element_type_ptr);
            let field_type: i32 = load_i32(target_elements_ptr + idx * WORD_SIZE);
            if try_convert_constant_value(
                ast_base,
                element_value_ptr,
                current_type,
                field_type,
            ) < 0 {
                return -1;
            }
            store_i32(element_type_ptr, field_type);
            idx = idx + 1;
        };
        store_i32(value_ptr, tuple_data_ptr);
        return 0;
    }
    -1
}

fn materialize_constant_value_expression(
    ast_base: i32,
    value: i32,
    type_id: i32,
    location_offset: i32,
) -> i32 {
    if type_id < 0 {
        return -1;
    }
    if type_id_is_array(type_id) {
        let length: i32 = array_type_length(ast_base, type_id);
        if length <= 0 {
            return -1;
        }
        if value <= 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_call_data_alloc(ast_base, length);
        if metadata_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < length {
            let slot_ptr: i32 = value + idx * 2 * WORD_SIZE;
            let element_value: i32 = load_i32(slot_ptr);
            let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
            if element_type < 0 {
                return -1;
            }
            let element_expr: i32 = materialize_constant_value_expression(
                ast_base,
                element_value,
                element_type,
                location_offset,
            );
            if element_expr < 0 {
                return -1;
            }
            store_i32(metadata_ptr + idx * WORD_SIZE, element_expr);
            idx = idx + 1;
        };
        let expr_index: i32 =
            ast_expr_alloc_array_list(ast_base, metadata_ptr, length, location_offset);
        if expr_index < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, type_id);
        return expr_index;
    }
    if type_id_is_tuple(type_id) {
        let tuple_idx: i32 = tuple_type_index(type_id);
        if tuple_idx < 0 {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count < 0 {
            return -1;
        }
        let metadata_ptr: i32 = if element_count > 0 {
            ast_call_data_alloc(ast_base, element_count)
        } else {
            0
        };
        if element_count > 0 {
            if metadata_ptr < 0 {
                return -1;
            }
            if value <= 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < element_count {
                let slot_ptr: i32 = value + idx * 2 * WORD_SIZE;
                let element_value: i32 = load_i32(slot_ptr);
                let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
                if element_type < 0 {
                    return -1;
                }
                let element_expr: i32 = materialize_constant_value_expression(
                    ast_base,
                    element_value,
                    element_type,
                    location_offset,
                );
                if element_expr < 0 {
                    return -1;
                }
                store_i32(metadata_ptr + idx * WORD_SIZE, element_expr);
                idx = idx + 1;
            };
        }
        let expr_index: i32 = ast_expr_alloc_tuple(ast_base, metadata_ptr, element_count);
        if expr_index < 0 {
            return -1;
        }
        ast_expr_entry_set_extra(ast_base, expr_index, location_offset);
        ast_expr_set_type(ast_base, expr_index, type_id);
        return expr_index;
    }
    let expr_index: i32 = ast_expr_alloc_literal(ast_base, value, type_id);
    if expr_index < 0 {
        return -1;
    }
    ast_expr_entry_set_extra(ast_base, expr_index, location_offset);
    expr_index
}

fn replace_expression_with_constant_value(
    ast_base: i32,
    expr_index: i32,
    value: i32,
    type_id: i32,
    location_offset: i32,
) -> i32 {
    if type_id < 0 {
        return -1;
    }
    if type_id_is_array(type_id) {
        let length: i32 = array_type_length(ast_base, type_id);
        if length <= 0 {
            return -1;
        }
        if value <= 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_call_data_alloc(ast_base, length);
        if metadata_ptr < 0 {
            return -1;
        }
        let mut idx: i32 = 0;
        while idx < length {
            let slot_ptr: i32 = value + idx * 2 * WORD_SIZE;
            let element_value: i32 = load_i32(slot_ptr);
            let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
            if element_type < 0 {
                return -1;
            }
            let element_expr: i32 = materialize_constant_value_expression(
                ast_base,
                element_value,
                element_type,
                location_offset,
            );
            if element_expr < 0 {
                return -1;
            }
            store_i32(metadata_ptr + idx * WORD_SIZE, element_expr);
            idx = idx + 1;
        };
        let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
        store_i32(entry_ptr, 37);
        store_i32(entry_ptr + WORD_SIZE, metadata_ptr);
        store_i32(entry_ptr + 2 * WORD_SIZE, length);
        store_i32(entry_ptr + 3 * WORD_SIZE, 0);
        ast_expr_entry_set_extra(ast_base, expr_index, location_offset);
        ast_expr_set_type(ast_base, expr_index, type_id);
        return 0;
    }
    if type_id_is_tuple(type_id) {
        let tuple_idx: i32 = tuple_type_index(type_id);
        if tuple_idx < 0 {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count < 0 {
            return -1;
        }
        let metadata_ptr: i32 = if element_count > 0 {
            ast_call_data_alloc(ast_base, element_count)
        } else {
            0
        };
        if element_count > 0 {
            if metadata_ptr < 0 {
                return -1;
            }
            if value <= 0 {
                return -1;
            }
            let mut idx: i32 = 0;
            while idx < element_count {
                let slot_ptr: i32 = value + idx * 2 * WORD_SIZE;
                let element_value: i32 = load_i32(slot_ptr);
                let element_type: i32 = load_i32(slot_ptr + WORD_SIZE);
                if element_type < 0 {
                    return -1;
                }
                let element_expr: i32 = materialize_constant_value_expression(
                    ast_base,
                    element_value,
                    element_type,
                    location_offset,
                );
                if element_expr < 0 {
                    return -1;
                }
                store_i32(metadata_ptr + idx * WORD_SIZE, element_expr);
                idx = idx + 1;
            };
        }
        let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
        store_i32(entry_ptr, 40);
        store_i32(entry_ptr + WORD_SIZE, metadata_ptr);
        store_i32(entry_ptr + 2 * WORD_SIZE, element_count);
        store_i32(entry_ptr + 3 * WORD_SIZE, 0);
        ast_expr_entry_set_extra(ast_base, expr_index, location_offset);
        ast_expr_set_type(ast_base, expr_index, type_id);
        return 0;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    store_i32(entry_ptr, 0);
    store_i32(entry_ptr + WORD_SIZE, value);
    store_i32(entry_ptr + 2 * WORD_SIZE, 0);
    store_i32(entry_ptr + 3 * WORD_SIZE, 0);
    ast_expr_entry_set_extra(ast_base, expr_index, 0);
    ast_expr_set_type(ast_base, expr_index, type_id);
    0
}

fn interpret_constant_entry(ast_base: i32, const_entry_ptr: i32) -> i32 {
    if const_entry_ptr < 0 {
        return -1;
    }
    let eval_state: i32 = ast_constant_entry_eval_state(const_entry_ptr);
    if eval_state == AST_CONSTANT_EVAL_STATE_EVALUATED {
        return 0;
    }
    if eval_state == AST_CONSTANT_EVAL_STATE_EVALUATING {
        return -1;
    }
    let expr_index: i32 = ast_constant_entry_expr_index(const_entry_ptr);
    if expr_index < 0 {
        ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATED);
        return 0;
    }
    let const_type_ptr: i32 = ast_constant_entry_type_ptr(const_entry_ptr);
    let mut target_type: i32 = load_i32(const_type_ptr);
    if target_type >= 0 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            ast_expr_set_type(ast_base, expr_index, target_type);
        }
    }
    ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATING);
    let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
    let eval_value_ptr: i32 = eval_base;
    let eval_type_ptr: i32 = eval_value_ptr + 4;
    let eval_stack_top_ptr: i32 = eval_type_ptr + 4;
    let eval_stack_base: i32 = eval_stack_top_ptr + 4;
    store_i32(eval_stack_top_ptr, 0);
    if interpret_constant_expression(
        ast_base,
        expr_index,
        eval_stack_base,
        eval_stack_top_ptr,
        eval_value_ptr,
        eval_type_ptr,
        0,
        0,
        0,
    ) < 0 {
        ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_UNEVALUATED);
        return -1;
    }
    let mut literal_value: i32 = load_i32(eval_value_ptr);
    let literal_type: i32 = load_i32(eval_type_ptr);
    target_type = load_i32(const_type_ptr);
    if target_type < 0 {
        target_type = literal_type;
    }
    if try_convert_constant_value(ast_base, eval_value_ptr, literal_type, target_type) < 0 {
        if literal_type < 0 {
            ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_UNEVALUATED);
            return -1;
        }
        target_type = literal_type;
    }
    literal_value = load_i32(eval_value_ptr);
    store_i32(ast_constant_entry_value_ptr(const_entry_ptr), literal_value);
    store_i32(const_type_ptr, target_type);
    ast_constant_entry_set_eval_state(const_entry_ptr, AST_CONSTANT_EVAL_STATE_EVALUATED);
    0
}

fn append_failure_canonical_bytes(out_ptr: i32, bytes_ptr: i32, length: i32) -> i32 {
    if out_ptr <= 0 {
        return 0;
    }
    if length <= 0 {
        return 0;
    }
    let mut write_offset: i32 = 0;
    loop {
        if write_offset >= FAILURE_DETAIL_CAPACITY {
            return 0;
        }
        let existing: i32 = load_u8(out_ptr + write_offset);
        if existing == 0 {
            break;
        }
        write_offset = write_offset + 1;
    };
    let mut idx: i32 = 0;
    while idx < length {
        if write_offset >= FAILURE_DETAIL_CAPACITY {
            return 0;
        }
        let element_ptr: i32 = bytes_ptr + idx * 2 * WORD_SIZE;
        let byte_value: i32 = load_i32(element_ptr);
        store_u8(out_ptr + write_offset, byte_value);
        write_offset = write_offset + 1;
        idx = idx + 1;
    };
    if write_offset < FAILURE_DETAIL_CAPACITY {
        store_u8(out_ptr + write_offset, 0);
        write_offset = write_offset + 1;
    }
    while write_offset < FAILURE_DETAIL_CAPACITY {
        store_u8(out_ptr + write_offset, 0);
        write_offset = write_offset + 1;
    };
    0
}

fn try_record_struct_intrinsic_failure(
    out_ptr: i32,
    ast_base: i32,
    const_entry_ptr: i32,
) -> bool {
    if out_ptr <= 0 {
        return false;
    }
    if load_u8(out_ptr) != 0 {
        return false;
    }
    let expr_index: i32 = ast_constant_entry_expr_index(const_entry_ptr);
    if expr_index < 0 {
        return false;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return false;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let expr_kind: i32 = load_i32(entry_ptr);
    if expr_kind != 1 {
        return false;
    }
    let metadata_ptr: i32 = ast_expr_call_metadata(ast_base, expr_index);
    if metadata_ptr <= 0 {
        return false;
    }
    let callee_ptr: i32 = call_metadata_callee_index_ptr(metadata_ptr);
    if callee_ptr <= 0 {
        return false;
    }
    let callee_index: i32 = load_i32(callee_ptr);
    if callee_index != CALL_METADATA_INTRINSIC_STRUCT {
        return false;
    }
    let payload_slot_ptr: i32 = call_metadata_template_payload_ptr(metadata_ptr);
    if payload_slot_ptr <= 0 {
        return false;
    }
    let failure_ptr: i32 = load_i32(payload_slot_ptr);
    if failure_ptr <= 0 {
        return false;
    }
    let failure_kind: i32 = load_i32(failure_ptr);
    if failure_kind == STRUCT_INTRINSIC_FAILURE_DUPLICATE_FIELD {
        let name_location: i32 = load_i32(failure_ptr + WORD_SIZE);
        let str_length: i32 = load_i32(failure_ptr + 2 * WORD_SIZE);
        if str_length < 0 {
            return false;
        }
        let canonical_pairs_ptr: i32 = load_i32(failure_ptr + 3 * WORD_SIZE);
        if str_length > 0 {
            if canonical_pairs_ptr <= 0 {
                return false;
            }
        }
        let mut trimmed_len: i32 = str_length;
        loop {
            if trimmed_len <= 0 {
                break;
            }
            let element_ptr: i32 =
                canonical_pairs_ptr + (trimmed_len - 1) * 2 * WORD_SIZE;
            let last_byte: i32 = load_i32(element_ptr);
            if last_byte == 0 {
                trimmed_len = trimmed_len - 1;
                continue;
            }
            break;
        };
        if trimmed_len < 0 {
            trimmed_len = 0;
        }
        let mut location_offset: i32 = name_location;
        if location_offset < 0 {
            location_offset = ast_expr_location(ast_base, expr_index);
        }
        let module_context: (i32, i32, i32) =
            resolve_constant_failure_module_context(out_ptr, const_entry_ptr);
        let module_index: i32 = module_context.0;
        let module_base: i32 = module_context.1;
        let module_len: i32 = module_context.2;
        let message: [u8; 23] = "duplicate struct field ";
        write_failure_detail_with_location(
            out_ptr,
            module_index,
            module_base,
            module_len,
            location_offset,
            23,
            message,
        );
        if trimmed_len > 0 {
            append_failure_canonical_bytes(out_ptr, canonical_pairs_ptr, trimmed_len);
        }
        return true;
    }
    if failure_kind == STRUCT_INTRINSIC_FAILURE_TEMPLATE_TYPE_MISMATCH {
        let mut location_offset: i32 = find_call_metadata_location(ast_base, metadata_ptr);
        if location_offset < 0 {
            location_offset = load_i32(failure_ptr + WORD_SIZE);
        }
        if location_offset < 0 {
            location_offset = ast_expr_location(ast_base, expr_index);
        }
        let module_context: (i32, i32, i32) =
            resolve_constant_failure_module_context(out_ptr, const_entry_ptr);
        let module_index: i32 = module_context.0;
        let module_base: i32 = module_context.1;
        let module_len: i32 = module_context.2;
        let message: [u8; 47] =
            "const parameter template expected type mismatch";
        write_failure_detail_with_location(
            out_ptr,
            module_index,
            module_base,
            module_len,
            location_offset,
            47,
            message,
        );
        return true;
    }
    if failure_kind != STRUCT_INTRINSIC_FAILURE_INVALID_PROPS {
        return false;
    }
    let props_location: i32 = load_i32(failure_ptr + WORD_SIZE);
    let mut location_offset: i32 = props_location;
    if location_offset < 0 {
        location_offset = ast_expr_location(ast_base, expr_index);
    }
    let module_context: (i32, i32, i32) =
        resolve_constant_failure_module_context(out_ptr, const_entry_ptr);
    let module_index: i32 = module_context.0;
    let module_base: i32 = module_context.1;
    let module_len: i32 = module_context.2;
    let message: [u8; 60] =
        "struct intrinsic properties must be an array of field tuples";
    write_failure_detail_with_location(
        out_ptr,
        module_index,
        module_base,
        module_len,
        location_offset,
        60,
        message,
    );
    true
}

fn interpret_program_constants(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        }
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        if interpret_constant_entry(ast_base, const_entry_ptr) < 0 {
            if try_record_struct_intrinsic_failure(out_ptr, ast_base, const_entry_ptr) {
                return -1;
            }
            if out_ptr > 0 {
                if load_u8(out_ptr) == 0 {
                    let message: [u8; 48] =
                        "const initializer must be compile-time evaluable";
                    let module_context: (i32, i32, i32) =
                        resolve_constant_failure_module_context(out_ptr, const_entry_ptr);
                    let module_index: i32 = module_context.0;
                    let module_base: i32 = module_context.1;
                    let module_len: i32 = module_context.2;
                    let location_offset: i32 =
                        ast_constant_entry_name_start(const_entry_ptr);
                    write_failure_detail_with_location(
                        out_ptr,
                        module_index,
                        module_base,
                        module_len,
                        location_offset,
                        48,
                        message,
                    );
                }
            }
            record_type_metadata_debug(out_ptr, 200, const_idx, const_entry_ptr);
            return -1;
        }
        const_idx = const_idx + 1;
    };

    let mut func_idx: i32 = 0;
    loop {
        if func_idx >= func_count {
            break;
        }
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if interpret_constants_visit_call_metadata(ast_base, metadata_ptr) < 0 {
                return -1;
            }
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if interpret_constants_visit_expression(ast_base, expr_index) < 0 {
                return -1;
            }
        }
        func_idx = func_idx + 1;
    };

    let expr_count: i32 = ast_expr_count(ast_base);
    let mut expr_idx: i32 = 0;
    loop {
        if expr_idx >= expr_count {
            break;
        }
        // Placeholder for future constant interpretation work that may require
        // inspecting each expression node in order.
        expr_idx = expr_idx + 1;
    };
    0
}

fn validate_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let constants_count: i32 = ast_constants_count(ast_base);
    let mut const_idx: i32 = 0;
    loop {
        if const_idx >= constants_count {
            break;
        }
        let const_entry_ptr: i32 = ast_constant_entry_ptr(ast_base, const_idx);
        let const_type_ptr: i32 = ast_constant_entry_type_ptr(const_entry_ptr);
        let const_type_id: i32 = load_i32(const_type_ptr);
        if const_type_id >= 0 {
            let resolved_const_type: i32 = resolve_type_id(out_ptr, ast_base, const_type_id);
            if resolved_const_type < 0 {
                return record_type_metadata_failure_with_debug(out_ptr, 300, const_idx, const_type_id);
            }
            if resolved_const_type != const_type_id {
                store_i32(const_type_ptr, resolved_const_type);
            }
        }
        const_idx = const_idx + 1;
    };
    let mut idx: i32 = 0;
    loop {
        let total_funcs: i32 = ast_functions_count(ast_base);
        if total_funcs < 0 {
            record_type_metadata_failure(out_ptr);
            return -1;
        }
        if idx >= total_funcs {
            break;
        }
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let name_ptr: i32 = load_i32(entry_ptr);
        let name_len: i32 = load_i32(entry_ptr + 4);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let caller_is_const: bool = ast_function_is_const(ast_base, idx);
        let mut other_idx: i32 = idx + 1;
        loop {
            if other_idx >= func_count {
                break;
            }
            let other_entry_ptr: i32 = ast_function_entry_ptr(ast_base, other_idx);
            let other_name_ptr: i32 = load_i32(other_entry_ptr);
            let other_name_len: i32 = load_i32(other_entry_ptr + 4);
            if name_len == other_name_len {
                if identifiers_match(name_ptr, name_len, other_name_ptr, other_name_len) {
                    let detail_out_ptr: i32 = out_ptr;
                    if detail_out_ptr > 0 {
                        if load_u8(detail_out_ptr) == 0 {
                            let module_index: i32 =
                                ast_function_entry_module_index(ast_base, idx);
                            let mut module_base: i32 =
                                ast_function_entry_module_base(ast_base, idx);
                            let mut module_len: i32 =
                                ast_function_entry_module_len(ast_base, idx);
                            if (module_base <= 0 || module_len <= 0) && module_index >= 0 {
                                module_base = module_entry_content(module_index);
                                module_len = module_entry_content_len(module_index);
                            }
                            let name_start: i32 =
                                ast_function_entry_name_start(ast_base, idx);
                            let message: [u8; 30] = "duplicate function declaration";
                            write_failure_detail_with_location(
                                detail_out_ptr,
                                module_index,
                                module_base,
                                module_len,
                                name_start,
                                30,
                                message,
                            );
                        }
                    }
                    return -1;
                }
            }
            other_idx = other_idx + 1;
        };

        if param_count > 0 {
            let param_types_ptr: i32 = load_i32(entry_ptr + 24);
            if param_types_ptr < 0 {
                return -1;
            }
            let mut param_idx: i32 = 0;
            loop {
                if param_idx >= param_count {
                    break;
                }
                let param_type_ptr: i32 = param_types_ptr + param_idx * 4;
                let param_type_id: i32 = load_i32(param_type_ptr);
                if param_type_id < 0 {
                    if !ast_function_param_requires_specialization(ast_base, idx, param_idx) {
                        return -1;
                    }
                    param_idx = param_idx + 1;
                    continue;
                }
                let resolved_param_type: i32 =
                    resolve_type_id(out_ptr, ast_base, param_type_id);
                if resolved_param_type < 0 {
                    return -1;
                }
                if resolved_param_type != param_type_id {
                    store_i32(param_type_ptr, resolved_param_type);
                }
                param_idx = param_idx + 1;
            };
        }
        let mut fn_return_type: i32 = load_i32(entry_ptr + 28);
        if fn_return_type >= 0 {
            if fn_return_type != BUILTIN_TYPE_ID_TYPE {
                let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, fn_return_type);
                if resolved_return < 0 {
                    return -1;
                }
                if resolved_return != fn_return_type {
                    store_i32(entry_ptr + 28, resolved_return);
                    fn_return_type = resolved_return;
                }
            }
        }

        if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            let call_location_offset: i32 =
                find_call_metadata_location(ast_base, metadata_ptr);
            let updated_metadata: i32 = resolve_call_metadata(
                out_ptr,
                ast_base,
                metadata_ptr,
                total_funcs,
                caller_is_const,
                idx,
                call_location_offset,
            );
            if updated_metadata < 0 {
                return -1;
            }
            if updated_metadata != metadata_ptr {
                store_i32(entry_ptr + 16, updated_metadata);
            }
        } else if body_kind == 2 {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            if resolve_expression(
                out_ptr,
                ast_base,
                expr_index,
                total_funcs,
                caller_is_const,
                idx,
            ) < 0 {
                return -1;
            }
            if caller_is_const {
                if param_count == 0 {
                    if !ast_function_has_const_params(ast_base, idx) {
                        if fn_return_type == BUILTIN_TYPE_ID_TYPE {
                            let locals_count: i32 = load_i32(entry_ptr + 20);
                            let eval_base: i32 =
                                ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                            let eval_value_ptr: i32 = eval_base;
                            let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                            let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                            let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                            let saved_eval_top: i32 = load_i32(eval_stack_top_ptr);
                            let env_total: i32 = locals_count;
                            let env_ptr: i32 = if env_total > 0 {
                                eval_stack_base + saved_eval_top
                            } else {
                                0
                            };
                            if env_total > 0 {
                                let mut fill_idx: i32 = 0;
                                while fill_idx < env_total {
                                    let slot_ptr: i32 = env_ptr + fill_idx * 8;
                                    store_i32(slot_ptr, 0);
                                    store_i32(slot_ptr + 4, -1);
                                    fill_idx = fill_idx + 1;
                                };
                            }
                            store_i32(
                                eval_stack_top_ptr,
                                saved_eval_top + env_total * 8,
                            );
                            let eval_status: i32 = interpret_constant_expression(
                                ast_base,
                                expr_index,
                                eval_stack_base,
                                eval_stack_top_ptr,
                                eval_value_ptr,
                                eval_type_ptr,
                                env_ptr,
                                0,
                                env_total,
                            );
                            store_i32(eval_stack_top_ptr, saved_eval_top);
                            if eval_status < 0 {
                                // Defer diagnostics to actual uses of the function.
                                store_i32(eval_stack_top_ptr, saved_eval_top);
                            }
                        }
                    }
                }
            }
            if fn_return_type >= 0 {
                let expr_type: i32 = ast_expr_type(ast_base, expr_index);
                let expect_array: bool = type_id_is_array(fn_return_type);
                let expr_is_array: bool = expr_type >= 0 && type_id_is_array(expr_type);
                if expect_array || expr_is_array {
                    if expr_type >= 0 {
                        if expr_type != fn_return_type {
                            let expr_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
                            let expr_kind: i32 = load_i32(expr_entry_ptr);
                            let location_offset: i32 = if expr_kind == 35 {
                                ast_expr_array_repeat_location(ast_base, expr_index)
                            } else if expr_kind == 37 {
                                ast_expr_array_list_location(ast_base, expr_index)
                            } else {
                                load_i32(expr_entry_ptr + 12)
                            };
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                idx,
                                location_offset,
                                56,
                                "array expression type does not match expected array type",
                            );
                            return -1;
                        }
                    } else if !expression_guaranteed_diverges(ast_base, expr_index) {
                        return -1;
                    }
                }
            }
        }
        idx = idx + 1;
    };
    0
}

const RESOLVE_CONTROL_STACK_CAPACITY: i32 = 128;

const RESOLVE_LOOP_STACK_CAPACITY: i32 = 64;

const RESOLVE_LOCAL_STACK_CAPACITY: i32 = 512;

const RESOLVE_LOCAL_STACK_ENTRY_SIZE: i32 = 12;

fn resolve_local_array_repeat_init_index(
    ast_base: i32,
    local_stack_base: i32,
    local_stack_count_ptr: i32,
    local_index: i32,
) -> i32 {
    if local_stack_base <= 0 {
        return -1;
    }
    if local_stack_count_ptr <= 0 {
        return -1;
    }
    if local_index < 0 {
        return -1;
    }
    let total_count: i32 = load_i32(local_stack_count_ptr);
    if total_count <= 0 {
        return -1;
    }
    let mut search_local: i32 = local_index;
    let mut depth: i32 = 0;
    loop {
        if depth >= total_count {
            return -1;
        }
        if search_local < 0 {
            return -1;
        }
        let stack_count: i32 = load_i32(local_stack_count_ptr);
        if stack_count <= 0 {
            return -1;
        }
        let mut stack_idx: i32 = stack_count - 1;
        let mut follow_alias: bool = false;
        let mut found_entry: bool = false;
        loop {
            if stack_idx < 0 {
                break;
            }
            let entry_offset: i32 =
                local_stack_base + stack_idx * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
            let recorded_index: i32 = load_i32(entry_offset);
            if recorded_index == search_local {
                found_entry = true;
                let init_expr_index: i32 = load_i32(entry_offset + 4);
                if init_expr_index < 0 {
                    return -1;
                }
                let init_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, init_expr_index);
                let init_kind: i32 = load_i32(init_entry_ptr);
                if init_kind == 35 {
                    return init_expr_index;
                }
                if init_kind == 8 {
                    search_local = load_i32(init_entry_ptr + 4);
                    follow_alias = true;
                    break;
                }
                return -1;
            }
            stack_idx = stack_idx - 1;
        };
        if !found_entry {
            return -1;
        }
        if follow_alias {
            depth = depth + 1;
            continue;
        }
        return -1;
    };
}

fn tuple_literal_element_requires_const_specialization(
    ast_base: i32,
    value_index: i32,
) -> bool {
    if value_index < 0 {
        return false;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, value_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 35 {
        let length: i32 = ast_expr_array_repeat_length(ast_base, value_index);
        if length >= 0 {
            return false;
        }
        let length_expr_index: i32 = ast_expr_array_repeat_length_expr(ast_base, value_index);
        if length_expr_index < 0 {
            return false;
        }
        return true;
    }
    false
}

fn resolve_expression_internal(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    control_stack_base: i32,
    control_stack_count_ptr: i32,
    loop_stack_base: i32,
    loop_stack_count_ptr: i32,
    local_stack_base: i32,
    local_stack_count_ptr: i32,
    caller_func_index: i32,
    caller_is_const: bool,
) -> i32 {
    if expr_index < 0 {
        return -1;
    }
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    }
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let mut kind: i32 = load_i32(entry_ptr);
    if kind == 43 {
        if resolve_constant_reference(ast_base, expr_index) < 0 {
            let location_offset: i32 = load_i32(entry_ptr + 4);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                20,
                "identifier not found",
            );
            return -1;
        }
        kind = load_i32(entry_ptr);
    }
    if kind == 0 {
        return 0;
    }
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        }
        let call_location_offset: i32 = load_i32(entry_ptr + 12);
        let updated_metadata: i32 = resolve_call_metadata(
            out_ptr,
            ast_base,
            metadata_ptr,
            func_count,
            caller_is_const,
            caller_func_index,
            call_location_offset,
        );
        if updated_metadata < 0 {
            return -1;
        }
        if updated_metadata != metadata_ptr {
            store_i32(entry_ptr + 4, updated_metadata);
        }
        let callee_index: i32 =
            load_i32(call_metadata_callee_index_ptr(updated_metadata));
        if callee_index == CALL_METADATA_INTRINSIC_STRUCT {
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_TYPE);
            if caller_is_const {
                let eval_base: i32 =
                    ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                let eval_value_ptr: i32 = eval_base;
                let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                let saved_eval_top: i32 = load_i32(eval_stack_top_ptr);
                store_i32(eval_stack_top_ptr, 0);
                let eval_status: i32 = interpret_constant_expression(
                    ast_base,
                    expr_index,
                    eval_stack_base,
                    eval_stack_top_ptr,
                    eval_value_ptr,
                    eval_type_ptr,
                    0,
                    0,
                    0,
                );
                store_i32(eval_stack_top_ptr, saved_eval_top);
                if eval_status == CONST_EVAL_STATUS_OK {
                    if load_i32(eval_type_ptr) == BUILTIN_TYPE_ID_TYPE {
                        let literal_value: i32 = load_i32(eval_value_ptr);
                        let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
                        store_i32(entry_ptr, 0);
                        store_i32(entry_ptr + WORD_SIZE, literal_value);
                        store_i32(entry_ptr + 2 * WORD_SIZE, 0);
                        store_i32(entry_ptr + 3 * WORD_SIZE, 0);
                        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_TYPE);
                    }
                }
            }
            return 0;
        }
        if callee_index < 0 {
            return -1;
        }
        let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, callee_index);
        let mut return_type_id: i32 = load_i32(callee_entry_ptr + 28);
        if return_type_id >= 0 {
            let resolved_return: i32 = resolve_type_id(out_ptr, ast_base, return_type_id);
            if resolved_return < 0 {
                return -1;
            }
            return_type_id = resolved_return;
        } else if ast_function_return_requires_specialization(ast_base, callee_index) {
            let template_handle: i32 =
                ast_function_return_template_payload(ast_base, callee_index);
            if template_handle <= 0 {
                return -1;
            }
            let template_kind: i32 =
                ast_function_return_template_kind(ast_base, callee_index);
            if template_kind == TYPE_TEMPLATE_KIND_NONE {
                return -1;
            }
            if template_kind != TYPE_TEMPLATE_KIND_ARRAY_LENGTH
                && template_kind != TYPE_TEMPLATE_KIND_TYPE_EXPR
            {
                return -1;
            }
            if validate_function_type_template(ast_base, callee_index, template_handle) < 0 {
                return -1;
            }
            let base_type: i32 =
                ast_function_return_template_base_type(ast_base, callee_index);
            if base_type >= 0 {
                let resolved_base: i32 = resolve_type_id(out_ptr, ast_base, base_type);
                if resolved_base < 0 {
                    return -1;
                }
            }
            let env_ptr: i32 = call_metadata_const_env_ptr(metadata_ptr);
            if env_ptr <= 0 {
                if call_metadata_const_usage_count(metadata_ptr) > 0 {
                    return 0;
                }
                return -1;
            }
            let env_param_count: i32 = load_i32(env_ptr);
            if env_param_count < 0 {
                return -1;
            }
            let expected_params: i32 = call_metadata_arg_count(metadata_ptr);
            if env_param_count != expected_params {
                return -1;
            }
            let env_values_ptr: i32 = env_ptr + WORD_SIZE;
            let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
            let eval_value_ptr: i32 = eval_base + MAX_PARAMS * 8;
            let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
            let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
            let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
            store_i32(eval_stack_top_ptr, 0);
            let specialized_type: i32 = type_template_resolve_type(
                ast_base,
                template_handle,
                env_values_ptr,
                env_param_count,
                eval_stack_base,
                eval_stack_top_ptr,
                eval_value_ptr,
                eval_type_ptr,
            );
            if specialized_type < 0 {
                return -1;
            }
            let resolved_specialized: i32 =
                resolve_type_id(out_ptr, ast_base, specialized_type);
            if resolved_specialized < 0 {
                return -1;
            }
            return_type_id = resolved_specialized;
        }
        ast_expr_set_type(ast_base, expr_index, return_type_id);
        if ast_function_is_const(ast_base, callee_index) {
            let runtime_param_total: i32 =
                ast_function_runtime_param_count(ast_base, callee_index);
            if runtime_param_total < 0 {
                return -1;
            }
            if runtime_param_total == 0 {
                let env_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                let eval_value_ptr: i32 = env_base + MAX_PARAMS * 8;
                let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                let saved_eval_top: i32 = load_i32(eval_stack_top_ptr);
                store_i32(eval_stack_top_ptr, 0);
                let mut evaluation_failed: bool = false;
                let mut literal_type: i32 = -1;
                let mut literal_value: i32 = 0;
                let mut param_values_ptr: i32 = 0;
                let mut total_param_count: i32 = ast_function_param_count(ast_base, callee_index);
                if total_param_count < 0 {
                    total_param_count = 0;
                    evaluation_failed = true;
                } else if total_param_count > MAX_PARAMS {
                    evaluation_failed = true;
                }
                let env_ptr: i32 = call_metadata_const_env_ptr(updated_metadata);
                if !evaluation_failed {
                    if total_param_count > 0 {
                        if env_ptr <= 0 {
                            evaluation_failed = true;
                        } else {
                            let recorded_param_count: i32 = load_i32(env_ptr);
                            if recorded_param_count != total_param_count {
                                evaluation_failed = true;
                            } else {
                                param_values_ptr = env_base;
                                let values_ptr: i32 = env_ptr + WORD_SIZE;
                                let mut param_idx: i32 = 0;
                                while param_idx < total_param_count {
                                    let dst_ptr: i32 =
                                        param_values_ptr + param_idx * 2 * WORD_SIZE;
                                    let entry_ptr: i32 =
                                        values_ptr + param_idx * 2 * WORD_SIZE;
                                    let arg_entry: ConstEnvEntry =
                                        const_env_entry_load(entry_ptr);
                                    if arg_entry.type < 0 {
                                        evaluation_failed = true;
                                        break;
                                    }
                                    const_env_entry_store(dst_ptr, arg_entry);
                                    param_idx = param_idx + 1;
                                };
                            }
                        }
                    }
                }
                let mut env_total: i32 = total_param_count;
                let mut body_expr_index: i32 = -1;
                if !evaluation_failed {
                    let callee_entry_ptr: i32 = ast_function_entry_ptr(ast_base, callee_index);
                    let body_kind: i32 = load_i32(callee_entry_ptr + 12);
                    if body_kind != 2 {
                        evaluation_failed = true;
                    } else {
                        body_expr_index = load_i32(callee_entry_ptr + 16);
                        if body_expr_index < 0 {
                            evaluation_failed = true;
                        }
                    }
                    let locals_count: i32 = load_i32(callee_entry_ptr + 20);
                    if locals_count < 0 {
                        evaluation_failed = true;
                    } else {
                        env_total = env_total + locals_count;
                        if env_total < 0 || env_total > MAX_PARAMS {
                            evaluation_failed = true;
                        } else if env_total > 0 {
                            if param_values_ptr == 0 {
                                param_values_ptr = env_base;
                                let mut init_idx: i32 = 0;
                                while init_idx < total_param_count {
                                    let dst_ptr: i32 =
                                        param_values_ptr + init_idx * 2 * WORD_SIZE;
                                    const_env_entry_store(
                                        dst_ptr,
                                        ConstEnvEntry { value: 0, type: -1 },
                                    );
                                    init_idx = init_idx + 1;
                                };
                            }
                            let mut fill_idx: i32 = total_param_count;
                            while fill_idx < env_total {
                                let dst_ptr: i32 =
                                    param_values_ptr + fill_idx * 2 * WORD_SIZE;
                                const_env_entry_store(
                                    dst_ptr,
                                    ConstEnvEntry { value: 0, type: -1 },
                                );
                                fill_idx = fill_idx + 1;
                            };
                        }
                    }
                }
                let mut eval_status: i32 = -1;
                if !evaluation_failed {
                    eval_status = interpret_constant_expression(
                        ast_base,
                        body_expr_index,
                        eval_stack_base,
                        eval_stack_top_ptr,
                        eval_value_ptr,
                        eval_type_ptr,
                        param_values_ptr,
                        total_param_count,
                        env_total,
                    );
                    if eval_status < 0 {
                        evaluation_failed = true;
                    } else if eval_status != CONST_EVAL_STATUS_OK
                        && eval_status != CONST_EVAL_STATUS_RETURN
                    {
                        evaluation_failed = true;
                    } else {
                        literal_type = load_i32(eval_type_ptr);
                        if literal_type < 0 {
                            evaluation_failed = true;
                        } else {
                            let mut target_type: i32 = ast_expr_type(ast_base, expr_index);
                            if target_type < 0 {
                                target_type = literal_type;
                            }
                            if target_type < 0 {
                                evaluation_failed = true;
                            } else if try_convert_constant_value(
                                ast_base,
                                eval_value_ptr,
                                literal_type,
                                target_type,
                            ) < 0 {
                                evaluation_failed = true;
                            } else {
                                literal_type = target_type;
                                literal_value = load_i32(eval_value_ptr);
                            }
                        }
                    }
                }
                store_i32(eval_stack_top_ptr, saved_eval_top);
                if !evaluation_failed {
                    if replace_expression_with_constant_value(
                        ast_base,
                        expr_index,
                        literal_value,
                        literal_type,
                        call_location_offset,
                    ) < 0 {
                        evaluation_failed = true;
                    }
                }
                if evaluation_failed {
                    let mut resolved_location_offset: i32 = call_location_offset;
                    if resolved_location_offset < 0 {
                        resolved_location_offset =
                            find_call_metadata_location(ast_base, updated_metadata);
                    }
                    let message: [u8; 28] = "const call evaluation failed";
                    let recorded: bool = try_record_call_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        resolved_location_offset,
                        28,
                        message,
                    );
                    if !recorded {
                        record_failure_detail(out_ptr, 28, message);
                    }
                    return -1;
                }
                let original_arg_count: i32 = call_metadata_arg_count(updated_metadata);
                let env_slot_ptr: i32 = call_metadata_const_env_ptr_ptr(updated_metadata);
                let recorded_env_ptr: i32 = if env_slot_ptr > 0 {
                    load_i32(env_slot_ptr)
                } else {
                    0
                };
                if original_arg_count > 0 {
                    let args_base: i32 = call_metadata_args_base(updated_metadata);
                    if args_base > 0 {
                        let mut clear_idx: i32 = 0;
                        while clear_idx < original_arg_count {
                            store_i32(args_base + clear_idx * WORD_SIZE, -1);
                            clear_idx = clear_idx + 1;
                        };
                    }
                }
                store_i32(updated_metadata, 0);
                store_i32(updated_metadata + WORD_SIZE, 0);
                store_i32(updated_metadata + 2 * WORD_SIZE, 0);
                store_i32(call_metadata_callee_index_ptr(updated_metadata), -1);
                if env_slot_ptr > 0 {
                    store_i32(env_slot_ptr, 0);
                }
                let extra_base: i32 = call_metadata_extra_slot_base(updated_metadata);
                if extra_base > 0 {
                    let mut extra_idx: i32 = 0;
                    while extra_idx < 5 {
                        store_i32(extra_base + extra_idx * WORD_SIZE, 0);
                        extra_idx = extra_idx + 1;
                    };
                }
                if recorded_env_ptr > 0 {
                    store_i32(recorded_env_ptr, 0);
                }
                if !type_id_is_array(literal_type) && !type_id_is_tuple(literal_type) {
                    store_i32(entry_ptr, 0);
                    store_i32(entry_ptr + WORD_SIZE, literal_value);
                    store_i32(entry_ptr + 2 * WORD_SIZE, 0);
                    store_i32(entry_ptr + 3 * WORD_SIZE, 0);
                    store_i32(entry_ptr + AST_EXPR_ENTRY_EXTRA_OFFSET, 0);
                    ast_expr_set_type(ast_base, expr_index, literal_type);
                } else {
                    if resolve_expression_internal(
                        out_ptr,
                        ast_base,
                        expr_index,
                        func_count,
                        control_stack_base,
                        control_stack_count_ptr,
                        loop_stack_base,
                        loop_stack_count_ptr,
                        local_stack_base,
                        local_stack_count_ptr,
                        caller_func_index,
                        caller_is_const,
                    ) < 0 {
                        return -1;
                    }
                }
            }
        }
        return 0;
    }
    if kind == 6 {
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            }
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
            }
        }
        return 0;
    }
    if kind == 8 {
        let mut expr_type: i32 = ast_expr_type(ast_base, expr_index);
        let initial_type: i32 = expr_type;
        let mut resolved_initial_type: i32 = -1;
        let mut recorded_type: i32 = -1;
        let mut recorded_entry_offset: i32 = -1;
        let mut init_expr_index: i32 = -1;
        if local_stack_base > 0 && local_stack_count_ptr > 0 {
            let local_index: i32 = load_i32(entry_ptr + 4);
            if local_index >= 0 {
                let stack_count: i32 = load_i32(local_stack_count_ptr);
                let mut stack_idx: i32 = stack_count - 1;
                loop {
                    if stack_idx < 0 {
                        break;
                    }
                    let entry_offset: i32 =
                        local_stack_base + stack_idx * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
                    let recorded_index: i32 = load_i32(entry_offset);
                    if recorded_index == local_index {
                        recorded_entry_offset = entry_offset;
                        init_expr_index = load_i32(entry_offset + 4);
                        let mut stack_type: i32 = load_i32(entry_offset + 8);
                        if stack_type < 0 {
                            if init_expr_index >= 0 {
                                stack_type = ast_expr_type(ast_base, init_expr_index);
                                if stack_type >= 0 {
                                    store_i32(entry_offset + 8, stack_type);
                                }
                            }
                        }
                        recorded_type = stack_type;
                        if expr_type < 0 {
                            if stack_type >= 0 {
                                expr_type = stack_type;
                                ast_expr_set_type(ast_base, expr_index, expr_type);
                            }
                        }
                        break;
                    }
                    stack_idx = stack_idx - 1;
                };
            }
        }
        if expr_type >= 0 {
            let resolved_type: i32 = resolve_type_id(out_ptr, ast_base, expr_type);
            if resolved_type < 0 {
                return -1;
            }
            if resolved_type != expr_type {
                ast_expr_set_type(ast_base, expr_index, resolved_type);
                expr_type = resolved_type;
            }
            resolved_initial_type = resolved_type;
            if initial_type >= 0 && recorded_type >= 0 {
                let mut validate_const_template: bool = false;
                if init_expr_index >= 0 {
                    let init_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, init_expr_index);
                    let init_kind: i32 = load_i32(init_entry_ptr);
                    if init_kind == 1 {
                        let metadata_ptr: i32 = load_i32(init_entry_ptr + 4);
                        if metadata_ptr > 0 {
                            let template_slot_ptr: i32 =
                                call_metadata_template_payload_ptr(metadata_ptr);
                            if template_slot_ptr > 0 {
                                let payload_ptr: i32 = load_i32(template_slot_ptr);
                                if payload_ptr > 0 {
                                    let return_handle: i32 = load_i32(
                                        payload_ptr
                                            + TYPE_TEMPLATE_PAYLOAD_RETURN_HANDLE_INDEX
                                                * WORD_SIZE,
                                    );
                                    if return_handle > 0 {
                                        validate_const_template = true;
                                    }
                                }
                            }
                        }
                    }
                }
                if validate_const_template {
                    let resolved_recorded: i32 =
                        resolve_type_id(out_ptr, ast_base, recorded_type);
                    if resolved_recorded < 0 {
                        return -1;
                    }
                    if recorded_entry_offset >= 0 {
                        if resolved_recorded != recorded_type {
                            store_i32(recorded_entry_offset + 8, resolved_recorded);
                        }
                    }
                    if resolved_initial_type >= 0
                        && resolved_initial_type != resolved_recorded
                    {
                        let location_offset: i32 = load_i32(entry_ptr + 12);
                        record_failure_with_location(
                            out_ptr,
                            ast_base,
                            caller_func_index,
                            location_offset,
                            47,
                            "const parameter template expected type mismatch",
                        );
                        return -1;
                    }
                    if resolved_recorded != expr_type {
                        ast_expr_set_type(ast_base, expr_index, resolved_recorded);
                        expr_type = resolved_recorded;
                    }
                }
            }
        }
        return 0;
    }
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = ast_expr_array_repeat_length(ast_base, expr_index);
        let length_expr_index: i32 = ast_expr_array_repeat_length_expr(ast_base, expr_index);
        if length < 0 {
            if length_expr_index < 0 {
                let location_offset: i32 = ast_expr_array_repeat_location(ast_base, expr_index);
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    41,
                    "array literal length must be non-negative",
                );
                return -1;
            }
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            element_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let element_type: i32 = ast_expr_type(ast_base, element_index);
        if element_type < 0 {
            return -1;
        }
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        }
        if resolved_element != element_type {
            ast_expr_set_type(ast_base, element_index, resolved_element);
        }
        if length < 0 {
            ast_expr_set_type(ast_base, expr_index, -1);
            return 0;
        }
        let array_type_id: i32 = ast_register_array_type(ast_base, resolved_element, length);
        if array_type_id < 0 {
            let location_offset: i32 = ast_expr_array_repeat_location(ast_base, expr_index);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                34,
                "array type table capacity exceeded",
            );
            return -1;
        }
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    }
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        }
        if element_count <= 0 {
            return -1;
        }
        let mut element_type: i32 = -1;
        let mut idx: i32 = 0;
        loop {
            if idx >= element_count {
                break;
            }
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                element_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            }
            let current_type: i32 = ast_expr_type(ast_base, element_index);
            if current_type < 0 {
                return -1;
            }
            let resolved_current: i32 = resolve_type_id(out_ptr, ast_base, current_type);
            if resolved_current < 0 {
                return -1;
            }
            if resolved_current != current_type {
                ast_expr_set_type(ast_base, element_index, resolved_current);
            }
            if element_type < 0 {
                element_type = resolved_current;
            } else if resolved_current != element_type {
                let location_offset: i32 = ast_expr_array_list_location(ast_base, expr_index);
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    45,
                    "array literal elements must have uniform type",
                );
                return -1;
            }
            idx = idx + 1;
        };
        if element_type < 0 {
            return -1;
        }
        let array_type_id: i32 = ast_register_array_type(ast_base, element_type, element_count);
        if array_type_id < 0 {
            let location_offset: i32 = ast_expr_array_list_location(ast_base, expr_index);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                34,
                "array type table capacity exceeded",
            );
            return -1;
        }
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type_id);
        if resolved_array_type < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, resolved_array_type);
        return 0;
    }
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let index_location: i32 = ast_expr_array_get_location(ast_base, expr_index);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            index_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            if caller_func_index >= 0 {
                let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
                let array_expr_kind: i32 = load_i32(array_entry_ptr);
                if array_expr_kind == 6 {
                    let param_index: i32 = load_i32(array_entry_ptr + 4);
                    if param_index >= 0 {
                        if ast_function_param_requires_specialization(
                            ast_base,
                            caller_func_index,
                            param_index,
                        ) {
                            let index_type: i32 = ast_expr_type(ast_base, index_index);
                            if index_type != BUILTIN_TYPE_ID_I32 {
                                record_failure_with_location(
                                    out_ptr,
                                    ast_base,
                                    caller_func_index,
                                    index_location,
                                    36,
                                    "array index requires integer indices",
                                );
                                return -1;
                            }
                            let element_hint: i32 =
                                ast_function_param_template_base_type(
                                    ast_base,
                                    caller_func_index,
                                    param_index,
                                );
                            if element_hint >= 0 {
                                let resolved_hint: i32 =
                                    resolve_type_id(out_ptr, ast_base, element_hint);
                                if resolved_hint < 0 {
                                    return -1;
                                }
                                ast_expr_set_type(ast_base, expr_index, resolved_hint);
                                return 0;
                            }
                            ast_expr_set_type(ast_base, expr_index, -1);
                            return 0;
                        }
                    }
                } else if array_expr_kind == 35 {
                    let length_expr_index: i32 =
                        ast_expr_array_repeat_length_expr(ast_base, array_index);
                    if length_expr_index >= 0 {
                        let index_type: i32 = ast_expr_type(ast_base, index_index);
                        if index_type != BUILTIN_TYPE_ID_I32 {
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                index_location,
                                36,
                                "array index requires integer indices",
                            );
                            return -1;
                        }
                        let element_index: i32 = load_i32(array_entry_ptr + WORD_SIZE);
                        if element_index < 0 {
                            return -1;
                        }
                        let element_type: i32 = ast_expr_type(ast_base, element_index);
                        if element_type < 0 {
                            return -1;
                        }
                        let resolved_element: i32 =
                            resolve_type_id(out_ptr, ast_base, element_type);
                        if resolved_element < 0 {
                            return -1;
                        }
                        if resolved_element != element_type {
                            ast_expr_set_type(ast_base, element_index, resolved_element);
                        }
                        ast_expr_set_type(ast_base, expr_index, resolved_element);
                        return 0;
                    }
                } else if array_expr_kind == 8 {
                    if local_stack_base > 0 && local_stack_count_ptr > 0 {
                        let local_index: i32 = load_i32(array_entry_ptr + 4);
                        if local_index >= 0 {
                            let repeat_init_index: i32 = resolve_local_array_repeat_init_index(
                                ast_base,
                                local_stack_base,
                                local_stack_count_ptr,
                                local_index,
                            );
                            if repeat_init_index >= 0 {
                                let index_type: i32 = ast_expr_type(ast_base, index_index);
                                if index_type != BUILTIN_TYPE_ID_I32 {
                                    record_failure_with_location(
                                        out_ptr,
                                        ast_base,
                                        caller_func_index,
                                        index_location,
                                        36,
                                        "array index requires integer indices",
                                    );
                                    return -1;
                                }
                                let repeat_entry_ptr: i32 =
                                    ast_expr_entry_ptr(ast_base, repeat_init_index);
                                let element_index: i32 = load_i32(repeat_entry_ptr + WORD_SIZE);
                                if element_index < 0 {
                                    return -1;
                                }
                                let element_type: i32 = ast_expr_type(ast_base, element_index);
                                if element_type < 0 {
                                    return -1;
                                }
                                let resolved_element: i32 =
                                    resolve_type_id(out_ptr, ast_base, element_type);
                                if resolved_element < 0 {
                                    return -1;
                                }
                                if resolved_element != element_type {
                                    ast_expr_set_type(
                                        ast_base,
                                        element_index,
                                        resolved_element,
                                    );
                                }
                                ast_expr_set_type(ast_base, expr_index, resolved_element);
                                return 0;
                            }
                        }
                    }
                }
            }
            return -1;
        }
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        }
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        }
        if type_id_is_struct(resolved_array_type) {
            let metadata_ptr: i32 = ast_call_data_alloc(ast_base, STRUCT_GET_LABEL_ENTRY_WORDS);
            if metadata_ptr < 0 {
                return -1;
            }
            struct_get_label_set_kind(metadata_ptr, STRUCT_LITERAL_LABEL_KIND_EXPRESSION);
            struct_get_label_set_data(metadata_ptr, index_index);
            struct_get_label_set_extra(metadata_ptr, -1);
            let expr_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
            store_i32(expr_entry_ptr, 48);
            store_i32(expr_entry_ptr + WORD_SIZE, array_index);
            store_i32(expr_entry_ptr + 2 * WORD_SIZE, metadata_ptr);
            if resolve_struct_get_expression(
                out_ptr,
                ast_base,
                expr_index,
                array_index,
                metadata_ptr,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            }
            return 0;
        }
        if !type_id_is_array(resolved_array_type) {
            return -1;
        }
        let index_type: i32 = ast_expr_type(ast_base, index_index);
        if index_type != BUILTIN_TYPE_ID_I32 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                index_location,
                36,
                "array index requires integer indices",
            );
            return -1;
        }
        let array_length: i32 = array_type_length(ast_base, resolved_array_type);
        if array_length < 0 {
            return -1;
        }
        let index_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, index_index);
        let index_expr_kind: i32 = load_i32(index_entry_ptr);
        if index_expr_kind == 0 {
            let mut index_value: i32 = load_i32(index_entry_ptr + WORD_SIZE);
            index_value = normalize_integer_value(index_value, BUILTIN_TYPE_ID_I32);
            if index_value < 0 {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    index_location,
                    32,
                    "array index must be non-negative",
                );
                return -1;
            }
            if index_value >= array_length {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    index_location,
                    25,
                    "array index out of bounds",
                );
                return -1;
            }
        }
        let element_type: i32 = array_type_element_type(ast_base, resolved_array_type);
        if element_type < 0 {
            return -1;
        }
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
        let array_expr_kind: i32 = load_i32(array_entry_ptr);
        if array_expr_kind == 0 {
            let array_literal_value: i32 = load_i32(array_entry_ptr + WORD_SIZE);
            if array_length > 0 {
                if array_literal_value > 0 {
                    if index_expr_kind == 0 {
                        let mut index_value: i32 = load_i32(index_entry_ptr + WORD_SIZE);
                        index_value = normalize_integer_value(index_value, BUILTIN_TYPE_ID_I32);
                        if index_value >= 0 {
                            if index_value < array_length {
                                let slot_ptr: i32 =
                                    array_literal_value + index_value * 2 * WORD_SIZE;
                                let element_value_ptr: i32 = slot_ptr;
                                let element_type_ptr: i32 = slot_ptr + WORD_SIZE;
                                let current_element_type: i32 = load_i32(element_type_ptr);
                                let converted_element: i32 = convert_constant_value(
                                    ast_base,
                                    element_value_ptr,
                                    current_element_type,
                                    resolved_element,
                                );
                                if converted_element >= 0 {
                                    let literal_value: i32 = load_i32(element_value_ptr);
                                    let expr_entry_ptr: i32 =
                                        ast_expr_entry_ptr(ast_base, expr_index);
                                    store_i32(expr_entry_ptr, 0);
                                    store_i32(expr_entry_ptr + WORD_SIZE, literal_value);
                                    store_i32(expr_entry_ptr + 2 * WORD_SIZE, 0);
                                    store_i32(expr_entry_ptr + 3 * WORD_SIZE, 0);
                                    ast_expr_set_type(ast_base, expr_index, converted_element);
                                }
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let location: i32 = ast_expr_array_set_location(ast_base, expr_index);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            index_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            return -1;
        }
        let resolved_array: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array < 0 {
            return -1;
        }
        if resolved_array != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array);
        }
        if !type_id_is_array(resolved_array) {
            return -1;
        }
        let index_type: i32 = ast_expr_type(ast_base, index_index);
        if index_type != BUILTIN_TYPE_ID_I32 {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location,
                36,
                "array index requires integer indices",
            );
            return -1;
        }
        let element_type: i32 = array_type_element_type(ast_base, resolved_array);
        if element_type < 0 {
            return -1;
        }
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        }
        if resolved_element != element_type {
            let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
            let array_kind: i32 = load_i32(array_entry_ptr);
            if array_kind == 8 {
                ast_expr_set_type(ast_base, array_index, resolved_array);
            }
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type >= 0 {
            let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
            if resolved_value < 0 {
                return -1;
            }
            if resolved_value != resolved_element {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location,
                    38,
                    "array element assignment type mismatch",
                );
                return -1;
            }
            if resolved_value != value_type {
                ast_expr_set_type(ast_base, value_index, resolved_value);
            }
        } else {
            ast_expr_set_type(ast_base, value_index, resolved_element);
        }
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    }
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let location: i32 = ast_expr_tuple_set_location(ast_base, expr_index);
        if field_index < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            tuple_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if tuple_type < 0 {
            return -1;
        }
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type);
        if resolved_tuple < 0 {
            return -1;
        }
        if resolved_tuple != tuple_type {
            ast_expr_set_type(ast_base, tuple_index, resolved_tuple);
        }
        if !type_id_is_tuple(resolved_tuple) {
            return -1;
        }
        let tuple_idx: i32 = tuple_type_index(resolved_tuple);
        if tuple_idx < 0 {
            return -1;
        }
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            return -1;
        }
        if ensure_tuple_type_metadata(out_ptr, ast_base, tuple_idx, resolved_tuple) < 0 {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        if element_count <= field_index {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location,
                31,
                "tuple field index out of bounds",
            );
            return -1;
        }
        if element_count <= 0 {
            return -1;
        }
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return -1;
        }
        let element_type_ptr: i32 = elements_ptr + field_index * WORD_SIZE;
        let element_type: i32 = load_i32(element_type_ptr);
        if element_type < 0 {
            return -1;
        }
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        }
        if resolved_element != element_type {
            store_i32(element_type_ptr, resolved_element);
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type >= 0 {
            let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
            if resolved_value < 0 {
                return -1;
            }
            if resolved_value != resolved_element {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location,
                    36,
                    "tuple field assignment type mismatch",
                );
                return -1;
            }
            if resolved_value != value_type {
                ast_expr_set_type(ast_base, value_index, resolved_value);
            }
        } else {
            ast_expr_set_type(ast_base, value_index, resolved_element);
        }
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        return 0;
    }
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            array_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if array_type < 0 {
            if caller_func_index >= 0 {
                let array_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, array_index);
                let array_expr_kind: i32 = load_i32(array_entry_ptr);
                if array_expr_kind == 6 {
                    let param_index: i32 = load_i32(array_entry_ptr + 4);
                    if param_index >= 0 {
                        if ast_function_param_requires_specialization(
                            ast_base,
                            caller_func_index,
                            param_index,
                        ) {
                            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                            return 0;
                        }
                    }
                } else if array_expr_kind == 35 {
                    let length_expr_index: i32 =
                        ast_expr_array_repeat_length_expr(ast_base, array_index);
                    if length_expr_index >= 0 {
                        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                        return 0;
                    }
                } else if array_expr_kind == 8 {
                    if local_stack_base > 0 && local_stack_count_ptr > 0 {
                        let local_index: i32 = load_i32(array_entry_ptr + 4);
                        if local_index >= 0 {
                            let repeat_init_index: i32 = resolve_local_array_repeat_init_index(
                                ast_base,
                                local_stack_base,
                                local_stack_count_ptr,
                                local_index,
                            );
                            if repeat_init_index >= 0 {
                                let length_expr_index: i32 = ast_expr_array_repeat_length_expr(
                                    ast_base,
                                    repeat_init_index,
                                );
                                if length_expr_index >= 0 {
                                    ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                                    return 0;
                                }
                                let stored_length: i32 =
                                    ast_expr_array_repeat_length(ast_base, repeat_init_index);
                                if stored_length >= 0 {
                                    ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
                                    return 0;
                                }
                            }
                        }
                    }
                }
            }
            return -1;
        }
        let resolved_array_type: i32 = resolve_type_id(out_ptr, ast_base, array_type);
        if resolved_array_type < 0 {
            return -1;
        }
        if resolved_array_type != array_type {
            ast_expr_set_type(ast_base, array_index, resolved_array_type);
        }
        if !type_id_is_array(resolved_array_type) {
            return -1;
        }
        let length: i32 = array_type_length(ast_base, resolved_array_type);
        if length < 0 {
            if out_ptr > 0 {
                if load_u8(out_ptr) == 0 {
                    let message: [u8; 41] = "array literal length must be non-negative";
                    write_failure_detail(out_ptr, 41, message);
                }
            }
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_I32);
        return 0;
    }
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        }
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            tuple_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if tuple_type < 0 {
            return -1;
        }
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type);
        if resolved_tuple < 0 {
            return -1;
        }
        if resolved_tuple != tuple_type {
            ast_expr_set_type(ast_base, tuple_index, resolved_tuple);
        }
        if !type_id_is_tuple(resolved_tuple) {
            return -1;
        }
        let tuple_idx: i32 = tuple_type_index(resolved_tuple);
        if tuple_idx < 0 {
            return -1;
        }
        if tuple_idx >= ast_tuple_types_count(ast_base) {
            return -1;
        }
        if ensure_tuple_type_metadata(out_ptr, ast_base, tuple_idx, resolved_tuple) < 0 {
            return -1;
        }
        let element_count: i32 = ast_tuple_type_element_count(ast_base, tuple_idx);
        let access_location: i32 = load_i32(entry_ptr + 12);
        if element_count <= field_index {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                access_location,
                31,
                "tuple field index out of bounds",
            );
            return -1;
        }
        if element_count <= 0 {
            return -1;
        }
        let elements_ptr: i32 = ast_tuple_type_elements_ptr(ast_base, tuple_idx);
        if elements_ptr < 0 {
            return -1;
        }
        let element_type_ptr: i32 = elements_ptr + field_index * WORD_SIZE;
        let element_type: i32 = load_i32(element_type_ptr);
        if element_type < 0 {
            return -1;
        }
        let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
        if resolved_element < 0 {
            return -1;
        }
        if resolved_element != element_type {
            store_i32(element_type_ptr, resolved_element);
        }
        ast_expr_set_type(ast_base, expr_index, resolved_element);
        let tuple_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, tuple_index);
        let tuple_expr_kind: i32 = load_i32(tuple_entry_ptr);
        if tuple_expr_kind == 0 {
            let tuple_literal_value: i32 = load_i32(tuple_entry_ptr + WORD_SIZE);
            if element_count > 0 {
                if tuple_literal_value > 0 {
                    let slot_ptr: i32 = tuple_literal_value + field_index * 2 * WORD_SIZE;
                    let element_value_ptr: i32 = slot_ptr;
                    let element_type_slot_ptr: i32 = slot_ptr + WORD_SIZE;
                    let current_element_type: i32 = load_i32(element_type_slot_ptr);
                    let converted_element: i32 = convert_constant_value(
                        ast_base,
                        element_value_ptr,
                        current_element_type,
                        resolved_element,
                    );
                    if converted_element >= 0 {
                        let literal_value: i32 = load_i32(element_value_ptr);
                        let expr_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
                        store_i32(expr_entry_ptr, 0);
                        store_i32(expr_entry_ptr + WORD_SIZE, literal_value);
                        store_i32(expr_entry_ptr + 2 * WORD_SIZE, 0);
                        store_i32(expr_entry_ptr + 3 * WORD_SIZE, 0);
                        ast_expr_set_type(ast_base, expr_index, converted_element);
                    }
                }
            }
        }
        return 0;
    }
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        }
        if element_count == 0 {
            let tuple_type_id: i32 = ast_register_tuple_type(ast_base, 0, 0);
            if tuple_type_id < 0 {
                return -1;
            }
            let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
            if resolved_tuple < 0 {
                return -1;
            }
            ast_expr_set_type(ast_base, expr_index, resolved_tuple);
            return 0;
        }
        if values_ptr < 0 {
            return -1;
        }
        let call_data_used_ptr: i32 = ast_call_data_len_ptr(ast_base);
        let saved_used: i32 = load_i32(call_data_used_ptr);
        let elements_ptr: i32 = ast_call_data_alloc(ast_base, element_count);
        if elements_ptr < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let mut idx: i32 = 0;
        let mut requires_specialization: bool = false;
        loop {
            if idx >= element_count {
                break;
            }
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            let defer_element: bool = if caller_is_const {
                tuple_literal_element_requires_const_specialization(ast_base, value_index)
            } else {
                false
            };
            if defer_element {
                requires_specialization = true;
                idx = idx + 1;
                continue;
            }
            let element_type: i32 = ast_expr_type(ast_base, value_index);
            if element_type < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            let resolved_element: i32 = resolve_type_id(out_ptr, ast_base, element_type);
            if resolved_element < 0 {
                store_i32(call_data_used_ptr, saved_used);
                return -1;
            }
            if resolved_element != element_type {
                ast_expr_set_type(ast_base, value_index, resolved_element);
            }
            store_i32(elements_ptr + idx * WORD_SIZE, resolved_element);
            idx = idx + 1;
        };
        if requires_specialization {
            store_i32(call_data_used_ptr, saved_used);
            return 0;
        }
        let before_count: i32 = ast_tuple_types_count(ast_base);
        let tuple_type_id: i32 =
            ast_register_tuple_type(ast_base, elements_ptr, element_count);
        if tuple_type_id < 0 {
            store_i32(call_data_used_ptr, saved_used);
            return -1;
        }
        let after_count: i32 = ast_tuple_types_count(ast_base);
        if after_count == before_count {
            store_i32(call_data_used_ptr, saved_used);
        }
        let resolved_tuple: i32 = resolve_type_id(out_ptr, ast_base, tuple_type_id);
        if resolved_tuple < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, resolved_tuple);
        return 0;
    }
    if kind == 47 {
        let type_expr_index: i32 = ast_expr_struct_literal_type_expr(ast_base, expr_index);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            type_expr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let type_expr_type: i32 = ast_expr_type(ast_base, type_expr_index);
        if type_expr_type != BUILTIN_TYPE_ID_TYPE {
            let literal_location: i32 = ast_expr_struct_literal_location(ast_base, expr_index);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                literal_location,
                41,
                "struct literal base must be a struct type",
            );
            return -1;
        }
        let type_expr_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, type_expr_index);
        if load_i32(type_expr_entry_ptr) != 0 {
            return -1;
        }
        let struct_type_id: i32 = load_i32(type_expr_entry_ptr + WORD_SIZE);
        if struct_type_id < 0 {
            return -1;
        }
        let resolved_struct: i32 = resolve_type_id(out_ptr, ast_base, struct_type_id);
        if resolved_struct < 0 {
            return -1;
        }
        if !type_id_is_struct(resolved_struct) {
            let literal_location: i32 = ast_expr_struct_literal_location(ast_base, expr_index);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                literal_location,
                41,
                "struct literal base must be a struct type",
            );
            return -1;
        }
        let struct_index: i32 = struct_type_index(resolved_struct);
        if struct_index < 0 {
            return -1;
        }
        if ensure_struct_type_metadata(out_ptr, ast_base, struct_index, resolved_struct) < 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_expr_struct_literal_metadata(ast_base, expr_index);
        let field_count: i32 = ast_expr_struct_literal_field_count(ast_base, expr_index);
        if field_count < 0 {
            return -1;
        }
        let struct_field_count: i32 = ast_struct_type_field_count(ast_base, struct_index);
        if struct_field_count < 0 {
            return -1;
        }
        if field_count > struct_field_count {
            let mut location: i32 = ast_expr_struct_literal_location(ast_base, expr_index);
            if struct_field_count >= 0 {
                let extra_entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, struct_field_count);
                if extra_entry > 0 {
                    let extra_location: i32 = struct_literal_field_location(extra_entry);
                    if extra_location >= 0 {
                        location = extra_location;
                    }
                }
            }
            let message: [u8; 40] = "struct literal specifies too many fields";
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location,
                40,
                message,
            );
            return -1;
        }
        let mut field_idx: i32 = 0;
        while field_idx < field_count {
            let entry_ptr: i32 = struct_literal_field_entry_ptr(metadata_ptr, field_idx);
            if entry_ptr <= 0 {
                return -1;
            }
            let label_kind: i32 = struct_literal_field_label_kind(entry_ptr);
            let mut canonical_field_index: i32 = field_idx;
            if label_kind == STRUCT_LITERAL_LABEL_KIND_IDENTIFIER {
                let ident_ptr: i32 = struct_literal_field_label_data(entry_ptr);
                let ident_len: i32 = struct_literal_field_label_extra(entry_ptr);
                if ident_ptr <= 0 {
                    let field_location: i32 = struct_literal_field_location(entry_ptr);
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                if ident_len < 0 {
                    let field_location: i32 = struct_literal_field_location(entry_ptr);
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let mut search_idx: i32 = 0;
                let mut matched_index: i32 = -1;
                while search_idx < struct_field_count {
                    if struct_field_identifier_matches(
                        ast_base,
                        struct_index,
                        search_idx,
                        ident_ptr,
                        ident_len,
                    ) {
                        matched_index = search_idx;
                        break;
                    }
                    search_idx = search_idx + 1;
                };
                if matched_index < 0 {
                    let field_location: i32 = struct_literal_field_location(entry_ptr);
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                canonical_field_index = matched_index;
            }
            if label_kind == STRUCT_LITERAL_LABEL_KIND_EXPRESSION {
                let label_expr: i32 = struct_literal_field_label_data(entry_ptr);
                if resolve_expression_internal(
                    out_ptr,
                    ast_base,
                    label_expr,
                    func_count,
                    control_stack_base,
                    control_stack_count_ptr,
                    loop_stack_base,
                    loop_stack_count_ptr,
                    local_stack_base,
                    local_stack_count_ptr,
                    caller_func_index,
                    caller_is_const,
                ) < 0 {
                    return -1;
                }
                let field_location: i32 = struct_literal_field_location(entry_ptr);
                let eval_base: i32 = ast_temp_base(ast_base) + CONSTANT_EVAL_SCRATCH_OFFSET;
                let eval_value_ptr: i32 = eval_base;
                let eval_type_ptr: i32 = eval_value_ptr + WORD_SIZE;
                let eval_stack_top_ptr: i32 = eval_type_ptr + WORD_SIZE;
                let eval_stack_base: i32 = eval_stack_top_ptr + WORD_SIZE;
                let saved_eval_top: i32 = load_i32(eval_stack_top_ptr);
                store_i32(eval_stack_top_ptr, 0);
                let eval_status: i32 = interpret_constant_expression(
                    ast_base,
                    label_expr,
                    eval_stack_base,
                    eval_stack_top_ptr,
                    eval_value_ptr,
                    eval_type_ptr,
                    0,
                    0,
                    0,
                );
                store_i32(eval_stack_top_ptr, saved_eval_top);
                if eval_status < 0 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                if eval_status != CONST_EVAL_STATUS_OK {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let mut label_type: i32 = load_i32(eval_type_ptr);
                let resolved_label_type: i32 = resolve_type_id(out_ptr, ast_base, label_type);
                if resolved_label_type < 0 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                label_type = resolved_label_type;
                ast_expr_set_type(ast_base, label_expr, label_type);
                if !type_id_is_array(label_type) {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let element_type: i32 = array_type_element_type(ast_base, label_type);
                if element_type != BUILTIN_TYPE_ID_U8 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let element_count: i32 = array_type_length(ast_base, label_type);
                if element_count < 0 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let label_value_ptr: i32 = load_i32(eval_value_ptr);
                if element_count > 0 {
                    if label_value_ptr <= 0 {
                        record_struct_literal_field_mismatch(
                            out_ptr,
                            ast_base,
                            caller_func_index,
                            field_location,
                            struct_index,
                            field_idx,
                        );
                        return -1;
                    }
                }
                let trimmed_length: i32 =
                    struct_label_expression_trimmed_length(label_value_ptr, element_count);
                if trimmed_length < 0 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                let mut search_idx: i32 = 0;
                let mut matched_index: i32 = -1;
                while search_idx < struct_field_count {
                    let canonical_length: i32 =
                        struct_field_trimmed_length(ast_base, struct_index, search_idx);
                    if canonical_length < 0 {
                        return -1;
                    }
                    if canonical_length == trimmed_length {
                        let mut compare_idx: i32 = 0;
                        let mut matches: bool = true;
                        while compare_idx < canonical_length {
                            let normalized_char: i32 =
                                struct_label_expression_normalized_byte(
                                    label_value_ptr,
                                    compare_idx,
                                );
                            if normalized_char < 0 {
                                record_struct_literal_field_mismatch(
                                    out_ptr,
                                    ast_base,
                                    caller_func_index,
                                    field_location,
                                    struct_index,
                                    field_idx,
                                );
                                return -1;
                            }
                            let canonical_char: i32 = ast_struct_type_field_canonical_byte(
                                ast_base,
                                struct_index,
                                search_idx,
                                compare_idx,
                            );
                            if canonical_char < 0 {
                                return -1;
                            }
                            if canonical_char != normalized_char {
                                matches = false;
                                break;
                            }
                            compare_idx = compare_idx + 1;
                        };
                        if matches {
                            matched_index = search_idx;
                            break;
                        }
                    }
                    search_idx = search_idx + 1;
                };
                if matched_index < 0 {
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        field_idx,
                    );
                    return -1;
                }
                canonical_field_index = matched_index;
            }
            let mut prev_idx: i32 = 0;
            while prev_idx < field_idx {
                let prev_entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, prev_idx);
                if prev_entry <= 0 {
                    return -1;
                }
                let prev_canonical: i32 = struct_literal_field_label_extra(prev_entry);
                if prev_canonical == canonical_field_index {
                    let field_location: i32 = struct_literal_field_location(entry_ptr);
                    record_struct_literal_field_mismatch(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        field_location,
                        struct_index,
                        canonical_field_index,
                    );
                    return -1;
                }
                prev_idx = prev_idx + 1;
            };
            struct_literal_field_set_label_extra(entry_ptr, canonical_field_index);
            let value_index: i32 = struct_literal_field_value_index(entry_ptr);
            if resolve_expression_internal(
                out_ptr,
                ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            }
            let field_type: i32 =
                ast_struct_type_field_type(ast_base, struct_index, canonical_field_index);
            if field_type < 0 {
                return -1;
            }
            let resolved_field_type: i32 = resolve_type_id(out_ptr, ast_base, field_type);
            if resolved_field_type < 0 {
                return -1;
            }
            let value_type: i32 = ast_expr_type(ast_base, value_index);
            if value_type < 0 {
                return -1;
            }
            let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
            if resolved_value < 0 {
                return -1;
            }
            if resolved_value != value_type {
                ast_expr_set_type(ast_base, value_index, resolved_value);
            }
            if resolved_value != resolved_field_type {
                let field_location: i32 = struct_literal_field_location(entry_ptr);
                record_struct_literal_type_mismatch(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    field_location,
                    struct_index,
                    canonical_field_index,
                );
                return -1;
            }
            field_idx = field_idx + 1;
        };
        let literal_location: i32 = ast_expr_struct_literal_location(ast_base, expr_index);
        let mut canonical_idx: i32 = 0;
        while canonical_idx < struct_field_count {
            let mut matched: bool = false;
            let mut scan_idx: i32 = 0;
            while scan_idx < field_count {
                let scan_entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, scan_idx);
                if scan_entry <= 0 {
                    return -1;
                }
                if struct_literal_field_label_extra(scan_entry) == canonical_idx {
                    matched = true;
                    break;
                }
                scan_idx = scan_idx + 1;
            };
            if !matched {
                record_struct_literal_missing_field(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    literal_location,
                    struct_index,
                    canonical_idx,
                );
                return -1;
            }
            canonical_idx = canonical_idx + 1;
        };
        ast_expr_set_type(ast_base, expr_index, resolved_struct);
        return 0;
    }
    if kind == 48 {
        let struct_index_expr: i32 = ast_expr_struct_get_base(ast_base, expr_index);
        if resolve_expression_internal(
            out_ptr,
            ast_base,
            struct_index_expr,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let metadata_ptr: i32 = ast_expr_struct_get_metadata(ast_base, expr_index);
        if resolve_struct_get_expression(
            out_ptr,
            ast_base,
            expr_index,
            struct_index_expr,
            metadata_ptr,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        return 0;
    }
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + 4);
        let byte_count: i32 = load_i32(entry_ptr + 8);
        if byte_count < 0 {
            return -1;
        }
        if byte_count > 0 && bytes_ptr < 0 {
            return -1;
        }
        return 0;
    }
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        }
        return 0;
    }
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            ptr_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let ptr_type: i32 = ast_expr_type(ast_base, ptr_index);
        if ptr_type != BUILTIN_TYPE_ID_I32 {
            return -1;
        }
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if type_id_is_array(value_type) {
            return -1;
        }
        return 0;
    }
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let resolved_target: i32 = resolve_type_id(out_ptr, ast_base, target_type);
        if resolved_target < 0 {
            return -1;
        }
        if !type_id_is_integer(resolved_target) {
            return -1;
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type < 0 {
            return -1;
        }
        let resolved_value: i32 = resolve_type_id(out_ptr, ast_base, value_type);
        if resolved_value < 0 {
            return -1;
        }
        if !type_id_is_integer(resolved_value) {
            return -1;
        }
        if resolved_value != value_type {
            ast_expr_set_type(ast_base, value_index, resolved_value);
        }
        ast_expr_set_type(ast_base, expr_index, resolved_target);
        return 0;
    }
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 46
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            left_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(out_ptr, ast_base,
            right_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let left_type: i32 = ast_expr_type(ast_base, left_index);
        let right_type: i32 = ast_expr_type(ast_base, right_index);
        if left_type < 0 {
            return -1;
        }
        if right_type < 0 {
            return -1;
        }
        let resolved_left: i32 = resolve_type_id(out_ptr, ast_base, left_type);
        if resolved_left < 0 {
            return -1;
        }
        if resolved_left != left_type {
            ast_expr_set_type(ast_base, left_index, resolved_left);
        }
        let resolved_right: i32 = resolve_type_id(out_ptr, ast_base, right_type);
        if resolved_right < 0 {
            return -1;
        }
        if resolved_right != right_type {
            ast_expr_set_type(ast_base, right_index, resolved_right);
        }
        if kind == 20 || kind == 21 {
            let location_offset: i32 = load_i32(entry_ptr + 12);
            if !type_id_is_bool(resolved_left) {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    42,
                    "logical operators require boolean operands",
                );
                return -1;
            }
            if !type_id_is_bool(resolved_right) {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    42,
                    "logical operators require boolean operands",
                );
                return -1;
            }
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        }
        if kind == 14
            || kind == 15
            || kind == 16
            || kind == 17
            || kind == 18
            || kind == 19
        {
            let location_offset: i32 = load_i32(entry_ptr + 12);
            if !type_id_is_integer(resolved_left) {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    41,
                    "binary operator operands must be integers",
                );
                return -1;
            }
            if !type_id_is_integer(resolved_right) {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    41,
                    "binary operator operands must be integers",
                );
                return -1;
            }
            if resolved_left != resolved_right {
                record_failure_with_location(
                    out_ptr,
                    ast_base,
                    caller_func_index,
                    location_offset,
                    48,
                    "binary operator operands must have matching type",
                );
                return -1;
            }
            ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
            return 0;
        }
        let location_offset: i32 = load_i32(entry_ptr + 12);
        if !type_id_is_integer(resolved_left) {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                41,
                "binary operator operands must be integers",
            );
            return -1;
        }
        if !type_id_is_integer(resolved_right) {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                41,
                "binary operator operands must be integers",
            );
            return -1;
        }
        if resolved_left != resolved_right {
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                48,
                "binary operator operands must have matching type",
            );
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, resolved_left);
        return 0;
    }
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if !type_id_is_bool(value_type) {
            let location_offset: i32 = load_i32(entry_ptr + 12);
            record_failure_with_location(
                out_ptr,
                ast_base,
                caller_func_index,
                location_offset,
                35,
                "logical not operand must be boolean",
            );
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, BUILTIN_TYPE_ID_BOOL);
        return 0;
    }
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        if caller_func_index >= 0 {
            let caller_entry_ptr: i32 = ast_function_entry_ptr(ast_base, caller_func_index);
            let mut expected_return: i32 = load_i32(caller_entry_ptr + 28);
            if expected_return >= 0 {
                let resolved_expected: i32 = resolve_type_id(out_ptr, ast_base, expected_return);
                if resolved_expected < 0 {
                    return -1;
                }
                if resolved_expected != expected_return {
                    store_i32(caller_entry_ptr + 28, resolved_expected);
                    expected_return = resolved_expected;
                }
                if value_type >= 0 && value_type != expected_return {
                    if out_ptr > 0 {
                        if load_u8(out_ptr) == 0 {
                            let location_offset: i32 = load_i32(entry_ptr + 12);
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                location_offset,
                                58,
                                "return expression type does not match function return type",
                            );
                        }
                    }
                    return -1;
                }
            }
            if ast_function_has_implicit_unit_return(ast_base, caller_func_index) {
                if !ast_expr_return_is_bare(ast_base, expr_index) {
                    if out_ptr > 0 {
                        if load_u8(out_ptr) == 0 {
                            let location_offset: i32 = load_i32(entry_ptr + 12);
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                location_offset,
                                58,
                                "return expression type does not match function return type",
                            );
                        }
                    }
                    return -1;
                }
            }
        }
        ast_expr_set_type(ast_base, expr_index, value_type);
        return 0;
    }
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            condition_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let control_count: i32 = load_i32(control_stack_count_ptr);
        if control_count >= RESOLVE_CONTROL_STACK_CAPACITY {
            return -1;
        }
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        }
        if resolve_expression_internal(out_ptr, ast_base,
            else_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            store_i32(control_stack_count_ptr, control_count);
            return -1;
        }
        store_i32(control_stack_count_ptr, control_count);
        let condition_type: i32 = ast_expr_type(ast_base, condition_index);
        if !type_id_is_bool(condition_type) {
            if !type_id_is_integer(condition_type) {
                return -1;
            }
        }
        let then_type: i32 = ast_expr_type(ast_base, then_index);
        let else_type: i32 = ast_expr_type(ast_base, else_index);
        if then_type != else_type {
            let then_diverges: bool = expression_guaranteed_diverges(ast_base, then_index);
            let else_diverges: bool = expression_guaranteed_diverges(ast_base, else_index);
            if then_diverges && !else_diverges {
                ast_expr_set_type(ast_base, expr_index, else_type);
                return 0;
            }
            if else_diverges && !then_diverges {
                ast_expr_set_type(ast_base, expr_index, then_type);
                return 0;
            }
            if then_diverges && else_diverges {
                return 0;
            }
            record_failure_detail(out_ptr, 25, "if branches type mismatch");
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, then_type);
        return 0;
    }
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        if resolve_expression_internal(out_ptr, ast_base,
            init_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if caller_func_index >= 0 {
            let init_entry_ptr: i32 = ast_expr_entry_ptr(ast_base, init_index);
            let init_kind: i32 = load_i32(init_entry_ptr);
            if init_kind == 1 {
                let metadata_ptr: i32 = load_i32(init_entry_ptr + 4);
                if metadata_ptr >= 0 {
                    let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
                    if callee_index >= 0 {
                        let mut unit_result: bool = false;
                        if ast_function_has_implicit_unit_return(ast_base, callee_index) {
                            unit_result = true;
                        } else {
                            let init_type: i32 = ast_expr_type(ast_base, init_index);
                            if init_type >= 0 {
                                if type_id_is_tuple(init_type) {
                                    let tuple_idx: i32 = tuple_type_index(init_type);
                                    if tuple_idx >= 0 {
                                        if ast_tuple_type_element_count(ast_base, tuple_idx) == 0 {
                                            unit_result = true;
                                        }
                                    }
                                }
                            }
                        }
                        if unit_result {
                            let location: i32 = ast_expr_location(ast_base, init_index);
                            let message: [u8; 46] =
                                "unit function results cannot initialize locals";
                            record_failure_with_location(
                                out_ptr,
                                ast_base,
                                caller_func_index,
                                location,
                                46,
                                message,
                            );
                            return -1;
                        }
                    }
                }
            }
        }
        let mut pushed: bool = false;
        if local_stack_base > 0 && local_stack_count_ptr > 0 {
            let stack_count: i32 = load_i32(local_stack_count_ptr);
            if stack_count >= RESOLVE_LOCAL_STACK_CAPACITY {
                return -1;
            }
            let entry_offset: i32 =
                local_stack_base + stack_count * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
            store_i32(entry_offset, local_index);
            store_i32(entry_offset + 4, init_index);
            store_i32(entry_offset + 8, ast_expr_type(ast_base, init_index));
            store_i32(local_stack_count_ptr, stack_count + 1);
            pushed = true;
        }
        let body_status: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        );
        if pushed {
            let stack_count: i32 = load_i32(local_stack_count_ptr);
            if stack_count <= 0 {
                return -1;
            }
            store_i32(local_stack_count_ptr, stack_count - 1);
        }
        if body_status < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    }
    if kind == 10 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            value_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        let mut recorded_entry_offset: i32 = -1;
        let mut recorded_type: i32 = -1;
        if local_stack_base > 0 && local_stack_count_ptr > 0 {
            if local_index >= 0 {
                let stack_count: i32 = load_i32(local_stack_count_ptr);
                let mut stack_idx: i32 = stack_count - 1;
                loop {
                    if stack_idx < 0 {
                        break;
                    }
                    let entry_offset: i32 =
                        local_stack_base + stack_idx * RESOLVE_LOCAL_STACK_ENTRY_SIZE;
                    let recorded_index: i32 = load_i32(entry_offset);
                    if recorded_index == local_index {
                        recorded_entry_offset = entry_offset;
                        recorded_type = load_i32(entry_offset + 8);
                        if recorded_type < 0 {
                            let init_expr_index: i32 = load_i32(entry_offset + 4);
                            if init_expr_index >= 0 {
                                recorded_type = ast_expr_type(ast_base, init_expr_index);
                                if recorded_type >= 0 {
                                    store_i32(entry_offset + 8, recorded_type);
                                }
                            }
                        }
                        break;
                    }
                    stack_idx = stack_idx - 1;
                };
            }
        }
        let mut resolved_local: i32 = -1;
        if recorded_type >= 0 {
            resolved_local = resolve_type_id(out_ptr, ast_base, recorded_type);
            if resolved_local < 0 {
                return -1;
            }
            if recorded_entry_offset >= 0 {
                if resolved_local != recorded_type {
                    store_i32(recorded_entry_offset + 8, resolved_local);
                }
            }
        }
        let mut resolved_value: i32 = -1;
        let mut value_type: i32 = ast_expr_type(ast_base, value_index);
        if value_type >= 0 {
            resolved_value = resolve_type_id(out_ptr, ast_base, value_type);
            if resolved_value < 0 {
                return -1;
            }
            if resolved_value != value_type {
                ast_expr_set_type(ast_base, value_index, resolved_value);
            }
            value_type = resolved_value;
        }
        if resolved_local >= 0 {
            if resolved_value >= 0 {
                if resolved_value != resolved_local {
                    let location: i32 = ast_expr_entry_extra(ast_base, expr_index);
                    record_failure_with_location(
                        out_ptr,
                        ast_base,
                        caller_func_index,
                        location,
                        30,
                        "local assignment type mismatch",
                    );
                    return -1;
                }
            } else {
                ast_expr_set_type(ast_base, value_index, resolved_local);
                value_type = resolved_local;
            }
            ast_expr_set_type(ast_base, expr_index, resolved_local);
            return 0;
        }
        if resolved_value >= 0 {
            if recorded_entry_offset >= 0 {
                store_i32(recorded_entry_offset + 8, resolved_value);
            }
            ast_expr_set_type(ast_base, expr_index, resolved_value);
            return 0;
        }
        ast_expr_set_type(ast_base, expr_index, value_type);
        return 0;
    }
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if resolve_expression_internal(out_ptr, ast_base,
            first_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        if resolve_expression_internal(out_ptr, ast_base,
            then_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        ) < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, then_index));
        return 0;
    }
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
        if control_count + 2 > control_capacity {
            return -1;
        }
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        let loop_capacity: i32 = RESOLVE_LOOP_STACK_CAPACITY;
        if loop_count >= loop_capacity {
            return -1;
        }
        let loop_flags: i32 = load_i32(entry_ptr + 8);
        store_i32(control_stack_base + control_count * 4, 0);
        store_i32(control_stack_count_ptr, control_count + 1);
        store_i32(control_stack_base + (control_count + 1) * 4, 1);
        store_i32(control_stack_count_ptr, control_count + 2);
        let packed_target: i32 = control_count + loop_flags * LOOP_STACK_FLAG_STRIDE;
        store_i32(loop_stack_base + loop_count * 4, packed_target);
        store_i32(loop_stack_count_ptr, loop_count + 1);
        let body_result: i32 = resolve_expression_internal(out_ptr, ast_base,
            body_index,
            func_count,
            control_stack_base,
            control_stack_count_ptr,
            loop_stack_base,
            loop_stack_count_ptr,
            local_stack_base,
            local_stack_count_ptr,
            caller_func_index,
            caller_is_const,
        );
        store_i32(loop_stack_count_ptr, loop_count);
        store_i32(control_stack_count_ptr, control_count);
        if body_result < 0 {
            return -1;
        }
        ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, body_index));
        return 0;
    }
    if kind == 13 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        }
        let stored_target: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let loop_flags: i32 = stored_target / LOOP_STACK_FLAG_STRIDE;
        let target_index: i32 =
            stored_target - loop_flags * LOOP_STACK_FLAG_STRIDE;
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - target_index;
        if branch_depth < 0 {
            return -1;
        }
        store_i32(entry_ptr + 4, branch_depth);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            if loop_flags != 0 {
                if out_ptr > 0 {
                    if load_u8(out_ptr) == 0 {
                        let location_offset: i32 = ast_expr_break_location(ast_base, expr_index);
                        if location_offset >= 0 {
                            let mut module_index: i32 = -1;
                            let mut module_base: i32 = 0;
                            let mut module_len: i32 = 0;
                            if caller_func_index >= 0 {
                                module_index = ast_function_entry_module_index(ast_base, caller_func_index);
                                module_base = ast_function_entry_module_base(ast_base, caller_func_index);
                                module_len = ast_function_entry_module_len(ast_base, caller_func_index);
                                if (module_base <= 0 || module_len <= 0) && module_index >= 0 {
                                    module_base = module_entry_content(module_index);
                                    module_len = module_entry_content_len(module_index);
                                }
                            }
                            if module_index < 0 {
                                module_base = scratch_module_base(out_ptr);
                                module_len = scratch_module_len(out_ptr);
                            }
                            let message: [u8; 36] = "while loops cannot break with values";
                            write_failure_detail_with_location(
                                out_ptr,
                                module_index,
                                module_base,
                                module_len,
                                location_offset,
                                36,
                                message,
                            );
                        } else {
                            record_failure_detail(
                                out_ptr,
                                36,
                                "while loops cannot break with values",
                            );
                        }
                    }
                }
                return -1;
            }
            if resolve_expression_internal(out_ptr, ast_base,
                value_index,
                func_count,
                control_stack_base,
                control_stack_count_ptr,
                loop_stack_base,
                loop_stack_count_ptr,
                local_stack_base,
                local_stack_count_ptr,
                caller_func_index,
                caller_is_const,
            ) < 0 {
                return -1;
            }
            ast_expr_set_type(ast_base, expr_index, ast_expr_type(ast_base, value_index));
            return 0;
        }
        ast_expr_set_type(ast_base, expr_index, -1);
        return 0;
    }
    if kind == 24 {
        let loop_count: i32 = load_i32(loop_stack_count_ptr);
        if loop_count <= 0 {
            return -1;
        }
        let stored_target: i32 = load_i32(loop_stack_base + (loop_count - 1) * 4);
        let loop_flags: i32 = stored_target / LOOP_STACK_FLAG_STRIDE;
        let target_index: i32 =
            stored_target - loop_flags * LOOP_STACK_FLAG_STRIDE;
        let continue_target: i32 = target_index + 1;
        let control_count: i32 = load_i32(control_stack_count_ptr);
        let branch_depth: i32 = control_count - 1 - continue_target;
        if branch_depth < 0 {
            return -1;
        }
        store_i32(entry_ptr + 4, branch_depth);
        return 0;
    }
    -1
}

fn resolve_expression(
    out_ptr: i32,
    ast_base: i32,
    expr_index: i32,
    func_count: i32,
    caller_is_const: bool,
    caller_func_index: i32,
) -> i32 {
    let temp_base: i32 = ast_temp_base(ast_base);
    let control_count_ptr: i32 = temp_base;
    let loop_count_ptr: i32 = temp_base + 4;
    let control_stack_base: i32 = temp_base + 8;
    let control_capacity: i32 = RESOLVE_CONTROL_STACK_CAPACITY;
    let loop_stack_base: i32 = control_stack_base + control_capacity * 4;
    let local_stack_count_ptr: i32 = loop_stack_base + RESOLVE_LOOP_STACK_CAPACITY * 4;
    let local_stack_base: i32 = local_stack_count_ptr + 4;
    let saved_control_count: i32 = load_i32(control_count_ptr);
    let saved_loop_count: i32 = load_i32(loop_count_ptr);
    let saved_local_count: i32 = load_i32(local_stack_count_ptr);
    store_i32(control_count_ptr, 0);
    store_i32(loop_count_ptr, 0);
    store_i32(local_stack_count_ptr, 0);
    let result: i32 = resolve_expression_internal(
        out_ptr,
        ast_base,
        expr_index,
        func_count,
        control_stack_base,
        control_count_ptr,
        loop_stack_base,
        loop_count_ptr,
        local_stack_base,
        local_stack_count_ptr,
        caller_func_index,
        caller_is_const,
    );
    store_i32(control_count_ptr, saved_control_count);
    store_i32(loop_count_ptr, saved_loop_count);
    store_i32(local_stack_count_ptr, saved_local_count);
    result
}


const COMPILER_MEMORY_PAGES: i32 = 256;

fn initialize_layout(out_ptr: i32) {
    if out_ptr > 0 {
        let mut detail_idx: i32 = 0;
        loop {
            if detail_idx >= FAILURE_DETAIL_CAPACITY {
                break;
            }
            store_u8(out_ptr + detail_idx, 0);
            detail_idx = detail_idx + 1;
        };
    }
    clear_failure_location(out_ptr);
    store_i32(scratch_instr_offset_ptr(out_ptr), 0);
    store_i32(scratch_expr_type_ptr(out_ptr), -1);
    store_i32(scratch_module_base_ptr(out_ptr), 0);
    store_i32(scratch_module_len_ptr(out_ptr), 0);
    store_i32(scratch_module_index_ptr(out_ptr), -1);
    store_i32(scratch_fn_count_ptr(out_ptr), 0);
    store_i32(scratch_types_count_ptr(out_ptr), 0);
}

// Entry point for the compiler pipeline.  The function stages the linear-memory
// layout, parses modules (including recursive imports), validates the resulting
// AST, and finally hands the fully-resolved program to the WebAssembly emitter.
// On success it returns the number of bytes written into the output buffer.
