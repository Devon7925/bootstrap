use "/stdlib/memory.bp";

// This module converts the validated AST produced by ast_compiler.bp into a
// fully-formed WebAssembly module.  The helpers here operate directly on the
// compiler's linear memory buffers, writing bytes and sections sequentially.

const WASM_VALUE_TYPE_I32: i32 = 127;

const WASM_VALUE_TYPE_I64: i32 = 126;

const WASM_REF_TYPE_REF: i32 = -28;

const WASM_COMPOSITE_TYPE_STRUCT: i32 = -33;

const WASM_COMPOSITE_TYPE_ARRAY: i32 = -34;

const WASM_MUTABILITY_CONST: i32 = 0;

const WASM_MUTABILITY_VAR: i32 = 1;

const WORD_SIZE: i32 = 4;

const COMPILER_MEMORY_PAGES: i32 = 256;

const AST_ARRAY_TYPE_ELEMENT_OFFSET: i32 = 0;

const AST_TUPLE_TYPE_COUNT_OFFSET: i32 = 0;

const AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET: i32 = 4;

const AST_STRUCT_TYPE_FIELD_COUNT_OFFSET: i32 = 0;

const AST_STRUCT_TYPE_FIELD_STRIDE_OFFSET: i32 = 8;

const AST_STRUCT_TYPE_FIELDS_PTR_OFFSET: i32 = 12;

const STRUCT_FIELD_METADATA_HEADER_WORDS: i32 = 2;

const STRUCT_FIELD_TYPE_WORD_OFFSET: i32 = 0;

const LOCAL_COUNTS_BASE: i32 = 1024;

fn record_emit_failure(out_ptr: i32, const MESSAGE_LEN: i32, message: [u8; MESSAGE_LEN]) {
    if out_ptr > 0 {
        if load_u8(out_ptr) == 0 {
            write_failure_detail(out_ptr, MESSAGE_LEN, message);
        };
    };
}

fn write_byte(base: i32, offset: i32, value: i32) -> i32 {
    store_u8(base + offset, value & 255);
    offset + 1
}


fn write_u32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let mut byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        if remaining != 0 {
            byte = byte | 128;
        };
        out = write_byte(base, out, byte);
        if remaining == 0 {
            break;
        };
    };
    out
}


fn write_i32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        let mut out_byte: i32 = byte;
        if !done {
            out_byte = out_byte | 128;
        };
        out = write_byte(base, out, out_byte);
        if done {
            break;
        };
    };
    out
}


fn build_runtime_function_map(ast_base: i32, func_count: i32) -> (i32, i32) {
    let mut total_functions: i32 = ast_functions_count(ast_base);
    if total_functions < func_count {
        total_functions = func_count;
    };
    if total_functions <= 0 {
        return (0, 0);
    };
    let map_ptr: i32 = ast_temp_base(ast_base);
    let mut runtime_index: i32 = 0;
    let mut idx: i32 = 0;
    while idx < total_functions {
        if ast_function_has_const_params(ast_base, idx) {
            store_i32(map_ptr + idx * WORD_SIZE, -1);
        } else {
            store_i32(map_ptr + idx * WORD_SIZE, runtime_index);
            runtime_index = runtime_index + 1;
        };
        idx = idx + 1;
    };
    (map_ptr, runtime_index)
}


fn leb_u32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        count = count + 1;
        remaining = remaining >> 7;
        if remaining == 0 {
            break;
        };
    };
    count
}


fn leb_i32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        count = count + 1;
        if done {
            break;
        };
    };
    count
}


fn write_magic(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, '\0');
    out = write_byte(base, out, 'a');
    out = write_byte(base, out, 's');
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out
}


fn type_id_to_wasm_value_type(type_id: i32) -> i32 {
    if type_id_is_64_bit_integer(type_id) {
        return WASM_VALUE_TYPE_I64;
    };
    if type_id_is_integer(type_id) || type_id_is_bool(type_id) {
        return WASM_VALUE_TYPE_I32;
    };
    if type_id == BUILTIN_TYPE_ID_TYPE {
        return WASM_VALUE_TYPE_I32;
    };
    -1
}


fn type_id_wasm_value_type_len(ast_base: i32, type_id: i32) -> i32 {
    if type_id_is_array(type_id)
        || type_id_is_tuple(type_id)
        || type_id_is_struct(type_id)
    {
        let heap_index: i32 = type_id_heap_type_index(ast_base, type_id);
        if heap_index < 0 {
            return -1;
        };
        return leb_i32_len(WASM_REF_TYPE_REF) + leb_i32_len(heap_index);
    };
    let numeric: i32 = type_id_to_wasm_value_type(type_id);
    if numeric < 0 {
        return -1;
    };
    1
}


fn write_type_id_as_wasm_value_type(base: i32, offset: i32, ast_base: i32, type_id: i32) -> i32 {
    if type_id_is_array(type_id)
        || type_id_is_tuple(type_id)
        || type_id_is_struct(type_id)
    {
        let heap_index: i32 = type_id_heap_type_index(ast_base, type_id);
        if heap_index < 0 {
            return -1;
        };
        let mut out: i32 = write_i32_leb(base, offset, WASM_REF_TYPE_REF);
        out = write_i32_leb(base, out, heap_index);
        return out;
    };
    let numeric: i32 = type_id_to_wasm_value_type(type_id);
    if numeric < 0 {
        return -1;
    };
    write_byte(base, offset, numeric)
}




fn integer_type_bit_width(type_id: i32) -> i32 {
    let variant_index: i32 = integer_type_variant_index(type_id);
    if variant_index < 0 {
        return -1;
    };
    let widths: [i32; 4] = [8, 16, 32, 64];
    widths[variant_index]
}


fn mask_i32_code_size(width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    let mask: i32 = (1 << width) - 1;
    1 + leb_i32_len(mask) + 1
}


fn mask_i32_value(base: i32, offset: i32, width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    let mask: i32 = (1 << width) - 1;
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, mask);
    out = write_byte(base, out, 113);
    out
}


fn sign_extend_i32_code_size(width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    let shift: i32 = 32 - width;
    let len: i32 = leb_i32_len(shift);
    2 * (1 + len) + 2
}


fn sign_extend_i32_value(base: i32, offset: i32, width: i32) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    let shift: i32 = 32 - width;
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, shift);
    out = write_byte(base, out, 116);
    out = write_byte(base, out, 65);
    out = write_i32_leb(base, out, shift);
    out = write_byte(base, out, 117);
    out
}


fn canonicalize_i32_code_size(width: i32, signed: bool) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return 0;
    };
    if signed {
        return sign_extend_i32_code_size(width);
    };
    mask_i32_code_size(width)
}


fn canonicalize_i32_value(base: i32, offset: i32, width: i32, signed: bool) -> i32 {
    if width <= 0 {
        return -1;
    };
    if width >= 32 {
        return offset;
    };
    if signed {
        return sign_extend_i32_value(base, offset, width);
    };
    mask_i32_value(base, offset, width)
}


fn cast_expression_extra_code_size(source_type: i32, target_type: i32) -> i32 {
    if source_type == target_type {
        return 0;
    };
    if !type_id_is_integer(source_type) {
        return -1;
    };
    if !type_id_is_integer(target_type) {
        return -1;
    };
    let source_width: i32 = integer_type_bit_width(source_type);
    let target_width: i32 = integer_type_bit_width(target_type);
    if source_width < 0 {
        return -1;
    };
    if target_width < 0 {
        return -1;
    };
    let source_signed: bool = type_id_is_signed_integer(source_type);
    let target_signed: bool = type_id_is_signed_integer(target_type);
    let mut total: i32 = 0;
    let mut working_is_64: bool = type_id_is_64_bit_integer(source_type);
    let target_is_64: bool = type_id_is_64_bit_integer(target_type);
    if !working_is_64 {
        let canonical: i32 = canonicalize_i32_code_size(source_width, source_signed);
        if canonical < 0 {
            return -1;
        };
        total = total + canonical;
    };
    if working_is_64 && !target_is_64 {
        total = total + 1;
        working_is_64 = false;
    };
    if !working_is_64 && target_is_64 {
        total = total + 1;
        return total;
    };
    if working_is_64 && target_is_64 {
        return total;
    };
    if target_width < 32 {
        let adjust: i32 = if target_signed {
            sign_extend_i32_code_size(target_width)
        } else {
            mask_i32_code_size(target_width)
        };
        if adjust < 0 {
            return -1;
        };
        total = total + adjust;
    };
    total
}


fn emit_cast_value(base: i32, offset: i32, source_type: i32, target_type: i32) -> i32 {
    if source_type == target_type {
        return offset;
    };
    if !type_id_is_integer(source_type) {
        return -1;
    };
    if !type_id_is_integer(target_type) {
        return -1;
    };
    let source_width: i32 = integer_type_bit_width(source_type);
    let target_width: i32 = integer_type_bit_width(target_type);
    if source_width < 0 {
        return -1;
    };
    if target_width < 0 {
        return -1;
    };
    let source_signed: bool = type_id_is_signed_integer(source_type);
    let target_signed: bool = type_id_is_signed_integer(target_type);
    let mut out: i32 = offset;
    let mut working_is_64: bool = type_id_is_64_bit_integer(source_type);
    let target_is_64: bool = type_id_is_64_bit_integer(target_type);
    if !working_is_64 {
        out = canonicalize_i32_value(base, out, source_width, source_signed);
        if out < 0 {
            return -1;
        };
    };
    if working_is_64 && !target_is_64 {
        out = write_byte(base, out, 167);
        working_is_64 = false;
    };
    if !working_is_64 && target_is_64 {
        let opcode: i32 = if source_signed { 172 } else { 173 };
        out = write_byte(base, out, opcode);
        return out;
    };
    if working_is_64 && target_is_64 {
        return out;
    };
    if target_width < 32 {
        if target_signed {
            out = sign_extend_i32_value(base, out, target_width);
        } else {
            out = mask_i32_value(base, out, target_width);
        };
    };
    out
}


fn local_counts_pack(i32_count: i32, i64_count: i32, ref_count: i32) -> i32 {
    i32_count
        + i64_count * LOCAL_COUNTS_BASE
        + ref_count * LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE
}


fn local_counts_ref(packed: i32) -> i32 {
    packed / (LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE)
}


fn local_counts_i64(packed: i32) -> i32 {
    packed / LOCAL_COUNTS_BASE - local_counts_ref(packed) * LOCAL_COUNTS_BASE
}


fn local_counts_i32(packed: i32) -> i32 {
    packed
        - local_counts_i64(packed) * LOCAL_COUNTS_BASE
        - local_counts_ref(packed) * LOCAL_COUNTS_BASE * LOCAL_COUNTS_BASE
}


fn local_counts_add(a: i32, b: i32) -> i32 {
    if a < 0 {
        return -1;
    };
    if b < 0 {
        return -1;
    };
    let sum_i32: i32 = local_counts_i32(a) + local_counts_i32(b);
    let sum_i64: i32 = local_counts_i64(a) + local_counts_i64(b);
    let sum_ref: i32 = local_counts_ref(a) + local_counts_ref(b);
    local_counts_pack(sum_i32, sum_i64, sum_ref)
}


fn local_counts_total(packed: i32) -> i32 {
    if packed < 0 {
        return -1;
    };
    local_counts_i32(packed) + local_counts_i64(packed) + local_counts_ref(packed)
}


fn collect_local_counts_from_expression(
    ast_base: i32,
    expr_index: i32,
    param_count: i32,
    locals_end: i32,
    local_types_ptr: i32,
) -> i32 {
    if expr_index < 0 {
        return 0;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 || kind == 6 || kind == 8 || kind == 24 {
        return 0;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + idx * 4);
            let arg_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                arg_expr_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if arg_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, arg_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        return total;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            element_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < element_count {
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                element_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if element_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, element_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        return total;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let array_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if array_counts < 0 {
            return -1;
        };
        let index_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            index_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if index_counts < 0 {
            return -1;
        };
        return local_counts_add(array_counts, index_counts);
    };
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let array_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if array_counts < 0 {
            return -1;
        };
        let index_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            index_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if index_counts < 0 {
            return -1;
        };
        let value_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if value_counts < 0 {
            return -1;
        };
        let mut total: i32 = local_counts_add(array_counts, index_counts);
        if total < 0 {
            return -1;
        };
        total = local_counts_add(total, value_counts);
        if total < 0 {
            return -1;
        };
        let second_eval: i32 = local_counts_add(array_counts, index_counts);
        if second_eval < 0 {
            return -1;
        };
        return local_counts_add(total, second_eval);
    };
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let tuple_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            tuple_index,
            param_count,
            locals_end,
                local_types_ptr,
        );
        if tuple_counts < 0 {
            return -1;
        };
        let value_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
        );
        if value_counts < 0 {
            return -1;
        };
        let mut total: i32 = local_counts_add(tuple_counts, value_counts);
        if total < 0 {
            return -1;
        };
        total = local_counts_add(total, tuple_counts);
        if total < 0 {
            return -1;
        };
        return total;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 46
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 20
        || kind == 21
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            left_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if left_counts < 0 {
            return -1;
        };
        let right_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            right_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if right_counts < 0 {
            return -1;
        };
        return local_counts_add(left_counts, right_counts);
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let mut total: i32 = collect_local_counts_from_expression(
            ast_base,
            condition_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if total < 0 {
            return -1;
        };
        let then_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            then_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if then_counts < 0 {
            return -1;
        };
        total = local_counts_add(total, then_counts);
        if total < 0 {
            return -1;
        };
        let else_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            else_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if else_counts < 0 {
            return -1;
        };
        return local_counts_add(total, else_counts);
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let init_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            init_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if init_counts < 0 {
            return -1;
        };
        let body_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            body_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if body_counts < 0 {
            return -1;
        };
        if local_index < param_count {
            return -1;
        };
        if local_index >= locals_end {
            return -1;
        };
        let mut total: i32 = local_counts_add(init_counts, body_counts);
        if total < 0 {
            return -1;
        };
        let init_type_id: i32 = ast_expr_type(ast_base, init_index);
        let local_slot: i32 = local_index - param_count;
        if local_slot < 0 {
            return -1;
        };
        let total_locals: i32 = locals_end - param_count;
        if local_slot >= total_locals {
            return -1;
        };
        if local_types_ptr >= 0 {
            store_i32(local_types_ptr + local_slot * WORD_SIZE, init_type_id);
        };
        let declaration_counts: i32 = if type_id_is_array(init_type_id)
            || type_id_is_tuple(init_type_id)
            || type_id_is_struct(init_type_id)
        {
            local_counts_pack(0, 0, 1)
        } else {
            let wasm_type: i32 = type_id_to_wasm_value_type(init_type_id);
            if wasm_type < 0 {
                return -1;
            };
            if wasm_type == WASM_VALUE_TYPE_I64 {
                local_counts_pack(0, 1, 0)
            } else {
                local_counts_pack(1, 0, 0)
            }
        };
        local_counts_add(total, declaration_counts)
    } else if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let first_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            first_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if first_counts < 0 {
            return -1;
        };
        let then_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            then_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if then_counts < 0 {
            return -1;
        };
        return local_counts_add(first_counts, then_counts);
    } else if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            body_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            return collect_local_counts_from_expression(
                ast_base,
                value_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
        };
        return 0;
    } else if kind == 22 || kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            array_index,
            param_count,
            locals_end,
            local_types_ptr,
        );
    } else if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        if element_count == 0 {
            return 0;
        };
        if values_ptr < 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < element_count {
            let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let value_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                value_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if value_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, value_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        total
    } else if kind == 47 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        let field_count: i32 = load_i32(entry_ptr + 12);
        if field_count < 0 {
            return -1;
        };
        if field_count == 0 {
            return 0;
        };
        if metadata_ptr <= 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < field_count {
            let entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, idx);
            if entry <= 0 {
                return -1;
            };
            let value_index: i32 = struct_literal_field_value_index(entry);
            let value_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                value_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if value_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, value_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        total
    } else if kind == 48 {
        let struct_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            struct_index,
            param_count,
            locals_end,
            local_types_ptr,
        );
    } else if kind == 42 {
        0
    } else if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            ptr_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
    } else if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let ptr_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            ptr_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if ptr_counts < 0 {
            return -1;
        };
        let value_counts: i32 = collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
                local_types_ptr,
            );
        if value_counts < 0 {
            return -1;
        };
        return local_counts_add(ptr_counts, value_counts);
    } else if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return collect_local_counts_from_expression(
            ast_base,
            value_index,
            param_count,
            locals_end,
            local_types_ptr,
        );
    } else {
        0
    }
}


fn collect_function_local_counts(
    ast_base: i32,
    body_kind: i32,
    body_data0: i32,
    param_count: i32,
    locals_count: i32,
    local_types_ptr: i32,
) -> i32 {
    if locals_count <= 0 {
        return 0;
    };
    let locals_end: i32 = param_count + locals_count;
    if local_types_ptr >= 0 {
        let mut init_idx: i32 = 0;
        while init_idx < locals_count {
            store_i32(local_types_ptr + init_idx * WORD_SIZE, -1);
            init_idx = init_idx + 1;
        };
    };
    if body_kind == 0 {
        if locals_count != 0 {
            return -1;
        };
        return 0;
    };
    if body_kind == 1 {
        let metadata_ptr: i32 = body_data0;
        if metadata_ptr < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + idx * 4);
            let arg_counts: i32 = collect_local_counts_from_expression(
                ast_base,
                arg_expr_index,
                param_count,
                locals_end,
                local_types_ptr,
            );
            if arg_counts < 0 {
                return -1;
            };
            total = local_counts_add(total, arg_counts);
            if total < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        if local_counts_total(total) != locals_count {
            return -1;
        };
        return total;
    };
    let counts: i32 = collect_local_counts_from_expression(
        ast_base,
        body_data0,
        param_count,
        locals_end,
        local_types_ptr,
    );
    if counts < 0 {
        return -1;
    };
    if local_counts_total(counts) != locals_count {
        return -1;
    };
    counts
}


fn expression_code_size(ast_base: i32, expr_index: i32) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        return 1 + leb_i32_len(value);
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut total: i32 = 0;
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
            if arg_size < 0 {
                return -1;
            };
            total = total + arg_size;
            arg_idx = arg_idx + 1;
        };
        return total + 1 + leb_u32_len(callee_index);
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        return 1 + leb_u32_len(param_index);
    };
    if kind == 8 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            return -1;
        };
        return 1 + leb_u32_len(local_index);
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        let element_size: i32 = expression_code_size(ast_base, element_index);
        if element_size < 0 {
            return -1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        return element_size + 1 + leb_i32_len(length) + 2 + leb_u32_len(type_index);
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut total: i32 = 0;
        let mut idx: i32 = 0;
        while idx < element_count {
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            let element_size: i32 = expression_code_size(ast_base, element_index);
            if element_size < 0 {
                return -1;
            };
            total = total + element_size;
            idx = idx + 1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        return total + 2 + leb_u32_len(type_index) + leb_u32_len(element_count);
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let array_size: i32 = expression_code_size(ast_base, array_index);
        if array_size < 0 {
            return -1;
        };
        let index_size: i32 = expression_code_size(ast_base, index_index);
        if index_size < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, array_type);
        if type_index < 0 {
            return -1;
        };
        return array_size + index_size + 2 + leb_u32_len(type_index);
    };
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let array_size: i32 = expression_code_size(ast_base, array_index);
        if array_size < 0 {
            return -1;
        };
        let index_size: i32 = expression_code_size(ast_base, index_index);
        if index_size < 0 {
            return -1;
        };
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, array_type);
        if type_index < 0 {
            return -1;
        };
        let first_eval: i32 = array_size + index_size + value_size;
        let set_size: i32 = 2 + leb_u32_len(type_index);
        let second_eval: i32 = array_size + index_size;
        let get_size: i32 = 2 + leb_u32_len(type_index);
        return first_eval + set_size + second_eval + get_size;
    };
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 12);
        let tuple_size: i32 = expression_code_size(ast_base, tuple_index);
        if tuple_size < 0 {
            return -1;
        };
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if !type_id_is_tuple(tuple_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, tuple_type);
        if type_index < 0 {
            return -1;
        };
        let first_eval: i32 = tuple_size + value_size;
        let set_size: i32 = 2 + leb_u32_len(type_index) + leb_u32_len(field_index);
        let second_eval: i32 = tuple_size;
        let get_size: i32 = 2 + leb_u32_len(type_index) + leb_u32_len(field_index);
        return first_eval + set_size + second_eval + get_size;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, array_type);
        if length < 0 {
            return -1;
        };
        return 1 + leb_i32_len(length);
    };
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        let tuple_size: i32 = expression_code_size(ast_base, tuple_index);
        if tuple_size < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if !type_id_is_tuple(tuple_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, tuple_type);
        if type_index < 0 {
            return -1;
        };
        return tuple_size + 2 + leb_u32_len(type_index) + leb_u32_len(field_index);
    };
    if kind == 48 {
        let struct_index: i32 = load_i32(entry_ptr + 4);
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        if metadata_ptr <= 0 {
            return -1;
        };
        let struct_size: i32 = expression_code_size(ast_base, struct_index);
        if struct_size < 0 {
            return -1;
        };
        let struct_type: i32 = ast_expr_type(ast_base, struct_index);
        if !type_id_is_struct(struct_type) {
            return -1;
        };
        let field_index: i32 = struct_get_label_extra(metadata_ptr);
        if field_index < 0 {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, struct_type);
        if type_index < 0 {
            return -1;
        };
        return struct_size + 2 + leb_u32_len(type_index) + leb_u32_len(field_index);
    };
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        let mut total: i32 = 0;
        if element_count > 0 {
            if values_ptr < 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < element_count {
                let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
                let value_size: i32 = expression_code_size(ast_base, value_index);
                if value_size < 0 {
                    return -1;
                };
                total = total + value_size;
                idx = idx + 1;
            };
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if !type_id_is_tuple(expr_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        return total + 2 + leb_u32_len(type_index);
    };
    if kind == 47 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        let field_count: i32 = load_i32(entry_ptr + 12);
        if field_count < 0 {
            return -1;
        };
        let mut total: i32 = 0;
        if field_count > 0 {
            if metadata_ptr <= 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < field_count {
                let entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, idx);
                if entry <= 0 {
                    return -1;
                };
                let value_index: i32 = struct_literal_field_value_index(entry);
                let value_size: i32 = expression_code_size(ast_base, value_index);
                if value_size < 0 {
                    return -1;
                };
                total = total + value_size;
                idx = idx + 1;
            };
        };
        let struct_type: i32 = ast_expr_type(ast_base, expr_index);
        if !type_id_is_struct(struct_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, struct_type);
        if type_index < 0 {
            return -1;
        };
        return total + 2 + leb_u32_len(type_index);
    };
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + 4);
        let byte_count: i32 = load_i32(entry_ptr + 8);
        if byte_count < 0 {
            return -1;
        };
        if byte_count > 0 && bytes_ptr < 0 {
            return -1;
        };
        return byte_count;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let ptr_size: i32 = expression_code_size(ast_base, ptr_index);
        if ptr_size < 0 {
            return -1;
        };
        let align: i32 = if kind == 29 {
            0
        } else if kind == 30 {
            1
        } else {
            2
        };
        return ptr_size + 1 + leb_u32_len(align) + leb_u32_len(0);
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let ptr_size: i32 = expression_code_size(ast_base, ptr_index);
        if ptr_size < 0 {
            return -1;
        };
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let align: i32 = if kind == 32 {
            0
        } else if kind == 33 {
            1
        } else {
            2
        };
        return ptr_size
            + value_size
            + 1
            + leb_u32_len(align)
            + leb_u32_len(0)
            + 1
            + leb_i32_len(0);
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        let extra: i32 = cast_expression_extra_code_size(value_type, target_type);
        if extra < 0 {
            return -1;
        };
        return value_size + extra;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 46
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_size: i32 = expression_code_size(ast_base, left_index);
        if left_size < 0 {
            return -1;
        };
        let right_size: i32 = expression_code_size(ast_base, right_index);
        if right_size < 0 {
            return -1;
        };
        return left_size + right_size + 1;
    };
    if kind == 20 || kind == 21 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let left_size: i32 = expression_code_size(ast_base, left_index);
        if left_size < 0 {
            return -1;
        };
        let right_size: i32 = expression_code_size(ast_base, right_index);
        if right_size < 0 {
            return -1;
        };
        return left_size + right_size + 6;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let condition_size: i32 = expression_code_size(ast_base, condition_index);
        if condition_size < 0 {
            return -1;
        };
        let then_size: i32 = expression_code_size(ast_base, then_index);
        if then_size < 0 {
            return -1;
        };
        let else_size: i32 = expression_code_size(ast_base, else_index);
        if else_size < 0 {
            return -1;
        };
        return condition_size + then_size + else_size + 4;
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let init_size: i32 = expression_code_size(ast_base, init_index);
        if init_size < 0 {
            return -1;
        };
        let body_size: i32 = expression_code_size(ast_base, body_index);
        if body_size < 0 {
            return -1;
        };
        return init_size + body_size + 1 + leb_u32_len(local_index);
    };
    if kind == 10 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let value_size: i32 = expression_code_size(ast_base, value_index);
        if value_size < 0 {
            return -1;
        };
        return value_size + 1 + leb_u32_len(local_index);
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let first_size: i32 = expression_code_size(ast_base, first_index);
        if first_size < 0 {
            return -1;
        };
        let then_size: i32 = expression_code_size(ast_base, then_index);
        if then_size < 0 {
            return -1;
        };
        return first_size + then_size + 1;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let body_size: i32 = expression_code_size(ast_base, body_index);
        if body_size < 0 {
            return -1;
        };
        return body_size + 10;
    };
    if kind == 13 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            let value_size: i32 = expression_code_size(ast_base, value_index);
            if value_size < 0 {
                return -1;
            };
            return value_size + 1 + leb_u32_len(branch_depth);
        };
        let const_size: i32 = 1 + leb_i32_len(0);
        return const_size + 1 + leb_u32_len(branch_depth);
    };
    if kind == 24 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        return 1 + leb_u32_len(branch_depth);
    };
    -1
}


fn remap_expression_calls(
    ast_base: i32,
    expr_index: i32,
    runtime_map_ptr: i32,
    func_index: i32,
) -> i32 {
    if expr_index < 0 {
        return 0;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        return 0;
    };
    if kind == 1 {
        if runtime_map_ptr <= 0 {
            return -1;
        };
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let mut runtime_index: i32 = -1;
        let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
        let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
        if call_name_ptr >= 0 {
            let total_funcs: i32 = ast_functions_count(ast_base);
            let mut search_idx: i32 = 0;
            while search_idx < total_funcs {
                let search_entry_ptr: i32 = ast_function_entry_ptr(ast_base, search_idx);
                let search_name_ptr: i32 = load_i32(search_entry_ptr);
                let search_name_len: i32 = load_i32(search_entry_ptr + 4);
                if identifiers_match(
                    call_name_ptr,
                    call_name_len,
                    search_name_ptr,
                    search_name_len,
                ) {
                    runtime_index = load_i32(runtime_map_ptr + search_idx * WORD_SIZE);
                    if runtime_index >= 0 {
                        break;
                    };
                };
                search_idx = search_idx + 1;
            };
        };
        if runtime_index < 0 {
            runtime_index = load_i32(runtime_map_ptr + callee_index * WORD_SIZE);
            if runtime_index < 0 {
                return -1;
            };
        };
        store_i32(call_metadata_callee_index_ptr(metadata_ptr), runtime_index);
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        if arg_count > 0 {
            if args_base < 0 {
                return -1;
            };
        };
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * WORD_SIZE);
            if remap_expression_calls(ast_base, arg_expr_index, runtime_map_ptr, func_index) < 0 {
                return -1;
            };
            arg_idx = arg_idx + 1;
        };
        return 0;
    };
    if kind == 6 || kind == 8 || kind == 38 || kind == 42 {
        return 0;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        return remap_expression_calls(ast_base, element_index, runtime_map_ptr, func_index);
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count > 0 {
            if values_ptr < 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < element_count {
                let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
                if remap_expression_calls(ast_base, element_index, runtime_map_ptr, func_index) < 0 {
                    return -1;
                };
                idx = idx + 1;
            };
        };
        return 0;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        if remap_expression_calls(ast_base, array_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, index_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        if remap_expression_calls(ast_base, array_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, index_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 12);
        if remap_expression_calls(ast_base, tuple_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index);
    };
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        return remap_expression_calls(ast_base, tuple_index, runtime_map_ptr, func_index);
    };
    if kind == 48 {
        let struct_index: i32 = load_i32(entry_ptr + 4);
        return remap_expression_calls(ast_base, struct_index, runtime_map_ptr, func_index);
    };
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count > 0 {
            if values_ptr < 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < element_count {
                let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
                if remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index) < 0 {
                    return -1;
                };
                idx = idx + 1;
            };
        };
        return 0;
    };
    if kind == 47 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        let field_count: i32 = load_i32(entry_ptr + 12);
        if field_count > 0 {
            if metadata_ptr <= 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < field_count {
                let entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, idx);
                if entry <= 0 {
                    return -1;
                };
                let value_index: i32 = struct_literal_field_value_index(entry);
                if remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index) < 0 {
                    return -1;
                };
                idx = idx + 1;
            };
        };
        return 0;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if remap_expression_calls(ast_base, ptr_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if remap_expression_calls(ast_base, ptr_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 27 || kind == 28 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        if remap_expression_calls(ast_base, tuple_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 26 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        if remap_expression_calls(ast_base, ptr_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 25 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        if remap_expression_calls(ast_base, ptr_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 22 || kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        return remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index);
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        if remap_expression_calls(ast_base, condition_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, then_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, else_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 9 {
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        if remap_expression_calls(ast_base, init_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, body_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 10 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        return remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index);
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        if remap_expression_calls(ast_base, first_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        if remap_expression_calls(ast_base, then_index, runtime_map_ptr, func_index) < 0 {
            return -1;
        };
        return 0;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        return remap_expression_calls(ast_base, body_index, runtime_map_ptr, func_index);
    };
    if kind == 13 {
        let value_index: i32 = load_i32(entry_ptr + 8);
        if value_index >= 0 {
            return remap_expression_calls(ast_base, value_index, runtime_map_ptr, func_index);
        };
        return 0;
    };
    if kind == 24 {
        return 0;
    };
    0
}


fn remap_function_calls(ast_base: i32, func_index: i32, runtime_map_ptr: i32) -> i32 {
    if runtime_map_ptr <= 0 {
        return -1;
    };
    let entry_ptr: i32 = ast_function_entry_ptr(ast_base, func_index);
    let body_kind: i32 = load_i32(entry_ptr + 12);
    if body_kind == 0 {
        return 0;
    };
    if body_kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 16);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
        if callee_index < 0 {
            return -1;
        };
        let runtime_index: i32 = load_i32(runtime_map_ptr + callee_index * WORD_SIZE);
        if runtime_index < 0 {
            return -1;
        };
        store_i32(call_metadata_callee_index_ptr(metadata_ptr), runtime_index);
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        if arg_count > 0 {
            if args_base < 0 {
                return -1;
            };
        };
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * WORD_SIZE);
            if remap_expression_calls(ast_base, arg_expr_index, runtime_map_ptr, func_index) < 0 {
                return -1;
            };
            arg_idx = arg_idx + 1;
        };
        return 0;
    };
    if body_kind == 2 {
        let body_index: i32 = load_i32(entry_ptr + 16);
        return remap_expression_calls(ast_base, body_index, runtime_map_ptr, func_index);
    };
    0
}


fn emit_expression(
    base: i32,
    offset: i32,
    ast_base: i32,
    expr_index: i32,
    runtime_map_ptr: i32,
    runtime_func_count: i32,
) -> i32 {
    if expr_index < 0 {
        return -1;
    };
    if expr_index >= ast_expr_count(ast_base) {
        return -1;
    };
    let entry_ptr: i32 = ast_expr_entry_ptr(ast_base, expr_index);
    let kind: i32 = load_i32(entry_ptr);
    if kind == 0 {
        let value: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = offset;
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, value);
        return out;
    };
    if kind == 1 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 4);
        if metadata_ptr < 0 {
            return -1;
        };
        let callee_slot: i32 = call_metadata_callee_index_ptr(metadata_ptr);
        if callee_slot <= 0 {
            return -1;
        };
        let mut callee_index: i32 = load_i32(callee_slot);
        if callee_index < 0 {
            return -1;
        };
        if runtime_map_ptr > 0 {
            if callee_index >= runtime_func_count {
                let runtime_index: i32 =
                    load_i32(runtime_map_ptr + callee_index * WORD_SIZE);
                if runtime_index < 0 {
                    return -1;
                };
                store_i32(callee_slot, runtime_index);
                callee_index = runtime_index;
            } else {
                let call_name_ptr: i32 = call_metadata_name_ptr(metadata_ptr);
                let call_name_len: i32 = call_metadata_name_len(metadata_ptr);
                if call_name_ptr >= 0 {
                    let total_funcs: i32 = ast_functions_count(ast_base);
                    let mut search_idx: i32 = 0;
                    while search_idx < total_funcs {
                        let search_entry_ptr: i32 =
                            ast_function_entry_ptr(ast_base, search_idx);
                        let search_name_ptr: i32 = load_i32(search_entry_ptr);
                        let search_name_len: i32 = load_i32(search_entry_ptr + 4);
                        if identifiers_match(
                            call_name_ptr,
                            call_name_len,
                            search_name_ptr,
                            search_name_len,
                        ) {
                            let runtime_index: i32 =
                                load_i32(runtime_map_ptr + search_idx * WORD_SIZE);
                            if runtime_index >= 0 {
                                store_i32(callee_slot, runtime_index);
                                callee_index = runtime_index;
                            };
                            break;
                        };
                        search_idx = search_idx + 1;
                    };
                };
            };
        };
        let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
        let args_base: i32 = call_metadata_args_base(metadata_ptr);
        let mut out: i32 = offset;
        let mut arg_idx: i32 = 0;
        while arg_idx < arg_count {
            let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
            out = emit_expression(
                base,
                out,
                ast_base,
                arg_expr_index,
                runtime_map_ptr,
                runtime_func_count,
            );
            if out < 0 {
                return -1;
            };
            arg_idx = arg_idx + 1;
        };
        out = write_byte(base, out, 16);
        out = write_u32_leb(base, out, callee_index);
        return out;
    };
    if kind == 6 {
        let param_index: i32 = load_i32(entry_ptr + 4);
        if param_index < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 32);
        out = write_u32_leb(base, out, param_index);
        return out;
    };
    if kind == 8 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        if local_index < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 32);
        out = write_u32_leb(base, out, local_index);
        return out;
    };
    if kind == 35 {
        let element_index: i32 = load_i32(entry_ptr + 4);
        let length: i32 = load_i32(entry_ptr + 8);
        if length < 0 {
            return -1;
        };
        let mut out: i32 = emit_expression(base, offset, ast_base, element_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, length);
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 6);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 37 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if values_ptr < 0 {
            return -1;
        };
        if element_count <= 0 {
            return -1;
        };
        let mut out: i32 = offset;
        let mut idx: i32 = 0;
        while idx < element_count {
            let element_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
            out = emit_expression(base, out, ast_base, element_index, runtime_map_ptr, runtime_func_count);
            if out < 0 {
                return -1;
            };
            idx = idx + 1;
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if expr_type < 0 {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 8);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, element_count);
        return out;
    };
    if kind == 36 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, array_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, index_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, array_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 11);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 44 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let index_index: i32 = load_i32(entry_ptr + 8);
        let value_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, array_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, index_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let type_index: i32 = array_type_heap_index(ast_base, array_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 14);
        out = write_u32_leb(base, out, type_index);
        out = emit_expression(base, out, ast_base, array_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, index_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 11);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 45 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, tuple_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if !type_id_is_tuple(tuple_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, tuple_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 5);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, field_index);
        out = emit_expression(base, out, ast_base, tuple_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 2);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, field_index);
        return out;
    };
    if kind == 38 {
        let array_index: i32 = load_i32(entry_ptr + 4);
        let array_type: i32 = ast_expr_type(ast_base, array_index);
        if !type_id_is_array(array_type) {
            return -1;
        };
        let length: i32 = array_type_length(ast_base, array_type);
        if length < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, length);
        return out;
    };
    if kind == 41 {
        let tuple_index: i32 = load_i32(entry_ptr + 4);
        let field_index: i32 = load_i32(entry_ptr + 8);
        if field_index < 0 {
            return -1;
        };
        let mut out: i32 = emit_expression(base, offset, ast_base, tuple_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let tuple_type: i32 = ast_expr_type(ast_base, tuple_index);
        if !type_id_is_tuple(tuple_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, tuple_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 2);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, field_index);
        return out;
    };
    if kind == 48 {
        let struct_index: i32 = load_i32(entry_ptr + 4);
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        if metadata_ptr <= 0 {
            return -1;
        };
        let start: i32 = offset;
        let mut out: i32 = emit_expression(
            base,
            offset,
            ast_base,
            struct_index,
            runtime_map_ptr,
            runtime_func_count,
        );
        if out < 0 {
            return -1;
        };
        let struct_type: i32 = ast_expr_type(ast_base, struct_index);
        if !type_id_is_struct(struct_type) {
            return -1;
        };
        let field_index: i32 = struct_get_label_extra(metadata_ptr);
        if field_index < 0 {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, struct_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 2);
        out = write_u32_leb(base, out, type_index);
        out = write_u32_leb(base, out, field_index);
        let expected: i32 = expression_code_size(ast_base, expr_index);
        if expected < 0 {
            return -1;
        };
        if out - start != expected {
            return -1;
        };
        return out;
    };
    if kind == 40 {
        let values_ptr: i32 = load_i32(entry_ptr + 4);
        let element_count: i32 = load_i32(entry_ptr + 8);
        if element_count < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        if element_count > 0 {
            if values_ptr < 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < element_count {
                let value_index: i32 = load_i32(values_ptr + idx * WORD_SIZE);
                out = emit_expression(base, out, ast_base, value_index, runtime_map_ptr, runtime_func_count);
                if out < 0 {
                    return -1;
                };
                idx = idx + 1;
            };
        };
        let expr_type: i32 = ast_expr_type(ast_base, expr_index);
        if !type_id_is_tuple(expr_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, expr_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 0);
        out = write_u32_leb(base, out, type_index);
        return out;
    };
    if kind == 47 {
        let metadata_ptr: i32 = load_i32(entry_ptr + 8);
        let field_count: i32 = load_i32(entry_ptr + 12);
        if field_count < 0 {
            return -1;
        };
        let start: i32 = offset;
        let mut out: i32 = offset;
        if field_count > 0 {
            if metadata_ptr <= 0 {
                return -1;
            };
            let mut idx: i32 = 0;
            while idx < field_count {
                let entry: i32 = struct_literal_field_entry_ptr(metadata_ptr, idx);
                if entry <= 0 {
                    return -1;
                };
                let value_index: i32 = struct_literal_field_value_index(entry);
                out = emit_expression(
                    base,
                    out,
                    ast_base,
                    value_index,
                    runtime_map_ptr,
                    runtime_func_count,
                );
                if out < 0 {
                    return -1;
                };
                idx = idx + 1;
            };
        };
        let struct_type: i32 = ast_expr_type(ast_base, expr_index);
        if !type_id_is_struct(struct_type) {
            return -1;
        };
        let type_index: i32 = type_id_heap_type_index(ast_base, struct_type);
        if type_index < 0 {
            return -1;
        };
        out = write_byte(base, out, 251);
        out = write_byte(base, out, 0);
        out = write_u32_leb(base, out, type_index);
        let expected: i32 = expression_code_size(ast_base, expr_index);
        if expected < 0 {
            return -1;
        };
        if out - start != expected {
            return -1;
        };
        return out;
    };
    if kind == 42 {
        let bytes_ptr: i32 = load_i32(entry_ptr + 4);
        let byte_count: i32 = load_i32(entry_ptr + 8);
        if byte_count < 0 {
            return -1;
        };
        if byte_count == 0 {
            return offset;
        };
        if bytes_ptr < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        let mut idx: i32 = 0;
        while idx < byte_count {
            let byte_value: i32 = load_i32(bytes_ptr + idx * WORD_SIZE);
            if byte_value < 0 || byte_value > 255 {
                return -1;
            };
            out = write_byte(base, out, byte_value);
            idx = idx + 1;
        };
        return out;
    };
    if kind == 29 || kind == 30 || kind == 31 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, ptr_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let opcode: i32 = if kind == 29 {
            45
        } else if kind == 30 {
            47
        } else {
            40
        };
        let align: i32 = if kind == 29 {
            0
        } else if kind == 30 {
            1
        } else {
            2
        };
        out = write_byte(base, out, opcode);
        out = write_u32_leb(base, out, align);
        out = write_u32_leb(base, out, 0);
        return out;
    };
    if kind == 32 || kind == 33 || kind == 34 {
        let ptr_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, ptr_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let opcode: i32 = if kind == 32 {
            58
        } else if kind == 33 {
            59
        } else {
            54
        };
        let align: i32 = if kind == 32 {
            0
        } else if kind == 33 {
            1
        } else {
            2
        };
        out = write_byte(base, out, opcode);
        out = write_u32_leb(base, out, align);
        out = write_u32_leb(base, out, 0);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 0);
        return out;
    };
    if kind == 39 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let target_type: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let value_type: i32 = ast_expr_type(ast_base, value_index);
        out = emit_cast_value(base, out, value_type, target_type);
        return out;
    };
    if kind == 2
        || kind == 3
        || kind == 4
        || kind == 5
        || kind == 46
        || kind == 14
        || kind == 15
        || kind == 16
        || kind == 17
        || kind == 18
        || kind == 19
        || kind == 25
        || kind == 26
        || kind == 27
        || kind == 28
    {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = emit_expression(base, out, ast_base, right_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        let op_type: i32 = if kind >= 14 && kind <= 19 {
            ast_expr_type(ast_base, left_index)
        } else {
            ast_expr_type(ast_base, expr_index)
        };
        if op_type < 0 {
            return -1;
        };
        let is_i64: bool = type_id_is_64_bit_integer(op_type);
        let is_signed: bool = type_id_is_signed_integer(op_type);
        let opcode: i32 = if kind == 2 {
            if is_i64 { 124 } else { 106 }
        } else if kind == 3 {
            if is_i64 { 125 } else { 107 }
        } else if kind == 4 {
            if is_i64 { 126 } else { 108 }
        } else if kind == 5 {
            if is_i64 {
                if is_signed { 127 } else { 128 }
            } else if is_signed {
                109
            } else {
                110
            }
        } else if kind == 46 {
            if is_i64 {
                if is_signed { 129 } else { 130 }
            } else if is_signed {
                111
            } else {
                112
            }
        } else if kind == 14 {
            if is_i64 { 81 } else { 70 }
        } else if kind == 15 {
            if is_i64 { 82 } else { 71 }
        } else if kind == 16 {
            if is_i64 {
                if is_signed { 83 } else { 84 }
            } else if is_signed {
                72
            } else {
                73
            }
        } else if kind == 17 {
            if is_i64 {
                if is_signed { 85 } else { 86 }
            } else if is_signed {
                74
            } else {
                75
            }
        } else if kind == 18 {
            if is_i64 {
                if is_signed { 87 } else { 88 }
            } else if is_signed {
                76
            } else {
                77
            }
        } else if kind == 19 {
            if is_i64 {
                if is_signed { 89 } else { 90 }
            } else if is_signed {
                78
            } else {
                79
            }
        } else if kind == 25 {
            if is_i64 { 132 } else { 114 }
        } else if kind == 26 {
            if is_i64 { 131 } else { 113 }
        } else if kind == 27 {
            if is_i64 { 134 } else { 116 }
        } else if is_i64 {
            if is_signed { 135 } else { 136 }
        } else if is_signed {
            117
        } else {
            118
        };
        out = write_byte(base, out, opcode);
        return out;
    };
    if kind == 20 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 1);
        out = write_byte(base, out, 5);
        out = emit_expression(base, out, ast_base, right_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 21 {
        let left_index: i32 = load_i32(entry_ptr + 4);
        let right_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, left_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = emit_expression(base, out, ast_base, right_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 5);
        out = write_byte(base, out, 65);
        out = write_i32_leb(base, out, 0);
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 22 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 69);
        return out;
    };
    if kind == 23 {
        let value_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 15);
        return out;
    };
    if kind == 7 {
        let condition_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let else_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, condition_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 4);
        out = write_byte(base, out, 127);
        out = emit_expression(base, out, ast_base, then_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 5);
        out = emit_expression(base, out, ast_base, else_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 9 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let init_index: i32 = load_i32(entry_ptr + 8);
        let body_index: i32 = load_i32(entry_ptr + 12);
        let mut out: i32 = emit_expression(base, offset, ast_base, init_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 33);
        out = write_u32_leb(base, out, local_index);
        out = emit_expression(base, out, ast_base, body_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        return out;
    };
    if kind == 10 {
        let local_index: i32 = load_i32(entry_ptr + 4);
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, value_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 34);
        out = write_u32_leb(base, out, local_index);
        return out;
    };
    if kind == 11 {
        let first_index: i32 = load_i32(entry_ptr + 4);
        let then_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = emit_expression(base, offset, ast_base, first_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 26);
        out = emit_expression(base, out, ast_base, then_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        return out;
    };
    if kind == 12 {
        let body_index: i32 = load_i32(entry_ptr + 4);
        let mut out: i32 = write_byte(base, offset, 2);
        out = write_byte(base, out, 127);
        out = write_byte(base, out, 3);
        out = write_byte(base, out, 64);
        out = emit_expression(base, out, ast_base, body_index, runtime_map_ptr, runtime_func_count);
        if out < 0 {
            return -1;
        };
        out = write_byte(base, out, 26);
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, 0);
        out = write_byte(base, out, 11);
        out = write_byte(base, out, 0);
        out = write_byte(base, out, 11);
        return out;
    };
    if kind == 13 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let value_index: i32 = load_i32(entry_ptr + 8);
        let mut out: i32 = offset;
        if value_index >= 0 {
            out = emit_expression(base, out, ast_base, value_index, runtime_map_ptr, runtime_func_count);
            if out < 0 {
                return -1;
            };
        } else {
            out = write_byte(base, out, 65);
            out = write_i32_leb(base, out, 0);
        };
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, branch_depth);
        return out;
    };
    if kind == 24 {
        let branch_depth: i32 = load_i32(entry_ptr + 4);
        if branch_depth < 0 {
            return -1;
        };
        let mut out: i32 = offset;
        out = write_byte(base, out, 12);
        out = write_u32_leb(base, out, branch_depth);
        return out;
    };
    -1
}


fn emit_type_section(
    base: i32,
    offset: i32,
    ast_base: i32,
    func_count: i32,
    array_count: i32,
    tuple_count: i32,
    struct_count: i32,
    runtime_map_ptr: i32,
    runtime_func_count: i32,
) -> i32 {
    if array_count < 0 {
        return -1;
    };
    if tuple_count < 0 {
        return -1;
    };
    if struct_count < 0 {
        return -1;
    };
    let total_types: i32 = array_count + tuple_count + struct_count + runtime_func_count;
    let mut payload_size: i32 = leb_u32_len(total_types);

    let composite_count: i32 = array_count + tuple_count + struct_count;
    let mut heap_idx: i32 = 0;
    while heap_idx < composite_count {
        let mut handled: bool = false;
        let mut array_idx: i32 = 0;
        while array_idx < array_count {
            let current_heap: i32 = ast_array_heap_index(ast_base, array_idx);
            if current_heap == heap_idx {
                let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, array_idx);
                let element_type_id: i32 =
                    load_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET);
                let element_size: i32 =
                    type_id_wasm_value_type_len(ast_base, element_type_id);
                if element_size < 0 {
                    return -1;
                };
                let entry_size: i32 =
                    leb_i32_len(WASM_COMPOSITE_TYPE_ARRAY) + element_size + 1;
                payload_size = payload_size + entry_size;
                handled = true;
                break;
            };
            array_idx = array_idx + 1;
        };
        if handled {
            heap_idx = heap_idx + 1;
            continue;
        };
        let mut tuple_idx: i32 = 0;
        while tuple_idx < tuple_count {
            let current_heap: i32 = ast_tuple_heap_index(ast_base, tuple_idx);
            if current_heap == heap_idx {
                let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, tuple_idx);
                let element_count: i32 =
                    load_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET);
                if element_count < 0 {
                    return -1;
                };
                let mut entry_size: i32 =
                    leb_i32_len(WASM_COMPOSITE_TYPE_STRUCT)
                    + leb_u32_len(element_count);
                if element_count > 0 {
                    let elements_ptr: i32 =
                        load_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET);
                    if elements_ptr < 0 {
                        return -1;
                    };
                    let mut field_idx: i32 = 0;
                    while field_idx < element_count {
                        let field_type_id: i32 =
                            load_i32(elements_ptr + field_idx * WORD_SIZE);
                        let field_size: i32 =
                            type_id_wasm_value_type_len(ast_base, field_type_id);
                        if field_size < 0 {
                            return -1;
                        };
                        entry_size = entry_size + field_size + 1;
                        field_idx = field_idx + 1;
                    };
                };
                payload_size = payload_size + entry_size;
                handled = true;
                break;
            };
            tuple_idx = tuple_idx + 1;
        };
        if handled {
            heap_idx = heap_idx + 1;
            continue;
        };
        let mut struct_idx: i32 = 0;
        while struct_idx < struct_count {
            let current_heap: i32 = ast_struct_heap_index(ast_base, struct_idx);
            if current_heap == heap_idx {
                let field_count: i32 = ast_struct_type_field_count(ast_base, struct_idx);
                if field_count < 0 {
                    return -1;
                };
                let field_stride: i32 = ast_struct_type_field_stride(ast_base, struct_idx);
                if field_stride < STRUCT_FIELD_METADATA_HEADER_WORDS {
                    return -1;
                };
                let fields_ptr: i32 = ast_struct_type_fields_ptr(ast_base, struct_idx);
                if field_count > 0 {
                    if fields_ptr <= 0 {
                        return -1;
                    };
                };
                let mut entry_size: i32 =
                    leb_i32_len(WASM_COMPOSITE_TYPE_STRUCT) + leb_u32_len(field_count);
                if field_count > 0 {
                    let stride_bytes: i32 = field_stride * WORD_SIZE;
                    let mut field_idx: i32 = 0;
                    while field_idx < field_count {
                        let record_ptr: i32 = fields_ptr + field_idx * stride_bytes;
                        let field_type_id: i32 = load_i32(
                            record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE,
                        );
                        let field_size: i32 =
                            type_id_wasm_value_type_len(ast_base, field_type_id);
                        if field_size < 0 {
                            return -1;
                        };
                        entry_size = entry_size + field_size + 1;
                        field_idx = field_idx + 1;
                    };
                };
                payload_size = payload_size + entry_size;
                handled = true;
                break;
            };
            struct_idx = struct_idx + 1;
        };
        if !handled {
            return -1;
        };
        heap_idx = heap_idx + 1;
    };

    let mut idx: i32 = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let param_types_ptr: i32 = load_i32(entry_ptr + 24);
        if param_count > 0 {
            if param_types_ptr < 0 {
                return -1;
            };
        };
        let mut entry_size: i32 = 1;
        entry_size = entry_size + leb_u32_len(param_count);
        let mut param_idx: i32 = 0;
        while param_idx < param_count {
            let param_type_id: i32 = load_i32(param_types_ptr + param_idx * 4);
            let param_size: i32 = type_id_wasm_value_type_len(ast_base, param_type_id);
            if param_size < 0 {
                return -1;
            };
            entry_size = entry_size + param_size;
            param_idx = param_idx + 1;
        };
        let return_type_id: i32 = load_i32(entry_ptr + 28);
        if return_type_id >= 0 {
            let return_size: i32 = type_id_wasm_value_type_len(ast_base, return_type_id);
            if return_size < 0 {
                return -1;
            };
            entry_size = entry_size + leb_u32_len(1) + return_size;
        } else {
            entry_size = entry_size + leb_u32_len(0);
        };
        payload_size = payload_size + entry_size;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, total_types);

    heap_idx = 0;
    while heap_idx < composite_count {
        let mut handled: bool = false;
        let mut array_idx: i32 = 0;
        while array_idx < array_count {
            let current_heap: i32 = ast_array_heap_index(ast_base, array_idx);
            if current_heap == heap_idx {
                let entry_ptr: i32 = ast_array_type_entry_ptr(ast_base, array_idx);
                let element_type_id: i32 =
                    load_i32(entry_ptr + AST_ARRAY_TYPE_ELEMENT_OFFSET);
                out = write_i32_leb(base, out, WASM_COMPOSITE_TYPE_ARRAY);
                let next: i32 =
                    write_type_id_as_wasm_value_type(base, out, ast_base, element_type_id);
                if next < 0 {
                    return -1;
                };
                out = write_byte(base, next, WASM_MUTABILITY_VAR);
                handled = true;
                break;
            };
            array_idx = array_idx + 1;
        };
        if handled {
            heap_idx = heap_idx + 1;
            continue;
        };
        let mut tuple_idx: i32 = 0;
        while tuple_idx < tuple_count {
            let current_heap: i32 = ast_tuple_heap_index(ast_base, tuple_idx);
            if current_heap == heap_idx {
                let entry_ptr: i32 = ast_tuple_type_entry_ptr(ast_base, tuple_idx);
                let element_count: i32 =
                    load_i32(entry_ptr + AST_TUPLE_TYPE_COUNT_OFFSET);
                if element_count < 0 {
                    return -1;
                };
                out = write_i32_leb(base, out, WASM_COMPOSITE_TYPE_STRUCT);
                out = write_u32_leb(base, out, element_count);
                if element_count > 0 {
                    let elements_ptr: i32 =
                        load_i32(entry_ptr + AST_TUPLE_TYPE_ELEMENTS_PTR_OFFSET);
                    if elements_ptr < 0 {
                        return -1;
                    };
                    let mut field_idx: i32 = 0;
                    while field_idx < element_count {
                        let field_type_id: i32 =
                            load_i32(elements_ptr + field_idx * WORD_SIZE);
                        let next: i32 = write_type_id_as_wasm_value_type(
                            base,
                            out,
                            ast_base,
                            field_type_id,
                        );
                        if next < 0 {
                            return -1;
                        };
                        out = write_byte(base, next, WASM_MUTABILITY_VAR);
                        field_idx = field_idx + 1;
                    };
                };
                handled = true;
                break;
            };
            tuple_idx = tuple_idx + 1;
        };
        if handled {
            heap_idx = heap_idx + 1;
            continue;
        };
        let mut struct_idx: i32 = 0;
        while struct_idx < struct_count {
            let current_heap: i32 = ast_struct_heap_index(ast_base, struct_idx);
            if current_heap == heap_idx {
                let field_count: i32 = ast_struct_type_field_count(ast_base, struct_idx);
                if field_count < 0 {
                    return -1;
                };
                out = write_i32_leb(base, out, WASM_COMPOSITE_TYPE_STRUCT);
                out = write_u32_leb(base, out, field_count);
                if field_count > 0 {
                    let fields_ptr: i32 = ast_struct_type_fields_ptr(ast_base, struct_idx);
                    if fields_ptr <= 0 {
                        return -1;
                    };
                    let field_stride: i32 = ast_struct_type_field_stride(ast_base, struct_idx);
                    if field_stride < STRUCT_FIELD_METADATA_HEADER_WORDS {
                        return -1;
                    };
                    let stride_bytes: i32 = field_stride * WORD_SIZE;
                    let mut field_idx: i32 = 0;
                    while field_idx < field_count {
                        let record_ptr: i32 = fields_ptr + field_idx * stride_bytes;
                        let field_type_id: i32 = load_i32(
                            record_ptr + STRUCT_FIELD_TYPE_WORD_OFFSET * WORD_SIZE,
                        );
                        let next: i32 = write_type_id_as_wasm_value_type(
                            base,
                            out,
                            ast_base,
                            field_type_id,
                        );
                        if next < 0 {
                            return -1;
                        };
                        out = write_byte(base, next, WASM_MUTABILITY_VAR);
                        field_idx = field_idx + 1;
                    };
                };
                handled = true;
                break;
            };
            struct_idx = struct_idx + 1;
        };
        if !handled {
            return -1;
        };
        heap_idx = heap_idx + 1;
    };

    idx = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let param_types_ptr: i32 = load_i32(entry_ptr + 24);
        if param_count > 0 {
            if param_types_ptr < 0 {
                return -1;
            };
        };
        out = write_byte(base, out, 96);
        out = write_u32_leb(base, out, param_count);
        let mut param_idx: i32 = 0;
        while param_idx < param_count {
            let param_type_id: i32 = load_i32(param_types_ptr + param_idx * 4);
            let next: i32 = write_type_id_as_wasm_value_type(
                base,
                out,
                ast_base,
                param_type_id,
            );
            if next < 0 {
                return -1;
            };
            out = next;
            param_idx = param_idx + 1;
        };
        let return_type_id: i32 = load_i32(entry_ptr + 28);
        if return_type_id >= 0 {
            out = write_u32_leb(base, out, 1);
            let next: i32 = write_type_id_as_wasm_value_type(
                base,
                out,
                ast_base,
                return_type_id,
            );
            if next < 0 {
                return -1;
            };
            out = next;
        } else {
            out = write_u32_leb(base, out, 0);
        };
        idx = idx + 1;
    };
    out
}
fn emit_function_section(
    base: i32,
    offset: i32,
    func_count: i32,
    runtime_map_ptr: i32,
    runtime_func_count: i32,
    array_count: i32,
    tuple_count: i32,
    struct_count: i32,
) -> i32 {
    if runtime_func_count > 0 {
        if runtime_map_ptr <= 0 {
            return -1;
        };
    };
    if struct_count < 0 {
        return -1;
    };
    let mut payload_size: i32 = leb_u32_len(runtime_func_count);
    let mut idx: i32 = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let type_index: i32 = array_count + tuple_count + struct_count + runtime_index;
        payload_size = payload_size + leb_u32_len(type_index);
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 3);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, runtime_func_count);
    idx = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let type_index: i32 = array_count + tuple_count + struct_count + runtime_index;
        out = write_u32_leb(base, out, type_index);
        idx = idx + 1;
    };
    out
}


fn emit_memory_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 5);
    let pages: i32 = COMPILER_MEMORY_PAGES;
    let payload_size: i32 = leb_u32_len(1) + 1 + leb_u32_len(pages) + leb_u32_len(pages);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, 1);
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, pages);
    out = write_u32_leb(base, out, pages);
    out
}


fn emit_export_section(
    base: i32,
    offset: i32,
    ast_base: i32,
    func_count: i32,
    runtime_map_ptr: i32,
) -> i32 {
    if func_count > 0 {
        if runtime_map_ptr <= 0 {
            return -1;
        };
    };
    let mut exported_functions: i32 = 0;
    let mut idx: i32 = 0;
    while idx < func_count {
        let runtime_index: i32 = load_i32(runtime_map_ptr + idx * WORD_SIZE);
        if runtime_index >= 0 {
            let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
            let name_len: i32 = load_i32(entry_ptr + 4);
            if name_len > 0 {
                exported_functions = exported_functions + 1;
            };
        };
        idx = idx + 1;
    };
    let total_exports: i32 = exported_functions + 1;
    let mut payload_size: i32 = leb_u32_len(total_exports);
    payload_size = payload_size + leb_u32_len(6) + 6 + 1 + leb_u32_len(0);
    idx = 0;
    while idx < func_count {
        let runtime_index: i32 = load_i32(runtime_map_ptr + idx * WORD_SIZE);
        if runtime_index >= 0 {
            let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
            let name_len: i32 = load_i32(entry_ptr + 4);
            if name_len > 0 {
                payload_size = payload_size
                    + leb_u32_len(name_len)
                    + name_len
                    + 1
                    + leb_u32_len(runtime_index);
            };
        };
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 7);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, total_exports);

    out = write_u32_leb(base, out, 6);
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 'e');
    out = write_byte(base, out, 'm');
    out = write_byte(base, out, 'o');
    out = write_byte(base, out, 'r');
    out = write_byte(base, out, 'y');
    out = write_byte(base, out, 2);
    out = write_u32_leb(base, out, 0);

    idx = 0;
    while idx < func_count {
        let runtime_index: i32 = load_i32(runtime_map_ptr + idx * WORD_SIZE);
        if runtime_index >= 0 {
            let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
            let name_ptr: i32 = load_i32(entry_ptr);
            let name_len: i32 = load_i32(entry_ptr + 4);
            if name_len > 0 {
                out = write_u32_leb(base, out, name_len);
                let mut byte_idx: i32 = 0;
                while byte_idx < name_len {
                    let byte: i32 = load_u8(name_ptr + byte_idx);
                    out = write_byte(base, out, byte);
                    byte_idx = byte_idx + 1;
                };
                out = write_byte(base, out, '\0');
                out = write_u32_leb(base, out, runtime_index);
            };
        };
        idx = idx + 1;
    };
    out
}


fn emit_code_section(
    base: i32,
    offset: i32,
    ast_base: i32,
    func_count: i32,
    runtime_map_ptr: i32,
    runtime_func_count: i32,
) -> i32 {
    if runtime_func_count > 0 {
        if runtime_map_ptr <= 0 {
            return -1;
        };
    };
    let mut payload_size: i32 = leb_u32_len(runtime_func_count);
    let mut idx: i32 = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let locals_count: i32 = load_i32(entry_ptr + 20);
        let body_data0: i32 = load_i32(entry_ptr + 16);
        let local_types_ptr: i32 = ast_temp_base(ast_base) + func_count * WORD_SIZE;
        let run_types_ptr: i32 = local_types_ptr + locals_count * WORD_SIZE;
        let run_counts_ptr: i32 = run_types_ptr + locals_count * WORD_SIZE;
        let local_counts: i32 = collect_function_local_counts(
            ast_base,
            body_kind,
            body_data0,
            param_count,
            locals_count,
            local_types_ptr,
        );
        if local_counts < 0 {
            return -1;
        };
        if local_counts_total(local_counts) != locals_count {
            return -1;
        };
        let mut local_groups: i32 = 0;
        let mut type_idx: i32 = 0;
        while type_idx < locals_count {
            let type_id: i32 = load_i32(local_types_ptr + type_idx * WORD_SIZE);
            if type_id < 0 {
                return -1;
            };
            let mut run_len: i32 = 1;
            while type_idx + run_len < locals_count {
                let next_type: i32 =
                    load_i32(local_types_ptr + (type_idx + run_len) * WORD_SIZE);
                if next_type != type_id {
                    break;
                };
                run_len = run_len + 1;
            };
            store_i32(run_types_ptr + local_groups * WORD_SIZE, type_id);
            store_i32(run_counts_ptr + local_groups * WORD_SIZE, run_len);
            local_groups = local_groups + 1;
            type_idx = type_idx + run_len;
        };
        let locals_decl_size: i32 = if locals_count > 0 {
            let mut size: i32 = leb_u32_len(local_groups);
            let mut run_idx: i32 = 0;
            while run_idx < local_groups {
                let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                let type_len: i32 = type_id_wasm_value_type_len(ast_base, type_id);
                if type_len < 0 {
                    return -1;
                };
                size = size + leb_u32_len(run_len) + type_len;
                run_idx = run_idx + 1;
            };
            size
        } else {
            leb_u32_len(0)
        };
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = locals_decl_size + 1 + leb_i32_len(literal_value) + 1;
        } else if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if metadata_ptr < 0 {
                return -1;
            };
            let callee_index: i32 = load_i32(call_metadata_callee_index_ptr(metadata_ptr));
            if callee_index < 0 {
                return -1;
            };
            let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
            let args_base: i32 = call_metadata_args_base(metadata_ptr);
            let mut args_size: i32 = 0;
            let mut arg_idx: i32 = 0;
            while arg_idx < arg_count {
                let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                if arg_size < 0 {
                    return -1;
                };
                args_size = args_size + arg_size;
                arg_idx = arg_idx + 1;
            };
            body_size = locals_decl_size + args_size + 1 + leb_u32_len(callee_index) + 1;
        } else {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            let expr_size: i32 = expression_code_size(ast_base, expr_index);
            if expr_size < 0 {
                return -1;
            };
            body_size = locals_decl_size + expr_size + 1;
        };
        payload_size = payload_size + leb_u32_len(body_size) + body_size;
        idx = idx + 1;
    };

    let mut out: i32 = offset;
    out = write_byte(base, out, 10);
    out = write_u32_leb(base, out, payload_size);
    out = write_u32_leb(base, out, runtime_func_count);

    idx = 0;
    while idx < func_count {
        let runtime_index: i32 = if runtime_map_ptr > 0 {
            load_i32(runtime_map_ptr + idx * WORD_SIZE)
        } else {
            -1
        };
        if runtime_index < 0 {
            idx = idx + 1;
            continue;
        };
        let entry_ptr: i32 = ast_function_entry_ptr(ast_base, idx);
        let body_kind: i32 = load_i32(entry_ptr + 12);
        let param_count: i32 = load_i32(entry_ptr + 8);
        let locals_count: i32 = load_i32(entry_ptr + 20);
        let body_data0: i32 = load_i32(entry_ptr + 16);
        let local_types_ptr: i32 = ast_temp_base(ast_base) + func_count * WORD_SIZE;
        let run_types_ptr: i32 = local_types_ptr + locals_count * WORD_SIZE;
        let run_counts_ptr: i32 = run_types_ptr + locals_count * WORD_SIZE;
        let local_counts: i32 = collect_function_local_counts(
            ast_base,
            body_kind,
            body_data0,
            param_count,
            locals_count,
            local_types_ptr,
        );
        if local_counts < 0 {
            return -1;
        };
        if local_counts_total(local_counts) != locals_count {
            return -1;
        };
        let mut local_groups: i32 = 0;
        let mut type_idx: i32 = 0;
        while type_idx < locals_count {
            let type_id: i32 = load_i32(local_types_ptr + type_idx * WORD_SIZE);
            if type_id < 0 {
                return -1;
            };
            let mut run_len: i32 = 1;
            while type_idx + run_len < locals_count {
                let next_type: i32 =
                    load_i32(local_types_ptr + (type_idx + run_len) * WORD_SIZE);
                if next_type != type_id {
                    break;
                };
                run_len = run_len + 1;
            };
            store_i32(run_types_ptr + local_groups * WORD_SIZE, type_id);
            store_i32(run_counts_ptr + local_groups * WORD_SIZE, run_len);
            local_groups = local_groups + 1;
            type_idx = type_idx + run_len;
        };
        let locals_decl_size: i32 = if locals_count > 0 {
            let mut size: i32 = leb_u32_len(local_groups);
            let mut run_idx: i32 = 0;
            while run_idx < local_groups {
                let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                let type_len: i32 = type_id_wasm_value_type_len(ast_base, type_id);
                if type_len < 0 {
                    return -1;
                };
                size = size + leb_u32_len(run_len) + type_len;
                run_idx = run_idx + 1;
            };
            size
        } else {
            leb_u32_len(0)
        };
        let mut body_size: i32 = 0;
        if body_kind == 0 {
            let literal_value: i32 = load_i32(entry_ptr + 16);
            body_size = locals_decl_size + 1 + leb_i32_len(literal_value) + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                while run_idx < local_groups {
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 =
                        write_type_id_as_wasm_value_type(base, out, ast_base, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            out = write_byte(base, out, 65);
            out = write_i32_leb(base, out, literal_value);
            out = write_byte(base, out, 11);
        } else if body_kind == 1 {
            let metadata_ptr: i32 = load_i32(entry_ptr + 16);
            if metadata_ptr < 0 {
                return -1;
            };
            let callee_slot_ptr: i32 = call_metadata_callee_index_ptr(metadata_ptr);
            if callee_slot_ptr <= 0 {
                return -1;
            };
            let mut callee_index: i32 = load_i32(callee_slot_ptr);
            if callee_index < 0 {
                return -1;
            };
            if runtime_map_ptr > 0 {
                if callee_index >= runtime_func_count {
                    let runtime_index: i32 =
                        load_i32(runtime_map_ptr + callee_index * WORD_SIZE);
                    if runtime_index < 0 {
                        return -1;
                    };
                    store_i32(callee_slot_ptr, runtime_index);
                    callee_index = runtime_index;
                };
            };
                let arg_count: i32 = call_metadata_arg_count(metadata_ptr);
                let args_base: i32 = call_metadata_args_base(metadata_ptr);
                let mut args_size: i32 = 0;
                let mut arg_idx: i32 = 0;
                while arg_idx < arg_count {
                    let arg_expr_index: i32 = load_i32(args_base + arg_idx * 4);
                    let arg_size: i32 = expression_code_size(ast_base, arg_expr_index);
                    if arg_size < 0 {
                        return -1;
                    };
                    args_size = args_size + arg_size;
                    arg_idx = arg_idx + 1;
                };
            body_size = locals_decl_size + args_size + 1 + leb_u32_len(callee_index) + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                while run_idx < local_groups {
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 =
                        write_type_id_as_wasm_value_type(base, out, ast_base, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            let mut emit_idx: i32 = 0;
            while emit_idx < arg_count {
                    let arg_expr_index: i32 = load_i32(args_base + emit_idx * 4);
                    out = emit_expression(base, out, ast_base, arg_expr_index, runtime_map_ptr, runtime_func_count);
                    if out < 0 {
                        return -1;
                    };
                    emit_idx = emit_idx + 1;
                };
            out = write_byte(base, out, 16);
            out = write_u32_leb(base, out, callee_index);
            out = write_byte(base, out, 11);
        } else {
            let expr_index: i32 = load_i32(entry_ptr + 16);
            let expr_size: i32 = expression_code_size(ast_base, expr_index);
            if expr_size < 0 {
                return -1;
            };
            body_size = locals_decl_size + expr_size + 1;
            out = write_u32_leb(base, out, body_size);
            if locals_count > 0 {
                out = write_u32_leb(base, out, local_groups);
                let mut run_idx: i32 = 0;
                while run_idx < local_groups {
                    let run_len: i32 = load_i32(run_counts_ptr + run_idx * WORD_SIZE);
                    let type_id: i32 = load_i32(run_types_ptr + run_idx * WORD_SIZE);
                    out = write_u32_leb(base, out, run_len);
                    let next: i32 =
                        write_type_id_as_wasm_value_type(base, out, ast_base, type_id);
                    if next < 0 {
                        return -1;
                    };
                    out = next;
                    run_idx = run_idx + 1;
                };
            } else {
                out = write_u32_leb(base, out, 0);
            };
            out = emit_expression(base, out, ast_base, expr_index, runtime_map_ptr, runtime_func_count);
            if out < 0 {
                return -1;
            };
            out = write_byte(base, out, 11);
        };
        idx = idx + 1;
    };
    out
}


// Serialises the structural type information for compound values into the
// output buffer.  The metadata is consumed later by the emitter when describing
// reference types in the module's type and heap sections.
fn write_type_metadata(out_ptr: i32, ast_base: i32) -> i32 {
    let array_count: i32 = ast_array_types_count(ast_base);
    let mut idx: i32 = 0;
    while idx < array_count {
        let type_id: i32 = array_type_id(idx);
        if resolve_array_type_id(out_ptr, ast_base, type_id) < 0 {
            return -1;
        };
        idx = idx + 1;
    };
    let tuple_count: i32 = ast_tuple_types_count(ast_base);
    let mut tuple_idx: i32 = 0;
    while tuple_idx < tuple_count {
        let type_id: i32 = tuple_type_id(tuple_idx);
        if resolve_tuple_type_id(out_ptr, ast_base, type_id) < 0 {
            return -1;
        };
        tuple_idx = tuple_idx + 1;
    };
    let struct_count: i32 = ast_struct_types_count(ast_base);
    let mut struct_idx: i32 = 0;
    while struct_idx < struct_count {
        let type_id: i32 = struct_type_id(struct_idx);
        if resolve_struct_type_id(out_ptr, ast_base, type_id) < 0 {
            return -1;
        };
        struct_idx = struct_idx + 1;
    };
    if assign_heap_type_indices(out_ptr, ast_base) < 0 {
        return -1;
    };
    0
}


// Produces the final WebAssembly binary.  The emitter writes the module header
// and then each section in order, reading resolved data from the AST and the
// type metadata region prepared earlier in the pipeline.
fn emit_program(out_ptr: i32, ast_base: i32, func_count: i32) -> i32 {
    let mut offset: i32 = 0;
    offset = write_magic(out_ptr, offset);
    let runtime_map: (i32, i32) = build_runtime_function_map(ast_base, func_count);
    let runtime_map_ptr: i32 = runtime_map.0;
    let runtime_func_count: i32 = runtime_map.1;
    if func_count > 0 {
        if runtime_map_ptr <= 0 {
            return -1;
        };
    };
    if runtime_func_count < 0 {
        return -1;
    };
    let mut idx: i32 = 0;
    while idx < func_count {
        if runtime_map_ptr > 0 {
            let runtime_index: i32 = load_i32(runtime_map_ptr + idx * WORD_SIZE);
            if runtime_index >= 0 {
                if remap_function_calls(ast_base, idx, runtime_map_ptr) < 0 {
                    return -1;
                };
            };
        };
        idx = idx + 1;
    };
    let array_count: i32 = ast_array_types_count(ast_base);
    let tuple_count: i32 = ast_tuple_types_count(ast_base);
    let struct_count: i32 = ast_struct_types_count(ast_base);
    offset = emit_type_section(
        out_ptr,
        offset,
        ast_base,
        func_count,
        array_count,
        tuple_count,
        struct_count,
        runtime_map_ptr,
        runtime_func_count,
    );
    if offset < 0 {
        let message: [u8; 34] = "failed to emit WebAssembly type section";
        record_emit_failure(out_ptr, 34, message);
        return -1;
    };
    offset = emit_function_section(
        out_ptr,
        offset,
        func_count,
        runtime_map_ptr,
        runtime_func_count,
        array_count,
        tuple_count,
        struct_count,
    );
    if offset < 0 {
        let message: [u8; 38] = "failed to emit WebAssembly function section";
        record_emit_failure(out_ptr, 38, message);
        return -1;
    };
    offset = emit_memory_section(out_ptr, offset);
    if offset < 0 {
        let message: [u8; 36] = "failed to emit WebAssembly memory section";
        record_emit_failure(out_ptr, 36, message);
        return -1;
    };
    offset = emit_export_section(out_ptr, offset, ast_base, func_count, runtime_map_ptr);
    if offset < 0 {
        let message: [u8; 37] = "failed to emit WebAssembly export section";
        record_emit_failure(out_ptr, 37, message);
        return -1;
    };
    offset = emit_code_section(
        out_ptr,
        offset,
        ast_base,
        func_count,
        runtime_map_ptr,
        runtime_func_count,
    );
    if offset < 0 {
        let message: [u8; 34] = "failed to emit WebAssembly code section";
        record_emit_failure(out_ptr, 34, message);
        return -1;
    };
    offset
}

