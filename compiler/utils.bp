// Small helper routines that operate on the compiler's linear memory buffers.
// These are shared by both the parser and the emitter to avoid duplicating
// low-level pointer math.

fn memory_equal(a_ptr: i32, b_ptr: i32, len: i32) -> bool {
    let mut idx: i32 = 0;
    while idx < len {
        let a_byte: i32 = load_u8(a_ptr + idx);
        let b_byte: i32 = load_u8(b_ptr + idx);
        if a_byte != b_byte {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn memory_starts_with(
    ptr: i32,
    len: i32,
    const PREFIX_LEN: i32,
    prefix: [u8; PREFIX_LEN],
) -> bool {
    if PREFIX_LEN <= 0 {
        return true;
    }
    if ptr <= 0 {
        return false;
    }
    if len < PREFIX_LEN {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < PREFIX_LEN {
        let byte: i32 = load_u8(ptr + idx);
        if byte != prefix[idx] as i32 {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn string_length(ptr: i32) -> i32 {
    if ptr <= 0 {
        return -1;
    }
    let mut len: i32 = 0;
    while load_u8(ptr + len) != 0 {
        len = len + 1;
    };
    len
}

fn copy_bytes(dest: i32, src: i32, len: i32) {
    let mut idx: i32 = 0;
    while idx < len {
        let byte: i32 = load_u8(src + idx);
        store_u8(dest + idx, byte);
        idx = idx + 1;
    };
}

fn align_to(value: i32, alignment: i32) -> i32 {
    if alignment <= 0 {
        return value;
    }
    let mut adjusted: i32 = value + alignment - 1;
    adjusted = adjusted / alignment * alignment;
    adjusted
}

fn is_whitespace(byte: i32) -> bool {
    byte == ' ' || byte == '\t' || byte == '\n' || byte == '\r'
}
