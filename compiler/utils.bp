// Small helper routines that operate on the compiler's linear memory buffers.
// These are shared by both the parser and the emitter to avoid duplicating
// low-level pointer math.

fn memory_equal(a_ptr: i32, b_ptr: i32, len: i32) -> bool {
    let mut idx: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let a_byte: i32 = load_u8(a_ptr + idx);
        let b_byte: i32 = load_u8(b_ptr + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn string_length(ptr: i32) -> i32 {
    if ptr <= 0 {
        return -1;
    };
    let mut len: i32 = 0;
    loop {
        let byte: i32 = load_u8(ptr + len);
        if byte == 0 {
            break;
        };
        len = len + 1;
    };
    len
}

fn copy_bytes(dest: i32, src: i32, len: i32) {
    let mut idx: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(src + idx);
        store_u8(dest + idx, byte);
        idx = idx + 1;
    };
}

fn align_to(value: i32, alignment: i32) -> i32 {
    if alignment <= 0 {
        return value;
    };
    let mut adjusted: i32 = value + alignment - 1;
    adjusted = adjusted / alignment * alignment;
    adjusted
}

fn is_whitespace(byte: i32) -> bool {
    byte == ' ' || byte == '\t' || byte == '\n' || byte == '\r'
}

fn write_ascii_literal(base: i32, offset: i32, literal: [u8; 32]) -> i32 {
    let capacity: i32 = len(literal);
    let mut idx: i32 = 0;
    let mut next: i32 = offset;
    loop {
        if idx >= capacity {
            break;
        };
        let byte: i32 = literal[idx] as i32;
        if byte == 0 {
            break;
        };
        store_u8(base + next, byte);
        idx = idx + 1;
        next = next + 1;
    };
    next
}

fn write_diagnostic_literal(out_ptr: i32, literal: [u8; 32]) -> i32 {
    if out_ptr <= 0 {
        return 0;
    };
    let written: i32 = write_ascii_literal(out_ptr, 0, literal);
    store_u8(out_ptr + written, 0);
    written
}
