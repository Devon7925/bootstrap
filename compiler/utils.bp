// Small helper routines that operate on the compiler's linear memory buffers.
// These are shared by both the parser and the emitter to avoid duplicating
// low-level pointer math.

fn memory_equal(a_ptr: i32, b_ptr: i32, len: i32) -> bool {
    let mut idx: i32 = 0;
    while idx < len {
        let a_byte: i32 = load_u8(a_ptr + idx);
        let b_byte: i32 = load_u8(b_ptr + idx);
        if a_byte != b_byte {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn memory_starts_with(
    ptr: i32,
    len: i32,
    const PREFIX_LEN: i32,
    prefix: [u8; PREFIX_LEN],
) -> bool {
    if PREFIX_LEN <= 0 {
        return true;
    }
    if ptr <= 0 {
        return false;
    }
    if len < PREFIX_LEN {
        return false;
    }
    let mut idx: i32 = 0;
    while idx < PREFIX_LEN {
        let byte: i32 = load_u8(ptr + idx);
        if byte != prefix[idx] as i32 {
            return false;
        }
        idx = idx + 1;
    };
    true
}

fn string_length(ptr: i32) -> i32 {
    if ptr <= 0 {
        return -1;
    }
    let mut len: i32 = 0;
    while load_u8(ptr + len) != 0 {
        len = len + 1;
    };
    len
}

fn copy_bytes(dest: i32, src: i32, len: i32) {
    let mut idx: i32 = 0;
    while idx < len {
        let byte: i32 = load_u8(src + idx);
        store_u8(dest + idx, byte);
        idx = idx + 1;
    };
}

fn align_to(value: i32, alignment: i32) -> i32 {
    if alignment <= 0 {
        return value;
    }
    let mut adjusted: i32 = value + alignment - 1;
    adjusted = adjusted / alignment * alignment;
    adjusted
}

fn is_whitespace(byte: i32) -> bool {
    byte == ' ' || byte == '\t' || byte == '\n' || byte == '\r'
}

fn decimal_length(value: i32) -> i32 {
    if value <= 0 {
        return 1;
    }
    let mut digits: i32 = 0;
    let mut remaining: i32 = value;
    while remaining > 0 {
        digits = digits + 1;
        remaining = remaining / 10;
    };
    digits
}

fn write_decimal_digits_with_capacity(
    base: i32,
    capacity: i32,
    offset: i32,
    value: i32,
) -> (i32, bool) {
    if base <= 0 {
        return (offset, true);
    }
    if capacity <= 0 {
        return (offset, true);
    }
    if offset < 0 {
        return (offset, true);
    }
    let digits_len: i32 = decimal_length(value);
    let mut divisor: i32 = 1;
    let mut divisor_idx: i32 = 1;
    while divisor_idx < digits_len {
        divisor = divisor * 10;
        divisor_idx = divisor_idx + 1;
    };
    let mut next_offset: i32 = offset;
    let mut remaining: i32 = if value <= 0 { 0 } else { value };
    let mut written: i32 = 0;
    let mut truncated: bool = false;
    while written < digits_len {
        if next_offset >= capacity {
            truncated = true;
            break;
        }
        let digit: i32 = remaining / divisor;
        store_u8(base + next_offset, digit + '0');
        next_offset = next_offset + 1;
        remaining = remaining - digit * divisor;
        if divisor <= 1 {
            divisor = 1;
        } else {
            divisor = divisor / 10;
        }
        written = written + 1;
    };
    if written < digits_len {
        truncated = true;
    }
    (next_offset, truncated)
}

fn write_decimal_digits(base: i32, offset: i32, value: i32) -> i32 {
    let digits_len: i32 = decimal_length(value);
    if digits_len <= 0 {
        return offset;
    }
    let capacity: i32 = offset + digits_len;
    if capacity <= offset {
        return offset;
    }
    let result: (i32, bool) = write_decimal_digits_with_capacity(base, capacity, offset, value);
    result.0
}
