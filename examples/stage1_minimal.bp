fn write_byte(base: i32, offset: i32, value: i32) -> i32 {
    store_u8(base + offset, value & 255);
    offset + 1
}

fn emit_i32_const(base: i32, offset: i32, value: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 65);
    out = write_i32_leb(base, out, value);
    out
}

fn emit_add(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 106)
}

fn emit_sub(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 107)
}

fn emit_mul(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 108)
}

fn emit_div(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 109)
}

fn emit_end(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 11)
}

fn emit_local_get(base: i32, offset: i32, index: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 32);
    out = write_u32_leb(base, out, index);
    out
}

fn emit_local_set(base: i32, offset: i32, index: i32) -> i32 {
    let mut out: i32 = write_byte(base, offset, 33);
    out = write_u32_leb(base, out, index);
    out
}

fn emit_return(base: i32, offset: i32) -> i32 {
    write_byte(base, offset, 15)
}

fn is_identifier_start(byte: i32) -> bool {
    (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122) || byte == 95
}

fn is_identifier_continue(byte: i32) -> bool {
    is_identifier_start(byte) || (byte >= 48 && byte <= 57)
}

fn identifiers_equal(
    base: i32,
    len: i32,
    a_start: i32,
    a_len: i32,
    b_start: i32,
    b_len: i32
) -> bool {
    if a_len != b_len {
        return false;
    };
    if a_len < 0 {
        return false;
    };
    if a_start < 0 || b_start < 0 {
        return false;
    };
    if a_start + a_len > len {
        return false;
    };
    if b_start + b_len > len {
        return false;
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= a_len {
            break;
        };
        let a_byte: i32 = load_u8(base + a_start + idx);
        let b_byte: i32 = load_u8(base + b_start + idx);
        if a_byte != b_byte {
            return false;
        };
        idx = idx + 1;
    };
    true
}

fn locals_find(
    base: i32,
    len: i32,
    locals_base: i32,
    locals_count_ptr: i32,
    name_start: i32,
    name_len: i32
) -> i32 {
    let count: i32 = load_i32(locals_count_ptr);
    let mut idx: i32 = 0;
    loop {
        if idx >= count {
            break;
        };
        let entry: i32 = locals_base + idx * 12;
        let stored_start: i32 = load_i32(entry);
        let stored_len: i32 = load_i32(entry + 4);
        if identifiers_equal(
            base,
            len,
            stored_start,
            stored_len,
            name_start,
            name_len
        ) {
            return load_i32(entry + 8);
        };
        idx = idx + 1;
    };
    -1
}

fn locals_store_entry(
    locals_base: i32,
    locals_count_ptr: i32,
    name_start: i32,
    name_len: i32,
    local_index: i32
) {
    let entry: i32 = locals_base + local_index * 12;
    store_i32(entry, name_start);
    store_i32(entry + 4, name_len);
    store_i32(entry + 8, local_index);
    store_i32(locals_count_ptr, local_index + 1);
}

fn write_u32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let mut byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        if remaining != 0 {
            byte = byte | 128;
        };
        out = write_byte(base, out, byte);
        if remaining == 0 {
            break;
        };
    };
    out
}

fn write_i32_leb(base: i32, offset: i32, value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut out: i32 = offset;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        let mut out_byte: i32 = byte;
        if !done {
            out_byte = out_byte | 128;
        };
        out = write_byte(base, out, out_byte);
        if done {
            break;
        };
    };
    out
}

fn leb_u32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        count = count + 1;
        remaining = remaining >> 7;
        if remaining == 0 {
            break;
        };
    };
    count
}

fn leb_i32_len(value: i32) -> i32 {
    let mut remaining: i32 = value;
    let mut count: i32 = 0;
    loop {
        let byte: i32 = remaining & 127;
        remaining = remaining >> 7;
        let sign_bit: i32 = byte & 64;
        let done: bool = (remaining == 0 && sign_bit == 0) || (remaining == -1 && sign_bit != 0);
        count = count + 1;
        if done {
            break;
        };
    };
    count
}

fn write_magic(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 97);
    out = write_byte(base, out, 115);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 0);
    out
}

fn is_whitespace(byte: i32) -> bool {
    byte == 32 || byte == 9 || byte == 10 || byte == 13
}

fn skip_whitespace(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = offset;
    loop {
        if idx >= len {
            break;
        };
        let byte: i32 = load_u8(base + idx);
        if !is_whitespace(byte) {
            break;
        };
        idx = idx + 1;
    };
    idx
}

fn expect_char(base: i32, len: i32, offset: i32, expected: i32) -> i32 {
    if offset >= len {
        return -1;
    };
    let byte: i32 = load_u8(base + offset);
    if byte != expected {
        return -1;
    };
    offset + 1
}

fn expect_keyword_fn(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 102);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_let(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 108);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 101);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 116);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_main(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 109);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 97);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 110);
    if idx < 0 {
        return -1;
    };
    idx
}

fn expect_keyword_i32(base: i32, len: i32, offset: i32) -> i32 {
    let mut idx: i32 = expect_char(base, len, offset, 105);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 51);
    if idx < 0 {
        return -1;
    };
    idx = expect_char(base, len, idx, 50);
    if idx < 0 {
        return -1;
    };
    idx
}

fn peek_byte(base: i32, len: i32, offset: i32) -> i32 {
    if offset >= len {
        -1
    } else {
        load_u8(base + offset)
    }
}

fn write_type_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 1);
    out = write_u32_leb(base, out, 5);
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 96);
    out = write_byte(base, out, 0);
    out = write_byte(base, out, 1);
    out = write_byte(base, out, 127);
    out
}

fn write_function_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 3);
    out = write_u32_leb(base, out, 2);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, 0);
    out
}

fn write_memory_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 5);
    out = write_u32_leb(base, out, 3);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, 0);
    out = write_u32_leb(base, out, 1);
    out
}

fn write_export_section(base: i32, offset: i32) -> i32 {
    let mut out: i32 = offset;
    out = write_byte(base, out, 7);
    out = write_u32_leb(base, out, 17);
    out = write_u32_leb(base, out, 2);
    out = write_u32_leb(base, out, 6);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 101);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 111);
    out = write_byte(base, out, 114);
    out = write_byte(base, out, 121);
    out = write_byte(base, out, 2);
    out = write_u32_leb(base, out, 0);
    out = write_u32_leb(base, out, 4);
    out = write_byte(base, out, 109);
    out = write_byte(base, out, 97);
    out = write_byte(base, out, 105);
    out = write_byte(base, out, 110);
    out = write_byte(base, out, 0);
    out = write_u32_leb(base, out, 0);
    out
}

fn write_code_section(
    base: i32,
    offset: i32,
    instr_base: i32,
    instr_len: i32,
    local_count: i32
) -> i32 {
    let local_decl_size: i32 = if local_count == 0 {
        1
    } else {
        let count_len: i32 = leb_u32_len(local_count);
        1 + count_len + 1
    };
    let body_size: i32 = local_decl_size + instr_len;
    let body_size_len: i32 = leb_u32_len(body_size);
    let section_size: i32 = 1 + body_size_len + body_size;
    let mut out: i32 = offset;
    out = write_byte(base, out, 10);
    out = write_u32_leb(base, out, section_size);
    out = write_u32_leb(base, out, 1);
    out = write_u32_leb(base, out, body_size);
    if local_count == 0 {
        out = write_byte(base, out, 0);
    } else {
        out = write_byte(base, out, 1);
        out = write_u32_leb(base, out, local_count);
        out = write_byte(base, out, 127);
    };
    let mut idx: i32 = 0;
    loop {
        if idx >= instr_len {
            break;
        };
        let byte: i32 = load_u8(instr_base + idx);
        out = write_byte(base, out, byte);
        idx = idx + 1;
    };
    out
}

fn write_constant_module(base: i32, instr_base: i32, instr_len: i32, local_count: i32) -> i32 {
    let mut offset: i32 = 0;
    offset = write_magic(base, offset);
    offset = write_type_section(base, offset);
    offset = write_function_section(base, offset);
    offset = write_memory_section(base, offset);
    offset = write_export_section(base, offset);
    write_code_section(base, offset, instr_base, instr_len, local_count)
}

fn parse_expression(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_term(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr
    );
    if idx < 0 {
        return -1;
    };

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte == 43 || op_byte == 45 {
            idx = idx + 1;
            let next_idx: i32 = parse_term(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr
            );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;

            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            if op_byte == 43 {
                instr_offset = emit_add(instr_base, instr_offset);
            } else {
                instr_offset = emit_sub(instr_base, instr_offset);
            };
            store_i32(instr_offset_ptr, instr_offset);
            continue;
        };

        if op_byte == 41 || op_byte == 59 || op_byte == 125 {
            break;
        };

        return -1;
    };

    idx
}

fn parse_term(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32
) -> i32 {
    let mut idx: i32 = parse_value(
        base,
        len,
        offset,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr
    );
    if idx < 0 {
        return -1;
    };

    loop {
        idx = skip_whitespace(base, len, idx);
        if idx >= len {
            break;
        };

        let op_byte: i32 = peek_byte(base, len, idx);
        if op_byte == 42 || op_byte == 47 {
            idx = idx + 1;
            let next_idx: i32 = parse_value(
                base,
                len,
                idx,
                instr_base,
                instr_offset_ptr,
                locals_base,
                locals_count_ptr
            );
            if next_idx < 0 {
                return -1;
            };
            idx = next_idx;

            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            if op_byte == 42 {
                instr_offset = emit_mul(instr_base, instr_offset);
            } else {
                instr_offset = emit_div(instr_base, instr_offset);
            };
            store_i32(instr_offset_ptr, instr_offset);
            continue;
        };

        break;
    };

    idx
}

fn parse_value(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32
) -> i32 {
    let mut idx: i32 = skip_whitespace(base, len, offset);
    if idx >= len {
        return -1;
    };

    let mut sign: i32 = 1;
    loop {
        if idx >= len {
            return -1;
        };
        let byte: i32 = peek_byte(base, len, idx);
        if byte == 45 {
            sign = sign * -1;
            idx = idx + 1;
        } else if byte == 43 {
            idx = idx + 1;
        } else {
            break;
        };
        idx = skip_whitespace(base, len, idx);
    };

    if idx >= len {
        return -1;
    };

    let head_byte: i32 = peek_byte(base, len, idx);
    if head_byte == 40 {
        idx = idx + 1;
        if sign == -1 {
            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            instr_offset = emit_i32_const(instr_base, instr_offset, 0);
            store_i32(instr_offset_ptr, instr_offset);
        };
        let inner_idx: i32 = parse_expression(
            base,
            len,
            idx,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr
        );
        if inner_idx < 0 {
            return -1;
        };
        idx = skip_whitespace(base, len, inner_idx);
        idx = expect_char(base, len, idx, 41);
        if idx < 0 {
            return -1;
        };
        if sign == -1 {
            let mut instr_offset: i32 = load_i32(instr_offset_ptr);
            instr_offset = emit_sub(instr_base, instr_offset);
            store_i32(instr_offset_ptr, instr_offset);
        };
        return idx;
    };

    if is_identifier_start(head_byte) {
        let ident_start: i32 = idx;
        let mut ident_len: i32 = 0;
        loop {
            if idx >= len {
                break;
            };
            let ch: i32 = peek_byte(base, len, idx);
            if ident_len == 0 {
                if !is_identifier_start(ch) {
                    break;
                };
            } else if !is_identifier_continue(ch) {
                break;
            };
            ident_len = ident_len + 1;
            idx = idx + 1;
        };
        if ident_len == 0 {
            return -1;
        };
        let local_index: i32 = locals_find(
            base,
            len,
            locals_base,
            locals_count_ptr,
            ident_start,
            ident_len
        );
        if local_index < 0 {
            return -1;
        };
        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        if sign == -1 {
            instr_offset = emit_i32_const(instr_base, instr_offset, 0);
        };
        instr_offset = emit_local_get(instr_base, instr_offset, local_index);
        if sign == -1 {
            instr_offset = emit_sub(instr_base, instr_offset);
        };
        store_i32(instr_offset_ptr, instr_offset);
        return idx;
    };

    if head_byte < 48 || head_byte > 57 {
        return -1;
    };

    let mut value: i32 = 0;
    let mut has_digit: bool = false;
    loop {
        if idx >= len {
            break;
        };
        let digit_byte: i32 = peek_byte(base, len, idx);
        if digit_byte < 48 || digit_byte > 57 {
            break;
        };
        let digit: i32 = digit_byte - 48;
        value = value * 10 + digit;
        has_digit = true;
        idx = idx + 1;
    };

    if !has_digit {
        return -1;
    };

    if sign == -1 {
        value = 0 - value;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_i32_const(instr_base, instr_offset, value);
    store_i32(instr_offset_ptr, instr_offset);

    idx
}

fn parse_let_statement(
    base: i32,
    len: i32,
    offset: i32,
    instr_base: i32,
    instr_offset_ptr: i32,
    locals_base: i32,
    locals_count_ptr: i32
) -> i32 {
    let mut idx: i32 = expect_keyword_let(base, len, offset);
    if idx < 0 {
        return -1;
    };
    if idx >= len {
        return -1;
    };
    let after_keyword: i32 = peek_byte(base, len, idx);
    if !is_whitespace(after_keyword) {
        return -1;
    };
    idx = skip_whitespace(base, len, idx);
    if idx >= len {
        return -1;
    };

    let name_start: i32 = idx;
    let mut name_len: i32 = 0;
    loop {
        if idx >= len {
            break;
        };
        let ch: i32 = peek_byte(base, len, idx);
        if name_len == 0 {
            if !is_identifier_start(ch) {
                break;
            };
        } else if !is_identifier_continue(ch) {
            break;
        };
        name_len = name_len + 1;
        idx = idx + 1;
    };
    if name_len == 0 {
        return -1;
    };

    let existing: i32 = locals_find(
        base,
        len,
        locals_base,
        locals_count_ptr,
        name_start,
        name_len
    );
    if existing >= 0 {
        return -1;
    };

    let local_index: i32 = load_i32(locals_count_ptr);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 58);
    if idx < 0 {
        return -1;
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_keyword_i32(base, len, idx);
    if idx < 0 {
        return -1;
    };

    if idx < len {
        let after_type: i32 = peek_byte(base, len, idx);
        if after_type != 61 && !is_whitespace(after_type) {
            return -1;
        };
    };

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 61);
    if idx < 0 {
        return -1;
    };

    idx = parse_expression(
        base,
        len,
        idx,
        instr_base,
        instr_offset_ptr,
        locals_base,
        locals_count_ptr
    );
    if idx < 0 {
        return -1;
    };

    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
    instr_offset = emit_local_set(instr_base, instr_offset, local_index);
    store_i32(instr_offset_ptr, instr_offset);

    idx = skip_whitespace(base, len, idx);
    idx = expect_char(base, len, idx, 59);
    if idx < 0 {
        return -1;
    };

    locals_store_entry(locals_base, locals_count_ptr, name_start, name_len, local_index);

    idx
}

fn compile(input_ptr: i32, input_len: i32, out_ptr: i32) -> i32 {
    if input_len == 0 {
        return -1;
    };

    let mut offset: i32 = skip_whitespace(input_ptr, input_len, 0);

    offset = expect_keyword_fn(input_ptr, input_len, offset);
    if offset < 0 {
        return -1;
    };

    if offset >= input_len {
        return -1;
    };
    let after_fn_byte: i32 = peek_byte(input_ptr, input_len, offset);
    if after_fn_byte < 0 || !is_whitespace(after_fn_byte) {
        return -1;
    };
    let mut next_offset: i32 = skip_whitespace(input_ptr, input_len, offset);
    if next_offset == offset {
        return -1;
    };
    offset = next_offset;

    offset = expect_keyword_main(input_ptr, input_len, offset);
    if offset < 0 {
        return -1;
    };

    if offset >= input_len {
        return -1;
    };
    let after_main_byte: i32 = peek_byte(input_ptr, input_len, offset);
    if after_main_byte != 40 && !is_whitespace(after_main_byte) {
        return -1;
    };
    offset = skip_whitespace(input_ptr, input_len, offset);

    offset = expect_char(input_ptr, input_len, offset, 40);
    if offset < 0 {
        return -1;
    };

    offset = skip_whitespace(input_ptr, input_len, offset);

    offset = expect_char(input_ptr, input_len, offset, 41);
    if offset < 0 {
        return -1;
    };

    offset = skip_whitespace(input_ptr, input_len, offset);

    offset = expect_char(input_ptr, input_len, offset, 45);
    if offset < 0 {
        return -1;
    };
    offset = expect_char(input_ptr, input_len, offset, 62);
    if offset < 0 {
        return -1;
    };

    offset = skip_whitespace(input_ptr, input_len, offset);

    offset = expect_keyword_i32(input_ptr, input_len, offset);
    if offset < 0 {
        return -1;
    };

    if offset >= input_len {
        return -1;
    };
    let after_type_byte: i32 = peek_byte(input_ptr, input_len, offset);
    if after_type_byte != 123 && !is_whitespace(after_type_byte) {
        return -1;
    };
    offset = skip_whitespace(input_ptr, input_len, offset);

    offset = expect_char(input_ptr, input_len, offset, 123);
    if offset < 0 {
        return -1;
    };

    let instr_base: i32 = out_ptr + 8192;
    let instr_offset_ptr: i32 = out_ptr + 4096;
    store_i32(instr_offset_ptr, 0);
    let locals_count_ptr: i32 = out_ptr + 12280;
    let locals_base: i32 = out_ptr + 12288;
    store_i32(locals_count_ptr, 0);

    let mut current_offset: i32 = offset;

    loop {
        current_offset = skip_whitespace(input_ptr, input_len, current_offset);
        if current_offset >= input_len {
            return -1;
        };

        let current_byte: i32 = peek_byte(input_ptr, input_len, current_offset);
        if current_byte == 125 {
            return -1;
        };

        if current_offset + 3 <= input_len {
            let l: i32 = peek_byte(input_ptr, input_len, current_offset);
            if l == 108 {
                let e: i32 = peek_byte(input_ptr, input_len, current_offset + 1);
                let t: i32 = peek_byte(input_ptr, input_len, current_offset + 2);
                if e == 101 && t == 116 {
                    let after_keyword: i32 = current_offset + 3;
                    let mut after_char: i32 = -1;
                    if after_keyword < input_len {
                        after_char = peek_byte(input_ptr, input_len, after_keyword);
                    };
                    if after_keyword >= input_len || !is_identifier_continue(after_char) {
                        let next_offset: i32 = parse_let_statement(
                            input_ptr,
                            input_len,
                            current_offset,
                            instr_base,
                            instr_offset_ptr,
                            locals_base,
                            locals_count_ptr
                        );
                        if next_offset < 0 {
                            return -1;
                        };
                        current_offset = next_offset;
                        continue;
                    };
                };
            };
        };

        if current_offset + 6 <= input_len {
            let r: i32 = peek_byte(input_ptr, input_len, current_offset);
            if r == 114 {
                let e: i32 = peek_byte(input_ptr, input_len, current_offset + 1);
                let t: i32 = peek_byte(input_ptr, input_len, current_offset + 2);
                let u: i32 = peek_byte(input_ptr, input_len, current_offset + 3);
                let rn: i32 = peek_byte(input_ptr, input_len, current_offset + 4);
                let n: i32 = peek_byte(input_ptr, input_len, current_offset + 5);
                if e == 101 && t == 116 && u == 117 && rn == 114 && n == 110 {
                    let after_return: i32 = current_offset + 6;
                    if after_return >= input_len {
                        return -1;
                    };
                    let after_return_byte: i32 = peek_byte(input_ptr, input_len, after_return);
                    if !is_whitespace(after_return_byte) {
                        return -1;
                    };
                    let mut expr_offset: i32 =
                        skip_whitespace(input_ptr, input_len, after_return);
                    if expr_offset == after_return {
                        return -1;
                    };
                    expr_offset = parse_expression(
                        input_ptr,
                        input_len,
                        expr_offset,
                        instr_base,
                        instr_offset_ptr,
                        locals_base,
                        locals_count_ptr
                    );
                    if expr_offset < 0 {
                        return -1;
                    };
                    expr_offset = skip_whitespace(input_ptr, input_len, expr_offset);
                    expr_offset = expect_char(input_ptr, input_len, expr_offset, 59);
                    if expr_offset < 0 {
                        return -1;
                    };
                    expr_offset = skip_whitespace(input_ptr, input_len, expr_offset);
                    expr_offset = expect_char(input_ptr, input_len, expr_offset, 125);
                    if expr_offset < 0 {
                        return -1;
                    };
                    expr_offset = skip_whitespace(input_ptr, input_len, expr_offset);
                    if expr_offset != input_len {
                        return -1;
                    };
                    let mut instr_offset: i32 = load_i32(instr_offset_ptr);
                    instr_offset = emit_return(instr_base, instr_offset);
                    instr_offset = emit_end(instr_base, instr_offset);
                    let local_count: i32 = load_i32(locals_count_ptr);
                    return write_constant_module(out_ptr, instr_base, instr_offset, local_count);
                };
            };
        };

        let expr_offset: i32 = parse_expression(
            input_ptr,
            input_len,
            current_offset,
            instr_base,
            instr_offset_ptr,
            locals_base,
            locals_count_ptr
        );
        if expr_offset < 0 {
            return -1;
        };

        let mut after_expr: i32 = skip_whitespace(input_ptr, input_len, expr_offset);
        if after_expr < input_len {
            let maybe_semicolon: i32 = peek_byte(input_ptr, input_len, after_expr);
            if maybe_semicolon == 59 {
                after_expr = after_expr + 1;
                after_expr = skip_whitespace(input_ptr, input_len, after_expr);
            };
        };

        after_expr = expect_char(input_ptr, input_len, after_expr, 125);
        if after_expr < 0 {
            return -1;
        };

        after_expr = skip_whitespace(input_ptr, input_len, after_expr);
        if after_expr != input_len {
            return -1;
        };

        let mut instr_offset: i32 = load_i32(instr_offset_ptr);
        instr_offset = emit_end(instr_base, instr_offset);
        let local_count: i32 = load_i32(locals_count_ptr);
        return write_constant_module(out_ptr, instr_base, instr_offset, local_count);
    };

    -1
}

fn main() -> i32 {
    0
}
